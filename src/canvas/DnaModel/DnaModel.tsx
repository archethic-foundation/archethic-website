/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.11 ./dna.glb -p 5 --types
*/
import React, { useEffect, useRef, useState } from 'react'
import { useBreakpoints } from '@/utils/hooks/useBreakpoints'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import { Color, Vector3 } from 'three'
import { GLTF } from 'three-stdlib'

import fragmentShader from './shaders/fragmentShader'
import vertexShader from './shaders/vertexShader'

const PATH = '/canvas/model/DnaModel.glb'

type GLTFResult = GLTF & {
  nodes: {
    twist1_1: THREE.Mesh
  }
  materials: {
    ['Material.002']: THREE.MeshBasicMaterial
  }
}

type DnaModelProps = JSX.IntrinsicElements['group'] & {
  controls?: {
    autoRotateSpeed: number
    dotSize: number
    uColor1: string
    uColor2: string
  }
}

const CONTROLS = {
  dotSize: 50,
  uColor1: '#4027a2',
  uColor2: '#d55cff',
  autoRotateSpeed: 25,
}

export function DnaModel(props: DnaModelProps) {
  const meshRef = useRef<THREE.Points>(null)
  const { nodes } = useGLTF(PATH) as GLTFResult
  const [, setAdditionalRotation] = useState(0)
  const additionalRotationRef = useRef(0)
  const { isScreenSmall } = useBreakpoints()

  const uniforms = {
    time: { value: 0 },
    dotSize: { value: CONTROLS.dotSize || 50 },
    uColor1: { value: new THREE.Color(CONTROLS.uColor1 || '#4027a2') },
    uColor2: { value: new THREE.Color(CONTROLS.uColor2 || '#d55cff') },
    uColor3: { value: new Color(0xffffff) },
    colorC: { value: new Vector3(0.912, 0.191, 0.652) },
    resolution: { value: new THREE.Vector4() },
  }

  useFrame(({ clock }) => {
    if (!meshRef.current) return

    const elapsedTime = clock.getElapsedTime()
    const toSubtract = CONTROLS.autoRotateSpeed

    meshRef.current.rotation.y = elapsedTime / toSubtract + additionalRotationRef.current
  })

  useEffect(() => {
    if (meshRef.current) {
      meshRef.current.geometry.center()

      const number = meshRef.current?.geometry.attributes.position.array.length

      let randoms = new Float32Array(number / 3)
      let colorRandoms = new Float32Array(number / 3)

      for (let i = 0; i < number / 3; i++) {
        randoms.set([Math.random()], i)
        colorRandoms.set([Math.random()], i)
      }

      meshRef.current.geometry.setAttribute('randoms', new THREE.BufferAttribute(randoms, 1))
      meshRef.current.geometry.setAttribute(
        'colorRandoms',
        new THREE.BufferAttribute(colorRandoms, 1)
      )
    }
  }, [])

  useEffect(() => {
    let lastKnownScrollPosition = 0
    let scrollY = 0

    const handleScroll = () => {
      if (!meshRef.current || isScreenSmall) return

      scrollY = window.scrollY - lastKnownScrollPosition
      lastKnownScrollPosition = window.scrollY

      setAdditionalRotation((prev) => {
        const newRotation = window.scrollY < 50 ? prev : prev + scrollY * 0.0005
        additionalRotationRef.current = newRotation
        return newRotation
      })
    }

    window.addEventListener('scroll', handleScroll)

    return () => {
      window.removeEventListener('scroll', handleScroll)
    }
  }, [isScreenSmall])

  return (
    <group {...props} dispose={null}>
      <points ref={meshRef} geometry={nodes.twist1_1.geometry}>
        <shaderMaterial
          fragmentShader={fragmentShader}
          vertexShader={vertexShader}
          side={THREE.DoubleSide}
          uniforms={uniforms}
          // wireframe: true
          transparent={true}
          depthTest={false}
          depthWrite={false}
          blending={THREE.AdditiveBlending}
        />
      </points>
    </group>
  )
}

useGLTF.preload(PATH)
