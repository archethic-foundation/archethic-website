import{S as c,o as h,_ as d}from"./sui-Br5LV7cS-KJfd6RRJ.js";import{bz as m}from"./index-Bibw8odz.js";import{T as p}from"./create-D7FD56l0-D2uTFRvt.js";import{b as w}from"./chain-DfK5JtF7-Jmo_aVnV.js";var l=Object.defineProperty,g=(a,e,t)=>e in a?l(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,s=(a,e,t)=>(g(a,typeof e!="symbol"?e+"":e,t),t);class i{constructor(e,t,n,o){s(this,"network"),s(this,"chain"),s(this,"provider"),s(this,"contracts"),s(this,"chainId"),s(this,"coreBridgePackageId"),this.network=e,this.chain=t,this.provider=n,this.contracts=o,this.chainId=m(t);const r=o.coreBridge;if(!r)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=r}getGuardianSet(e){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[n,o]=await c.chainFromRpc(e),r=t[o];if(r.network!==n)throw new Error(`Network mismatch: ${r.network} !== ${n}`);return new i(n,o,e,r.contracts)}async*verifyMessage(e,t){throw new Error("Method not implemented.")}async*publishMessage(e,t){throw new Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(t=>({emitter:t.emitterAddress,sequence:t.sequence,chain:this.chain}))}async getGuardianSetIndex(){throw new Error("Method not implemented.")}async parseMessages(e){var t;const n=(t=(await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}})).events)==null?void 0:t.filter(o=>o.type.endsWith("WormholeMessage"));if(!n||n.length==0)throw new Error("WormholeMessage not found");return n.map(o=>{const r=o.parsedJson;return p("Uint8Array",{emitterChain:this.chain,emitterAddress:new h(r.sender).toUniversalAddress(),sequence:BigInt(r.sequence),guardianSet:0,timestamp:Number(r.timestamp),consistencyLevel:r.consistency_level,nonce:r.nonce,signatures:[],payload:new Uint8Array(r.payload)})})}}w(d,"WormholeCore",i);export{i as SuiWormholeCore};
