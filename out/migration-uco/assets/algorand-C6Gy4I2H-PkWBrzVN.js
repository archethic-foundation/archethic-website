const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CqJuSw0V-HnIqbu9o.js","assets/index-Bibw8odz.js","assets/index-BelLbmDI.css","assets/create-D7FD56l0-D2uTFRvt.js","assets/chain-DfK5JtF7-Jmo_aVnV.js","assets/index-BC7PTIqY-3HSphiOR.js"])))=>i.map(i=>d[i]);
import{aE as S,aG as y,bJ as T,bK as C,bh as p,aN as _,bL as B,aH as R,bM as c,aI as j,aJ as k,aK as w,aL as x,aM as D,_ as I,aO as z,bN as F,bO as O}from"./index-Bibw8odz.js";import{I as U,R as L}from"./chain-DfK5JtF7-Jmo_aVnV.js";var P=Object.defineProperty,$=(o,t,n)=>t in o?P(o,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):o[t]=n,u=(o,t,n)=>($(o,typeof t!="symbol"?t+"":t,n),n);const h="Algorand";function K(o){if(o<BigInt(Number.MIN_SAFE_INTEGER)||o>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Integer is unsafe");return Number(o)}const M="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ",b=class l{constructor(t){if(u(this,"type","Native"),u(this,"address"),l.instanceof(t))this.address=t.address;else if(y.instanceof(t))this.address=t.toUint8Array();else if(t instanceof Uint8Array&&t.byteLength===l.byteSize)this.address=t;else if(typeof t=="string"&&T(t))this.address=C(t).publicKey;else if(typeof t=="string"&&!isNaN(parseInt(t)))this.address=p.zpad(_.toBytes(BigInt(t),8),l.byteSize);else if(typeof t=="bigint")this.address=p.zpad(_.toBytes(t,8),l.byteSize);else if(t instanceof Uint8Array&&t.byteLength===8)this.address=p.zpad(t,l.byteSize);else throw new Error(`Invalid Algorand address or ASA ID: ${t}`)}unwrap(){return this.toString()}toString(){return B(this.address)}toNative(){return this}toUint8Array(){return this.address}toUniversalAddress(){return new y(this.toUint8Array())}toBigInt(){return _.decode(this.toUint8Array().slice(24,32))}toInt(){return K(this.toBigInt())}equals(t){return l.instanceof(t)?t.address===this.address:this.toUniversalAddress().equals(t)}static instanceof(t){return t.constructor.platform===h}};u(b,"byteSize",32),u(b,"platform",h);let A=b;S(h,A);class E extends L{}const N=class g extends U{constructor(t,n){super(t,n??R(t,g._platform))}getRpc(t){if(t in this.config)return new c.Algodv2("",this.config[t].rpc);throw new Error("No configuration available for chain: "+t)}getChain(t){if(t in this.config)return new E(t,this);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(t,n){if(!g.isSupportedChain(n))throw new Error(`invalid chain for Algorand: ${n}`);return j.chainAddress(n,M)}static isNativeTokenId(t,n,e){return!g.isSupportedChain(n)||e.chain!==n?!1:this.nativeTokenId(t,n)==e}static isSupportedChain(t){return k(t)===g._platform}static async getDecimals(t,n,e){const a=w(e)?0:new A(e).toInt();if(a===0)return x(g._platform);const i=await n.getAssetByID(a).do(),s=c.modelsv2.Asset.from_obj_for_encoding(i);if(!s.params||!s.params.decimals)throw new Error("Could not fetch token details");return Number(s.params.decimals)}static async getBalance(t,n,e,a){const i=w(a)?0:new A(a).toInt();if(i===0){const f=await n.accountInformation(e).do(),d=c.modelsv2.Account.from_obj_for_encoding(f);return BigInt(d.amount)}const s=await n.accountAssetInformation(e,i).do(),r=c.modelsv2.AssetHolding.from_obj_for_encoding(s);return BigInt(r.amount)}static async getBalances(t,n,e,a){let i;if(a.includes("native")){const s=await n.accountInformation(e).do(),r=c.modelsv2.Account.from_obj_for_encoding(s);i=BigInt(r.amount)}return a.map(async s=>{if(w(s))return{native:i};const r=new A(s).toInt(),f=await n.accountAssetInformation(e,r).do(),d=c.modelsv2.AssetHolding.from_obj_for_encoding(f);return BigInt(d.amount)}).reduce((s,r)=>Object.assign(s,r),{})}static async sendWait(t,n,e){const a=e.map((r,f)=>c.decodeSignedTransaction(r)).map((r,f)=>r.txn.txID()),{txId:i}=await n.sendRawTransaction(e).do();if(!i)throw new Error("Transaction(s) failed to send");const s=await c.waitForConfirmation(n,i,4);if(!c.modelsv2.PendingTransactionResponse.from_obj_for_encoding(s).confirmedRound)throw new Error("Transaction(s) could not be confirmed in 4 rounds");return a}static async getLatestBlock(t){const n=await t.status().do(),e=c.modelsv2.NodeStatusResponse.from_obj_for_encoding(n);if(!e.lastRound)throw new Error("Error getting status from node");return Number(e.lastRound)}static async getLatestFinalizedBlock(t){const n=await t.status().do(),e=c.modelsv2.NodeStatusResponse.from_obj_for_encoding(n);if(!e.lastRound)throw new Error("Error getting status from node");return Number(e.lastRound)}static chainFromChainId(t){const n=D(g._platform,t);if(n===void 0)throw new Error(`Unknown native chain id ${t}`);const[e,a]=n;return[e,a]}static async chainFromRpc(t){const n=await t.versionsCheck().do(),e=c.modelsv2.Version.from_obj_for_encoding(n);return this.chainFromChainId(e.genesisId)}};u(N,"_platform",h);let v=N;async function H(o,t){const[n,e]=await v.chainFromRpc(o);return new G(e,o,t)}class G{constructor(t,n,e,a=!1){u(this,"_chain"),u(this,"_debug"),u(this,"_account"),this._chain=t,this._debug=a,this._account=F(e)}chain(){return this._chain}address(){return this._account.addr}async sign(t){const n=[],e=t.map((s,r)=>s.transaction.tx),a=O(e),i=t.map((s,r)=>(s.transaction.tx=a[r],s));for(const s of i){const{description:r,transaction:f}=s,{tx:d,signer:m}=f;this._debug&&(console.log(d._getDictForDisplay()),console.log(d.txID())),m?(this._debug&&console.log(`Signing: ${r} with signer ${m.address} for address ${this.address()}`),n.push(await m.signTxn(d))):(this._debug&&console.log(`Signing: ${r} without signer for address ${this.address()}`),n.push(d.signTxn(this._account.sk)))}return n}}const V={Address:A,Platform:v,getSigner:H,protocols:{WormholeCore:()=>I(()=>import("./index-CqJuSw0V-HnIqbu9o.js"),__vite__mapDeps([0,1,2,3,4])).then(o=>o.i),TokenBridge:()=>I(()=>import("./index-BC7PTIqY-3HSphiOR.js"),__vite__mapDeps([5,0,1,2,3,4]))},getChain:(o,t,n)=>new E(t,new v(o,z(o,h,{[t]:n})))},J=Object.freeze(Object.defineProperty({__proto__:null,default:V},Symbol.toStringTag,{value:"Module"}));export{A,h as _,v as a,J as b,K as s};
