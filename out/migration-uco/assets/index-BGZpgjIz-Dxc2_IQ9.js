import"./index-B1gEeodR-D_86SREc.js";import{C as l,a as i,G as T,_ as W}from"./cosmwasm-DQIRZxXO-zm4kDnj4.js";import{T as o,h as w,F as N}from"./unsignedTransaction-FNxPjbl8-mlU_xnKV.js";import{aK as f,bg as c,bz as b,aS as A,c3 as x,aG as E,c4 as y}from"./index-Bibw8odz.js";import{b as q}from"./chain-DfK5JtF7-Jmo_aVnV.js";import"./create-D7FD56l0-D2uTFRvt.js";import"./ens-validation.es6-wfrgcl4a-DnAHJYLr.js";import"./index-DQlzy8aC-BLa2RM0w.js";var D=Object.defineProperty,$=(h,t,e)=>t in h?D(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e,d=(h,t,e)=>($(h,typeof t!="symbol"?t+"":t,e),e);class k{constructor(t,e,r,n){d(this,"network"),d(this,"chain"),d(this,"rpc"),d(this,"contracts"),d(this,"tokenBridge"),d(this,"translator"),this.network=t,this.chain=e,this.rpc=r,this.contracts=n;const a=this.contracts.tokenBridge;if(!a)throw new Error(`Wormhole Token Bridge contract for domain ${e} not found`);if(this.tokenBridge=a,this.translator=this.contracts.translator,this.translator!==void 0&&this.translator==="")throw new Error("Translator address may be undefined but not empty string")}static async fromRpc(t,e){const[r,n]=await l.chainFromRpc(t),a=e[n];if(a.network!==r)throw new Error(`Network mismatch: ${a.network} != ${r}`);return new k(r,n,t,e[n].contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{}return!1}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(t.chain===this.chain)throw new Error(`Expected foreign chain, got ${t.chain}`);if(f(t.address))throw new Error("Native asset cannot be a wrapped asset");const e=c.encode(t.address.toUniversalAddress().toUint8Array()),{address:r}=await this.rpc.queryContractSmart(this.tokenBridge,{wrapped_registry:{chain:b(t.chain),address:e}});return A(this.chain,r)}async getOriginalAsset(t){let e=new i(t);e.denomType==="factory"&&(e=T.factoryToCw20(e));const r=await this.rpc.queryContractSmart(e.toString(),{wrapped_asset_info:{}}),n=x(r.asset_chain),a=c.decode(r.asset_address);return{chain:n,address:new E(new Uint8Array(a))}}async isTransferCompleted(t){const e=c.encode(y(t));return(await this.rpc.queryContractSmart(this.tokenBridge,{is_vaa_redeemed:{vaa:e}})).is_redeemed}async*createAttestation(t,e){if(!e)throw new Error("Payer required to create attestation");const r=new i(t).toString(),n=new i(e).toString(),a=0,m=f(t)?{native_token:{denom:l.getNativeDenom(this.network,this.chain)}}:{token:{contract_addr:r}};yield this.createUnsignedTx({msgs:[o(n,this.tokenBridge,{create_asset_meta:{asset_info:m,nonce:a}})],fee:w(this.network,this.chain),memo:"Wormhole - Create Attestation"},"TokenBridge.createAttestation")}async*submitAttestation(t,e){if(!e)throw new Error("Payer required to submit attestation");const r=new i(e).toString();yield this.createUnsignedTx({msgs:[o(r,this.tokenBridge,{submit_vaa:{data:y(t)}})],fee:w(this.network,this.chain),memo:"Wormhole - Submit Attestation"},"TokenBridge.submitAttestation")}async*transfer(t,e,r,n,a){const m=Math.round(Math.random()*1e5),B="0",S=b(e.chain),U=c.encode(e.address.toUniversalAddress().toUint8Array()),C=l.getNativeDenom(this.network,this.chain),u=f(r);let s=u?C:r.toString();s.startsWith("factory")&&(s=T.factoryToCw20(new i(s)).toString());const p=new i(t).toString(),_=g=>{const v={asset:{amount:n.toString(),info:g},recipient_chain:S,recipient:U,fee:B,nonce:m};return a?{initiate_transfer_with_payload:{...v,payload:c.encode(a)}}:{initiate_transfer:v}};if(u){const g=[o(p,this.tokenBridge,{deposit_tokens:{}},[{amount:n.toString(),denom:s}]),o(p,this.tokenBridge,_({native_token:{denom:s}}))];yield this.createUnsignedTx({msgs:g,fee:w(this.network,this.chain),memo:"Wormhole - Initiate Native Transfer"},"TokenBridge.transferNative")}else{const g=[o(p,s,{increase_allowance:{spender:this.tokenBridge,amount:n.toString(),expires:{never:{}}}}),o(p,this.tokenBridge,_({token:{contract_addr:s}}),[{amount:n.toString(),denom:s}])];yield this.createUnsignedTx({msgs:g,fee:w(this.network,this.chain),memo:"Wormhole - Initiate Transfer"},"TokenBridge.transfer")}}async*redeem(t,e,r=!0){const n=c.encode(y(e)),a=new i(t).toString(),m=this.translator&&new i(this.translator).toUniversalAddress().equals(e.payload.to.address)?o(a,this.translator,{complete_transfer_and_convert:{vaa:n}}):o(a,this.tokenBridge,{submit_vaa:{data:n}});yield this.createUnsignedTx({msgs:[m],fee:w(this.network,this.chain),memo:"Wormhole - Complete Transfer"},"TokenBridge.redeem")}async parseTransactionDetails(t){throw new Error("Not implemented")}async getWrappedNative(){return A(this.chain,l.getNativeDenom(this.network,this.chain))}createUnsignedTx(t,e,r=!1){return new N(t,this.network,this.chain,e,r)}}q(W,"TokenBridge",k);export{k as CosmwasmTokenBridge};
