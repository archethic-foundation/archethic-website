import{bC as Nr,c2 as Je,c3 as Vr,aG as Rr,aK as Lt,bz as Ae,aQ as Dr,aS as Kt,bW as Wr,c4 as Jt,bg as Fr,aF as Gr,m as Lr,bj as Kr}from"./index-Bibw8odz.js";import{i as tr,g as ft,a as Jr,b as rr,c as nr,d as nt,t as it,S as qr,e as $e,p as Hr,f as Zr,h as qe,j as Xr,u as He,k as Qr,l as Yr,m as qt,n as en,_ as tn}from"./sui-Br5LV7cS-KJfd6RRJ.js";import"./index-fXpyUPPA-CpB5LPa8.js";import{b as rn}from"./chain-DfK5JtF7-Jmo_aVnV.js";import"./create-D7FD56l0-D2uTFRvt.js";var nn=Object.defineProperty,sn=(e,t,r)=>t in e?nn(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,F=(e,t,r)=>(sn(e,typeof t!="symbol"?t+"":t,r),r);class an{constructor(t,r,n,i,s=!1){F(this,"transaction"),F(this,"network"),F(this,"chain"),F(this,"description"),F(this,"parallelizable"),this.transaction=t,this.network=r,this.chain=n,this.description=i,this.parallelizable=s}}class on extends TypeError{constructor(t,r){let n;const{message:i,explanation:s,...a}=t,{path:o}=t,c=o.length===0?i:`At path: ${o.join(".")} -- ${i}`;super(s??c),s!=null&&(this.cause=c),Object.assign(this,a),this.name=this.constructor.name,this.failures=()=>n??(n=[t,...r()])}}function cn(e){return G(e)&&typeof e[Symbol.iterator]=="function"}function G(e){return typeof e=="object"&&e!=null}function L(e){return typeof e=="symbol"?e.toString():typeof e=="string"?JSON.stringify(e):`${e}`}function un(e){const{done:t,value:r}=e.next();return t?void 0:r}function dn(e,t,r,n){if(e===!0)return;e===!1?e={}:typeof e=="string"&&(e={message:e});const{path:i,branch:s}=t,{type:a}=r,{refinement:o,message:c=`Expected a value of type \`${a}\`${o?` with refinement \`${o}\``:""}, but received: \`${L(n)}\``}=e;return{value:n,type:a,refinement:o,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*Ht(e,t,r,n){cn(e)||(e=[e]);for(const i of e){const s=dn(i,t,r,n);s&&(yield s)}}function*pt(e,t,r={}){const{path:n=[],branch:i=[e],coerce:s=!1,mask:a=!1}=r,o={path:n,branch:i};if(s&&(e=t.coercer(e,o),a&&t.type!=="type"&&G(t.schema)&&G(e)&&!Array.isArray(e)))for(const d in e)t.schema[d]===void 0&&delete e[d];let c="valid";for(const d of t.validator(e,o))d.explanation=r.message,c="not_valid",yield[d,void 0];for(let[d,l,m]of t.entries(e,o)){const w=pt(l,m,{path:d===void 0?n:[...n,d],branch:d===void 0?i:[...i,l],coerce:s,mask:a,message:r.message});for(const g of w)g[0]?(c=g[0].refinement!=null?"not_refined":"not_valid",yield[g[0],void 0]):s&&(l=g[1],d===void 0?e=l:e instanceof Map?e.set(d,l):e instanceof Set?e.add(l):G(e)&&(l!==void 0||d in e)&&(e[d]=l))}if(c!=="not_valid")for(const d of t.refiner(e,o))d.explanation=r.message,c="not_refined",yield[d,void 0];c==="valid"&&(yield[void 0,e])}class Y{constructor(t){const{type:r,schema:n,validator:i,refiner:s,coercer:a=c=>c,entries:o=function*(){}}=t;this.type=r,this.schema=n,this.entries=o,this.coercer=a,i?this.validator=(c,d)=>{const l=i(c,d);return Ht(l,d,this,c)}:this.validator=()=>[],s?this.refiner=(c,d)=>{const l=s(c,d);return Ht(l,d,this,c)}:this.refiner=()=>[]}assert(t,r){return st(t,this,r)}create(t,r){return ir(t,this,r)}is(t){return D(t,this)}mask(t,r){return sr(t,this,r)}validate(t,r={}){return Ee(t,this,r)}}function st(e,t,r){const n=Ee(e,t,{message:r});if(n[0])throw n[0]}function ir(e,t,r){const n=Ee(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function sr(e,t,r){const n=Ee(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}function D(e,t){return!Ee(e,t)[0]}function Ee(e,t,r={}){const n=pt(e,t,r),i=un(n);return i[0]?[new on(i[0],function*(){for(const s of n)s[0]&&(yield s[0])}),void 0]:[void 0,i[1]]}function je(...e){const t=e[0].type==="type",r=e.map(i=>i.schema),n=Object.assign({},...r);return t?fn(n):h(n)}function W(e,t){return new Y({type:e,schema:null,validator:t})}function at(){return W("any",()=>!0)}function S(e){return new Y({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${L(t)}`}})}function ln(){return W("bigint",e=>typeof e=="bigint")}function M(){return W("boolean",e=>typeof e=="boolean")}function Q(){return W("integer",e=>typeof e=="number"&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${L(e)}`)}function j(e){const t=L(e),r=typeof e;return new Y({type:"literal",schema:r==="string"||r==="number"||r==="boolean"?e:null,validator(n){return n===e||`Expected the literal \`${t}\`, but received: ${L(n)}`}})}function ar(){return W("never",()=>!1)}function B(e){return new Y({...e,validator:(t,r)=>t===null||e.validator(t,r),refiner:(t,r)=>t===null||e.refiner(t,r)})}function de(){return W("number",e=>typeof e=="number"&&!isNaN(e)||`Expected a number, but received: ${L(e)}`)}function h(e){const t=e?Object.keys(e):[],r=ar();return new Y({type:"object",schema:e||null,*entries(n){if(e&&G(n)){const i=new Set(Object.keys(n));for(const s of t)i.delete(s),yield[s,n[s],e[s]];for(const s of i)yield[s,n[s],r]}},validator(n){return G(n)||`Expected an object, but received: ${L(n)}`},coercer(n){return G(n)?{...n}:n}})}function v(e){return new Y({...e,validator:(t,r)=>t===void 0||e.validator(t,r),refiner:(t,r)=>t===void 0||e.refiner(t,r)})}function X(e,t){return new Y({type:"record",schema:null,*entries(r){if(G(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator(r){return G(r)||`Expected an object, but received: ${L(r)}`}})}function f(){return W("string",e=>typeof e=="string"||`Expected a string, but received: ${L(e)}`)}function or(e){const t=ar();return new Y({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator(r){return Array.isArray(r)||`Expected an array, but received: ${L(r)}`}})}function fn(e){const t=Object.keys(e);return new Y({type:"type",schema:e,*entries(r){if(G(r))for(const n of t)yield[n,r[n],e[n]]},validator(r){return G(r)||`Expected an object, but received: ${L(r)}`},coercer(r){return G(r)?{...r}:r}})}function U(e){const t=e.map(r=>r.type).join(" | ");return new Y({type:"union",schema:null,coercer(r){for(const n of e){const[i,s]=n.validate(r,{coerce:!0});if(!i)return s}return r},validator(r,n){const i=[];for(const s of e){const[...a]=pt(r,s,n),[o]=a;if(o[0])for(const[c]of a)c&&i.push(c);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${L(r)}`,...i]}})}function cr(){return W("unknown",()=>!0)}const ht=U([h({AddressOwner:f()}),h({ObjectOwner:f()}),h({Shared:h({initial_shared_version:B(f())})}),j("Immutable")]);W("SuiJsonValue",()=>!0);const pn=U([h({u32:f()}),h({u64:f()}),h({f64:f()})]);h({attributes:X(f(),B(pn)),featureFlags:X(f(),M()),maxSupportedProtocolVersion:f(),minSupportedProtocolVersion:f(),protocolVersion:f()});U([f(),j("package")]);const se=h({digest:f(),objectId:f(),version:U([de(),f(),ln()])});h({owner:ht,reference:se});h({objectId:f(),sequenceNumber:f()});h({payment:S(se),owner:f(),price:f(),budget:f()});const hn=je(se,h({type:f(),owner:ht,previousTransaction:f()})),gn=X(f(),at()),mn=X(f(),cr()),yn=h({type:f(),fields:gn,hasPublicTransfer:M()}),wn=h({disassembled:mn}),bn=U([je(yn,h({dataType:j("moveObject")})),je(wn,h({dataType:j("package")}))]),vn=h({type:f(),hasPublicTransfer:M(),version:f(),bcsBytes:f()}),jn=h({id:f(),moduleMap:X(f(),f())}),Tn=U([je(vn,h({dataType:j("moveObject")})),je(jn,h({dataType:j("package")}))]);BigInt(1e9);const ur=h({code:f(),error:v(f()),object_id:v(f()),parent_object_id:v(f()),version:v(f()),digest:v(f())}),Sn=h({data:B(v(X(f(),f()))),error:B(v(ur))}),kn=U([Sn,v(X(f(),f()))]),dr=h({objectId:f(),version:f(),digest:f(),type:B(v(f())),content:B(v(bn)),bcs:B(v(Tn)),owner:B(v(ht)),previousTransaction:B(v(f())),storageRebate:B(v(f())),display:B(v(kn))});h({showType:B(v(M())),showContent:B(v(M())),showBcs:B(v(M())),showOwner:B(v(M())),showPreviousTransaction:B(v(M())),showStorageRebate:B(v(M())),showDisplay:B(v(M()))});U([j("Exists"),j("notExists"),j("Deleted")]);S(hn);const En=h({data:B(v(dr)),error:B(v(ur))});function xn(e){return e.data}function On(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){const t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}function Zt(e){if("reference"in e)return e.reference;const t=xn(e);return t?{objectId:t.objectId,version:t.version,digest:t.digest}:On(e)}h({objectId:f(),atCheckpoint:v(de())});h({data:S(En),nextCursor:v(B(f())),hasNextPage:M()});U([h({details:dr,status:j("VersionFound")}),h({details:f(),status:j("ObjectNotExists")}),h({details:se,status:j("ObjectDeleted")}),h({details:or([f(),de()]),status:j("VersionNotFound")}),h({details:h({asked_version:de(),latest_version:de(),object_id:f()}),status:j("VersionTooHigh")})]);const In=U([f(),h({Object:f()})]);S(In);const An=h({address:f(),name:f()}),$n=U([j("Private"),j("Public"),j("Friend")]),gt=h({abilities:S(f())}),Bn=h({constraints:gt,isPhantom:M()}),Un=h({TypeParameter:de()}),Ze=or([h({module:f(),package:f(),function:f()}),f()]);h({rank3Days:S(Ze),rank7Days:S(Ze),rank30Days:S(Ze)});function lr(e){if(!e)return!1;if(typeof e=="string"||D(e,Un)||fr(e))return!0;if(typeof e!="object")return!1;const t=e;return!!(D(t.Reference,pe)||D(t.MutableReference,pe)||D(t.Vector,pe))}const pe=W("SuiMoveNormalizedType",lr);function fr(e){if(!e||typeof e!="object")return!1;const t=e;if(!t.Struct||typeof t.Struct!="object")return!1;const r=t.Struct;return!(typeof r.address!="string"||typeof r.module!="string"||typeof r.name!="string"||!Array.isArray(r.typeArguments)||!r.typeArguments.every(n=>lr(n)))}W("SuiMoveNormalizedStructType",fr);const Cn=h({visibility:$n,isEntry:M(),typeParameters:S(gt),parameters:S(pe),return:S(pe)}),zn=h({name:f(),type:pe}),Pn=h({abilities:gt,typeParameters:S(Bn),fields:S(zn)}),_n=h({fileFormatVersion:de(),address:f(),name:f(),friends:S(An),structs:X(f(),Pn),exposedFunctions:X(f(),Cn)});X(f(),_n);function ot(e){return typeof e=="object"&&"MutableReference"in e?e.MutableReference:void 0}function pr(e){return typeof e=="object"&&"Reference"in e?e.Reference:void 0}function mt(e){if(typeof e=="object"&&"Struct"in e)return e;const t=pr(e),r=ot(e);if(typeof t=="object"&&"Struct"in t)return t;if(typeof r=="object"&&"Struct"in r)return r}function Mn(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(t[s]!==255)throw new TypeError(i+" is ambiguous");t[s]=n}var a=e.length,o=e.charAt(0),c=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function l(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var y=0,p=0,b=0,A=g.length;b!==A&&g[b]===0;)b++,y++;for(var P=(A-b)*d+1>>>0,I=new Uint8Array(P);b!==A;){for(var $=g[b],x=0,N=P-1;($!==0||x<p)&&N!==-1;N--,x++)$+=256*I[N]>>>0,I[N]=$%a>>>0,$=$/a>>>0;if($!==0)throw new Error("Non-zero carry");p=x,b++}for(var K=P-p;K!==P&&I[K]===0;)K++;for(var ce=o.repeat(y);K<P;++K)ce+=e.charAt(I[K]);return ce}function m(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;for(var y=0,p=0,b=0;g[y]===o;)p++,y++;for(var A=(g.length-y)*c+1>>>0,P=new Uint8Array(A);g[y];){var I=t[g.charCodeAt(y)];if(I===255)return;for(var $=0,x=A-1;(I!==0||$<b)&&x!==-1;x--,$++)I+=a*P[x]>>>0,P[x]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");b=$,y++}for(var N=A-b;N!==A&&P[N]===0;)N++;for(var K=new Uint8Array(p+(A-N)),ce=p;N!==A;)K[ce++]=P[N++];return K}function w(g){var y=m(g);if(y)return y;throw new Error("Non-base"+a+" character")}return{encode:l,decodeUnsafe:m,decode:w}}var Nn=Mn;const Vn=Nn,Rn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var Dn=Vn(Rn);const hr=Lr(Dn),xe=e=>hr.encode(e),yt=e=>hr.decode(e);function ae(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))}const Xe=8192;function Oe(e){if(e.length<Xe)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=Xe){const n=e.slice(r,r+Xe);t+=String.fromCharCode(...n)}return btoa(t)}function Ke(e){var t;const r=e.startsWith("0x")?e.slice(2):e,n=((t=(r.length%2===0?r:`0${r}}`).match(/.{2}/g))==null?void 0:t.map(i=>parseInt(i,16)))??[];return Uint8Array.from(n)}function Ie(e){return e.reduce((t,r)=>t+r.toString(16).padStart(2,"0"),"")}function wt(e){let t=[],r=0;if(e===0)return[0];for(;e>0;)t[r]=e&127,(e>>=7)&&(t[r]|=128),r+=1;return t}function Wn(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(i&127)<<r,!(i&128))break;r+=7}return{value:t,length:n}}class gr{constructor(t){this.bytePosition=0,this.dataView=new DataView(t.buffer)}shift(t){return this.bytePosition+=t,this}read8(){let t=this.dataView.getUint8(this.bytePosition);return this.shift(1),t}read16(){let t=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),t}read32(){let t=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),t}read64(){let t=this.read32(),r=this.read32().toString(16)+t.toString(16).padStart(8,"0");return BigInt("0x"+r).toString(10)}read128(){let t=BigInt(this.read64()),r=BigInt(this.read64()).toString(16)+t.toString(16).padStart(16,"0");return BigInt("0x"+r).toString(10)}read256(){let t=BigInt(this.read128()),r=BigInt(this.read128()).toString(16)+t.toString(16).padStart(32,"0");return BigInt("0x"+r).toString(10)}readBytes(t){let r=this.bytePosition+this.dataView.byteOffset,n=new Uint8Array(this.dataView.buffer,r,t);return this.shift(t),n}readULEB(){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t),{value:n,length:i}=Wn(r);return this.shift(i),n}readVec(t){let r=this.readULEB(),n=[];for(let i=0;i<r;i++)n.push(t(this,i,r));return n}}function Fn(e,t){switch(t){case"base58":return xe(e);case"base64":return Oe(e);case"hex":return Ie(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function Gn(e,t){switch(t){case"base58":return yt(e);case"base64":return ae(e);case"hex":return Ke(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function mr(e,t=["<",">"]){const[r,n]=t,i=[];let s="",a=0;for(let o=0;o<e.length;o++){const c=e[o];if(c===r&&a++,c===n&&a--,a===0&&c===","){i.push(s.trim()),s="";continue}s+=c}return i.push(s.trim()),i}class yr{constructor({size:t=1024,maxSize:r,allocateSize:n=1024}={}){this.bytePosition=0,this.size=t,this.maxSize=r||t,this.allocateSize=n,this.dataView=new DataView(new ArrayBuffer(t))}ensureSizeOrGrow(t){const r=this.bytePosition+t;if(r>this.size){const n=Math.min(this.maxSize,this.size+this.allocateSize);if(r>n)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${r}`);this.size=n;const i=new ArrayBuffer(this.size);new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(i)}}shift(t){return this.bytePosition+=t,this}write8(t){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(t)),this.shift(1)}write16(t){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(t),!0),this.shift(2)}write32(t){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(t),!0),this.shift(4)}write64(t){return Qe(BigInt(t),8).forEach(r=>this.write8(r)),this}write128(t){return Qe(BigInt(t),16).forEach(r=>this.write8(r)),this}write256(t){return Qe(BigInt(t),32).forEach(r=>this.write8(r)),this}writeULEB(t){return wt(t).forEach(r=>this.write8(r)),this}writeVec(t,r){return this.writeULEB(t.length),Array.from(t).forEach((n,i)=>r(this,n,i,t.length)),this}*[Symbol.iterator](){for(let t=0;t<this.bytePosition;t++)yield this.dataView.getUint8(t);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(t){return Fn(this.toBytes(),t)}}function Qe(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e=e/BigInt(256),n+=1;return r}var wr=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},q=(e,t,r)=>(wr(e,t,"read from private field"),r?r.call(e):t.get(e)),Re=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},De=(e,t,r,n)=>(wr(e,t,"write to private field"),t.set(e,r),r),fe,ye,Pe,ie;const br=class{constructor(e){Re(this,fe,void 0),Re(this,ye,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),De(this,fe,e.write),De(this,ye,e.serialize??((t,r)=>{const n=new yr({size:this.serializedSize(t)??void 0,...r});return q(this,fe).call(this,t,n),n.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),q(this,fe).call(this,e,t)}serialize(e,t){return this.validate(e),new Ln(this,q(this,ye).call(this,e,t))}parse(e){const t=new gr(e);return this.read(t)}transform({name:e,input:t,output:r}){return new br({name:e??this.name,read:n=>r(this.read(n)),write:(n,i)=>q(this,fe).call(this,t(n),i),serializedSize:n=>this.serializedSize(t(n)),serialize:(n,i)=>q(this,ye).call(this,t(n),i),validate:n=>this.validate(t(n))})}};let H=br;fe=new WeakMap;ye=new WeakMap;const vr=Symbol.for("@mysten/serialized-bcs");function bt(e){return!!e&&typeof e=="object"&&e[vr]===!0}class Ln{constructor(t,r){Re(this,Pe,void 0),Re(this,ie,void 0),De(this,Pe,t),De(this,ie,r)}get[vr](){return!0}toBytes(){return q(this,ie)}toHex(){return Ie(q(this,ie))}toBase64(){return Oe(q(this,ie))}toBase58(){return xe(q(this,ie))}parse(){return q(this,Pe).parse(q(this,ie))}}Pe=new WeakMap;ie=new WeakMap;function We({size:e,...t}){return new H({...t,serializedSize:()=>e})}function Ye({readMethod:e,writeMethod:t,...r}){return We({...r,read:n=>n[e](),write:(n,i)=>i[t](n),validate:n=>{var i;if(n<0||n>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${n}. Expected value in range 0-${r.maxValue}`);(i=r.validate)==null||i.call(r,n)}})}function et({readMethod:e,writeMethod:t,...r}){return We({...r,read:n=>n[e](),write:(n,i)=>i[t](BigInt(n)),validate:n=>{var i;const s=BigInt(n);if(s<0||s>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${s}. Expected value in range 0-${r.maxValue}`);(i=r.validate)==null||i.call(r,s)}})}function Kn({serialize:e,...t}){const r=new H({...t,serialize:e,write:(n,i)=>{for(const s of r.serialize(n).toBytes())i.write8(s)}});return r}function Jn({toBytes:e,fromBytes:t,...r}){return new H({...r,read:n=>{const i=n.readULEB(),s=n.readBytes(i);return t(s)},write:(n,i)=>{const s=e(n);i.writeULEB(s.length);for(let a=0;a<s.length;a++)i.write8(s[a])},serialize:n=>{const i=e(n),s=wt(i.length),a=new Uint8Array(s.length+i.length);return a.set(s,0),a.set(i,s.length),a},validate:n=>{var i;if(typeof n!="string")throw new TypeError(`Invalid ${r.name} value: ${n}. Expected string`);(i=r.validate)==null||i.call(r,n)}})}function qn(e){let t=null;function r(){return t||(t=e()),t}return new H({name:"lazy",read:n=>r().read(n),serializedSize:n=>r().serializedSize(n),write:(n,i)=>r().write(n,i),serialize:(n,i)=>r().serialize(n,i).toBytes()})}const u={u8(e){return Ye({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...e})},u16(e){return Ye({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...e})},u32(e){return Ye({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e})},u64(e){return et({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e})},u128(e){return et({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e})},u256(e){return et({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e})},bool(e){return We({name:"bool",size:1,read:t=>t.read8()===1,write:(t,r)=>r.write8(t?1:0),...e,validate:t=>{var r;if((r=e==null?void 0:e.validate)==null||r.call(e,t),typeof t!="boolean")throw new TypeError(`Expected boolean, found ${typeof t}`)}})},uleb128(e){return Kn({name:"uleb128",read:t=>t.readULEB(),serialize:t=>Uint8Array.from(wt(t)),...e})},bytes(e,t){return We({name:`bytes[${e}]`,size:e,read:r=>r.readBytes(e),write:(r,n)=>{for(let i=0;i<e;i++)n.write8(r[i]??0)},...t,validate:r=>{var n;if((n=t==null?void 0:t.validate)==null||n.call(t,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}})},string(e){return Jn({name:"string",toBytes:t=>new TextEncoder().encode(t),fromBytes:t=>new TextDecoder().decode(t),...e})},fixedArray(e,t,r){return new H({name:`${t.name}[${e}]`,read:n=>{const i=new Array(e);for(let s=0;s<e;s++)i[s]=t.read(n);return i},write:(n,i)=>{for(const s of n)t.write(s,i)},...r,validate:n=>{var i;if((i=r==null?void 0:r.validate)==null||i.call(r,n),!("length"in n))throw new TypeError(`Expected array, found ${typeof n}`);if(n.length!==e)throw new TypeError(`Expected array of length ${e}, found ${n.length}`)}})},option(e){return u.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:t=>t==null?{None:!0}:{Some:t},output:t=>"Some"in t?t.Some:null})},vector(e,t){return new H({name:`vector<${e.name}>`,read:r=>{const n=r.readULEB(),i=new Array(n);for(let s=0;s<n;s++)i[s]=e.read(r);return i},write:(r,n)=>{n.writeULEB(r.length);for(const i of r)e.write(i,n)},...t,validate:r=>{var n;if((n=t==null?void 0:t.validate)==null||n.call(t,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`)}})},tuple(e,t){return new H({name:`(${e.map(r=>r.name).join(", ")})`,serializedSize:r=>{let n=0;for(let i=0;i<e.length;i++){const s=e[i].serializedSize(r[i]);if(s==null)return null;n+=s}return n},read:r=>{const n=[];for(const i of e)n.push(i.read(r));return n},write:(r,n)=>{for(let i=0;i<e.length;i++)e[i].write(r[i],n)},...t,validate:r=>{var n;if((n=t==null?void 0:t.validate)==null||n.call(t,r),!Array.isArray(r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}})},struct(e,t,r){const n=Object.entries(t);return new H({name:e,serializedSize:i=>{let s=0;for(const[a,o]of n){const c=o.serializedSize(i[a]);if(c==null)return null;s+=c}return s},read:i=>{const s={};for(const[a,o]of n)s[a]=o.read(i);return s},write:(i,s)=>{for(const[a,o]of n)o.write(i[a],s)},...r,validate:i=>{var s;if((s=r==null?void 0:r.validate)==null||s.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})},enum(e,t,r){const n=Object.entries(t);return new H({name:e,read:i=>{const s=i.readULEB(),[a,o]=n[s];return{[a]:(o==null?void 0:o.read(i))??!0}},write:(i,s)=>{const[a,o]=Object.entries(i)[0];for(let c=0;c<n.length;c++){const[d,l]=n[c];if(d===a){s.writeULEB(c),l==null||l.write(o,s);return}}},...r,validate:i=>{var s;if((s=r==null?void 0:r.validate)==null||s.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`);const a=Object.keys(i);if(a.length!==1)throw new TypeError(`Expected object with one key, found ${a.length}`);const[o]=a;if(!Object.hasOwn(t,o))throw new TypeError(`Invalid enum variant ${o}`)}})},map(e,t){return u.vector(u.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:r=>[...r.entries()],output:r=>{const n=new Map;for(const[i,s]of r)n.set(i,s);return n}})},generic(e,t){return(...r)=>t(...r).transform({name:`${t.name}<${r.map(n=>n.name).join(", ")}>`,input:n=>n,output:n=>n})},lazy(e){return qn(e)}},Hn=32,we=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof we){this.schema=e.schema,this.types=new Map(e.types);return}if(this.schema=e,this.registerAddressType(we.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);e.withPrimitives!==!1&&Zn(this)}tempKey(){return`bcs-struct-${++this.counter}`}ser(e,t,r){if(typeof e=="string"||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if(typeof e=="object"){const n=this.tempKey();return new we(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(e)}`)}de(e,t,r){if(typeof t=="string")if(r)t=Gn(t,r);else throw new Error("To pass a string to `bcs.de`, specify encoding");if(typeof e=="string"||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).decode(this,t,i)}if(typeof e=="object"){const n=new we(this),i=this.tempKey();return n.registerStructType(i,e).de(i,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,n=()=>!0){const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(a,o,c,d){const l=s.reduce((m,w,g)=>Object.assign(m,{[w]:d[g]}),{});return this._encodeRaw.call(a,new yr(c),o,d,l)},decode(a,o,c){const d=s.reduce((l,m,w)=>Object.assign(l,{[m]:c[w]}),{});return this._decodeRaw.call(a,new gr(o),c,d)},_encodeRaw(a,o,c,d){if(n(o))return t.call(this,a,o,c,d);throw new Error(`Validation failed for type ${i}, data: ${o}`)},_decodeRaw(a,o,c){return r.call(this,a,o,c)}}),this}registerBcsType(e,t){return this.registerType(e,(r,n,i)=>{const s=i.map(a=>new H({name:String(a),write:(o,c)=>{const{name:d,params:l}=this.parseTypeName(a),m=this.getTypeInterface(d),w=l.reduce((g,y,p)=>Object.assign(g,{[y]:i[p]}),{});return m._encodeRaw.call(this,c,o,l,w)},read:()=>{throw new Error("Not implemented")}}));return t(...s).write(n,r),r},(r,n)=>{const i=n.map(s=>new H({name:String(s),write:(a,o)=>{throw new Error("Not implemented")},read:a=>{const{name:o,params:c}=this.parseTypeName(s),d=this.getTypeInterface(o),l=c.reduce((m,w,g)=>Object.assign(m,{[w]:n[g]}),{});return d._decodeRaw.call(this,a,c,l)}}));return t(...i).read(r)}),this}registerAddressType(e,t,r="hex"){switch(r){case"base64":return this.registerType(e,function(n,i){return ae(i).reduce((s,a)=>s.write8(a),n)},function(n){return Oe(n.readBytes(t))});case"hex":return this.registerType(e,function(n,i){return Ke(i).reduce((s,a)=>s.write8(a),n)},function(n){return Ie(n.readBytes(t))});default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,function(n,i,s,a){return n.writeVec(i,(o,c)=>{let d=s[0];if(!d)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:l,params:m}=this.parseTypeName(d);if(this.hasType(l))return this.getTypeInterface(l)._encodeRaw.call(this,o,c,m,a);if(!(l in a))throw new Error(`Unable to find a matching type definition for ${l} in vector; make sure you passed a generic`);let{name:w,params:g}=this.parseTypeName(a[l]);return this.getTypeInterface(w)._encodeRaw.call(this,o,c,g,a)})},function(n,i,s){return n.readVec(a=>{let o=i[0];if(!o)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:c,params:d}=this.parseTypeName(o);if(this.hasType(c))return this.getTypeInterface(c)._decodeRaw.call(this,a,d,s);if(!(c in s))throw new Error(`Unable to find a matching type definition for ${c} in vector; make sure you passed a generic`);let{name:l,params:m}=this.parseTypeName(s[c]);return this.getTypeInterface(l)._decodeRaw.call(this,a,m,s)})})}registerStructType(e,t){for(let a in t){let o=this.tempKey(),c=t[a];!Array.isArray(c)&&typeof c!="string"&&(t[a]=o,this.registerStructType(o,c))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,function(a,o,c,d){if(!o||o.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${o}`);if(c.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${c.length}`);for(let l of n){if(!(l in o))throw new Error(`Struct ${i} requires field ${l}:${r[l]}`);const{name:m,params:w}=this.parseTypeName(r[l]);if(!s.includes(m))this.getTypeInterface(m)._encodeRaw.call(this,a,o[l],w,d);else{const g=s.indexOf(m);let{name:y,params:p}=this.parseTypeName(c[g]);if(this.hasType(y)){this.getTypeInterface(y)._encodeRaw.call(this,a,o[l],p,d);continue}if(!(y in d))throw new Error(`Unable to find a matching type definition for ${y} in ${i}; make sure you passed a generic`);let{name:b,params:A}=this.parseTypeName(d[y]);this.getTypeInterface(b)._encodeRaw.call(this,a,o[l],A,d)}}return a},function(a,o,c){if(o.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${o.length}`);let d={};for(let l of n){const{name:m,params:w}=this.parseTypeName(r[l]);if(!s.includes(m))d[l]=this.getTypeInterface(m)._decodeRaw.call(this,a,w,c);else{const g=s.indexOf(m);let{name:y,params:p}=this.parseTypeName(o[g]);if(this.hasType(y)){d[l]=this.getTypeInterface(y)._decodeRaw.call(this,a,p,c);continue}if(!(y in c))throw new Error(`Unable to find a matching type definition for ${y} in ${i}; make sure you passed a generic`);let{name:b,params:A}=this.parseTypeName(c[y]);d[l]=this.getTypeInterface(b)._decodeRaw.call(this,a,A,c)}}return d})}registerEnumType(e,t){for(let a in t){let o=this.tempKey(),c=t[a];c!==null&&!Array.isArray(c)&&typeof c!="string"&&(t[a]=o,this.registerStructType(o,c))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,function(a,o,c,d){if(!o)throw new Error(`Unable to write enum "${i}", missing data.
Received: "${o}"`);if(typeof o!="object")throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".
Received: "${JSON.stringify(o)}"`);let l=Object.keys(o)[0];if(l===void 0)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let m=n.indexOf(l);if(m===-1)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${l}"`);let w=n[m],g=r[w];if(a.write8(m),g===null)return a;let y=s.indexOf(g),p=y===-1?g:c[y];{let{name:b,params:A}=this.parseTypeName(p);return this.getTypeInterface(b)._encodeRaw.call(this,a,o[l],A,d)}},function(a,o,c){let d=a.readULEB(),l=n[d],m=r[l];if(d===-1)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${d}"`);if(m===null)return{[l]:!0};let w=s.indexOf(m),g=w===-1?m:o[w];{let{name:y,params:p}=this.parseTypeName(g);return{[l]:this.getTypeInterface(y)._decodeRaw.call(this,a,p,c)}}})}getTypeInterface(e){let t=this.types.get(e);if(typeof t=="string"){let r=[];for(;typeof t=="string";){if(r.includes(t))throw new Error(`Recursive definition found: ${r.join(" -> ")} -> ${t}`);r.push(t),t=this.types.get(t)}}if(t===void 0)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[o,...c]=e;return{name:o,params:c}}if(typeof e!="string")throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(n===-1&&i===-1)return{name:e,params:[]};if(n===-1||i===-1)throw new Error(`Unclosed generic in name '${e}'`);let s=e.slice(0,n),a=mr(e.slice(n+1,e.length-i-1),this.schema.genericSeparators);return{name:s,params:a}}};let O=we;O.U8="u8";O.U16="u16";O.U32="u32";O.U64="u64";O.U128="u128";O.U256="u256";O.BOOL="bool";O.VECTOR="vector";O.ADDRESS="address";O.STRING="string";O.HEX="hex-string";O.BASE58="base58-string";O.BASE64="base64-string";function Zn(e){e.registerType(O.U8,function(t,r){return t.write8(r)},function(t){return t.read8()},t=>t<256),e.registerType(O.U16,function(t,r){return t.write16(r)},function(t){return t.read16()},t=>t<65536),e.registerType(O.U32,function(t,r){return t.write32(r)},function(t){return t.read32()},t=>t<=4294967296n),e.registerType(O.U64,function(t,r){return t.write64(r)},function(t){return t.read64()}),e.registerType(O.U128,function(t,r){return t.write128(r)},function(t){return t.read128()}),e.registerType(O.U256,function(t,r){return t.write256(r)},function(t){return t.read256()}),e.registerType(O.BOOL,function(t,r){return t.write8(r)},function(t){return t.read8().toString(10)==="1"}),e.registerType(O.STRING,function(t,r){return t.writeVec(Array.from(r),(n,i)=>n.write8(i.charCodeAt(0)))},function(t){return t.readVec(r=>r.read8()).map(r=>String.fromCharCode(Number(r))).join("")},t=>!0),e.registerType(O.HEX,function(t,r){return t.writeVec(Array.from(Ke(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return Ie(new Uint8Array(r))}),e.registerType(O.BASE58,function(t,r){return t.writeVec(Array.from(yt(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return xe(new Uint8Array(r))}),e.registerType(O.BASE64,function(t,r){return t.writeVec(Array.from(ae(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return Oe(new Uint8Array(r))})}function Xn(){return{genericSeparators:["<",">"],vectorType:"vector",addressLength:Hn,addressEncoding:"hex"}}const vt=32;function Qn(e){return Yn(e)&&ei(e)===vt}function _(e,t=!1){let r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(vt*2,"0")}`}function he(e,t=!1){return _(e,t)}function Yn(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2===0}function ei(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}BigInt(1e9);const jt="0x1",jr="0x2",me=he("0x6"),_e=`${jr}::sui::SUI`;he("0x5");const ti="object",ri="ID",ni="ascii",ii="String",si="string",ai="String",oi="option",ci="Option",ui={address:jr,module:ti,name:ri},di={address:jt,module:ni,name:ii},li={address:jt,module:si,name:ai},fi={address:jt,module:oi,name:ci},Be=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function pi(e){var t;const r=(t=mt(e))==null?void 0:t.Struct;return(r==null?void 0:r.address)==="0x2"&&(r==null?void 0:r.module)==="tx_context"&&(r==null?void 0:r.name)==="TxContext"}function tt(e,t){if(!(typeof t>"u")&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const hi=["Address","Bool","U8","U16","U32","U64","U128","U256"];function ct(e,t){if(typeof e=="string"&&hi.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])tt("number",t);else if(e==="Bool")tt("boolean",t);else if(e==="Address"&&(tt("string",t),t&&!Qn(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}else if(typeof e=="string")throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((t===void 0||typeof t=="string")&&e.Vector==="U8")return"string";if(t!==void 0&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=ct(e.Vector,t?t[0]:void 0);return r===void 0?void 0:`vector<${r}>`}if("Struct"in e){if(Be(e.Struct,di))return"string";if(Be(e.Struct,li))return"utf8string";if(Be(e.Struct,ui))return"address";if(Be(e.Struct,fi)){const r={Vector:e.Struct.typeArguments[0]};return ct(r,t)}}}const gi=/^vector<(.+)>$/,mi=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class te{static parseFromStr(t,r=!1){if(t==="address")return{address:null};if(t==="bool")return{bool:null};if(t==="u8")return{u8:null};if(t==="u16")return{u16:null};if(t==="u32")return{u32:null};if(t==="u64")return{u64:null};if(t==="u128")return{u128:null};if(t==="u256")return{u256:null};if(t==="signer")return{signer:null};const n=t.match(gi);if(n)return{vector:te.parseFromStr(n[1],r)};const i=t.match(mi);if(i)return{struct:{address:r?_(i[1]):i[1],module:i[2],name:i[3],typeParams:i[5]===void 0?[]:te.parseStructTypeArgs(i[5],r)}};throw new Error(`Encountered unexpected token when parsing type args for ${t}`)}static parseStructTypeArgs(t,r=!1){return mr(t).map(n=>te.parseFromStr(n,r))}static tagToString(t){if("bool"in t)return"bool";if("u8"in t)return"u8";if("u16"in t)return"u16";if("u32"in t)return"u32";if("u64"in t)return"u64";if("u128"in t)return"u128";if("u256"in t)return"u256";if("address"in t)return"address";if("signer"in t)return"signer";if("vector"in t)return`vector<${te.tagToString(t.vector)}>`;if("struct"in t){const r=t.struct,n=r.typeParams.map(te.tagToString).join(", ");return`${r.address}::${r.module}::${r.name}${n?`<${n}>`:""}`}throw new Error("Invalid TypeTag")}}const E=new O({...Xn(),types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function Tr(e){return u.u64({name:"unsafe_u64",...e}).transform({input:t=>t,output:t=>Number(t)})}function yi(e){return u.enum("Option",{None:null,Some:e})}function Tt(e){return e.transform({input:t=>({[t.kind]:t}),output:t=>{const r=Object.keys(t)[0];return{kind:r,...t[r]}}})}const Z=u.bytes(vt).transform({input:e=>typeof e=="string"?Ke(_(e)):e,output:e=>_(Ie(e))}),St=u.vector(u.u8()).transform({name:"ObjectDigest",input:e=>yt(e),output:e=>xe(new Uint8Array(e))}),Te=u.struct("SuiObjectRef",{objectId:Z,version:u.u64(),digest:St}),kt=u.struct("SharedObjectRef",{objectId:Z,initialSharedVersion:u.u64(),mutable:u.bool()}),Fe=u.enum("ObjectArg",{ImmOrOwned:Te,Shared:kt,Receiving:Te}),Et=u.enum("CallArg",{Pure:u.vector(u.u8()),Object:Fe,ObjVec:u.vector(Fe)}),ge=u.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:u.lazy(()=>ge),struct:u.lazy(()=>Bt),u16:null,u32:null,u256:null}),J=Tt(u.enum("Argument",{GasCoin:null,Input:u.struct("Input",{index:u.u16()}),Result:u.struct("Result",{index:u.u16()}),NestedResult:u.struct("NestedResult",{index:u.u16(),resultIndex:u.u16()})})),xt=u.struct("ProgrammableMoveCall",{package:Z,module:u.string(),function:u.string(),type_arguments:u.vector(ge),arguments:u.vector(J)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map(s=>te.parseFromStr(s,!0));return{package:_(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(te.tagToString)})}),Ot=Tt(u.enum("Transaction",{MoveCall:xt,TransferObjects:u.struct("TransferObjects",{objects:u.vector(J),address:J}),SplitCoins:u.struct("SplitCoins",{coin:J,amounts:u.vector(J)}),MergeCoins:u.struct("MergeCoins",{destination:J,sources:u.vector(J)}),Publish:u.struct("Publish",{modules:u.vector(u.vector(u.u8())),dependencies:u.vector(Z)}),MakeMoveVec:u.struct("MakeMoveVec",{type:yi(ge),objects:u.vector(J)}),Upgrade:u.struct("Upgrade",{modules:u.vector(u.vector(u.u8())),dependencies:u.vector(Z),packageId:Z,ticket:J})})),It=u.struct("ProgrammableTransaction",{inputs:u.vector(Et),transactions:u.vector(Ot)}),At=u.enum("TransactionKind",{ProgrammableTransaction:It,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),$t=u.enum("TransactionExpiration",{None:null,Epoch:Tr()}),Bt=u.struct("StructTag",{address:Z,module:u.string(),name:u.string(),typeParams:u.vector(ge)}),Ut=u.struct("GasData",{payment:u.vector(Te),owner:Z,price:u.u64(),budget:u.u64()}),Ct=u.struct("TransactionDataV1",{kind:At,sender:Z,gasData:Ut,expiration:$t}),zt=u.enum("TransactionData",{V1:Ct}),wi=u.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),bi=u.enum("IntentVersion",{V0:null}),vi=u.enum("AppId",{Sui:null}),ji=u.struct("Intent",{scope:wi,version:bi,appId:vi}),Ti=u.generic(["T"],e=>u.struct("IntentMessage<T>",{intent:ji,value:e})),Pt=u.enum("CompressedSignature",{ED25519:u.fixedArray(64,u.u8()),Secp256k1:u.fixedArray(64,u.u8()),Secp256r1:u.fixedArray(64,u.u8()),ZkLogin:u.vector(u.u8())}),_t=u.enum("PublicKey",{ED25519:u.fixedArray(32,u.u8()),Secp256k1:u.fixedArray(33,u.u8()),Secp256r1:u.fixedArray(33,u.u8()),ZkLogin:u.vector(u.u8())}),Mt=u.struct("MultiSigPkMap",{pubKey:_t,weight:u.u8()}),Nt=u.struct("MultiSigPublicKey",{pk_map:u.vector(Mt),threshold:u.u16()}),Sr=u.struct("MultiSig",{sigs:u.vector(Pt),bitmap:u.u16(),multisig_pk:Nt}),Si=u.vector(u.u8()).transform({input:e=>typeof e=="string"?ae(e):e,output:e=>Oe(new Uint8Array(e))}),kr=u.struct("SenderSignedTransaction",{intentMessage:Ti(zt),txSignatures:u.vector(Si)}),Er=u.vector(kr,{name:"SenderSignedData"}),C={...u,U8:u.u8(),U16:u.u16(),U32:u.u32(),U64:u.u64(),U128:u.u128(),U256:u.u256(),ULEB128:u.uleb128(),Bool:u.bool(),String:u.string(),Address:Z,Argument:J,CallArg:Et,CompressedSignature:Pt,GasData:Ut,MultiSig:Sr,MultiSigPkMap:Mt,MultiSigPublicKey:Nt,ObjectArg:Fe,ObjectDigest:St,ProgrammableMoveCall:xt,ProgrammableTransaction:It,PublicKey:_t,SenderSignedData:Er,SenderSignedTransaction:kr,SharedObjectRef:kt,StructTag:Bt,SuiObjectRef:Te,Transaction:Ot,TransactionData:zt,TransactionDataV1:Ct,TransactionExpiration:$t,TransactionKind:At,TypeTag:ge,ser:E.ser.bind(E),de:E.de.bind(E),getTypeInterface:E.getTypeInterface.bind(E),hasType:E.hasType.bind(E),parseTypeName:E.parseTypeName.bind(E),registerAddressType:E.registerAddressType.bind(E),registerAlias:E.registerAlias.bind(E),registerBcsType:E.registerBcsType.bind(E),registerEnumType:E.registerEnumType.bind(E),registerStructType:E.registerStructType.bind(E),registerType:E.registerType.bind(E),types:E.types};E.registerBcsType("utf8string",()=>u.string({name:"utf8string"}));E.registerBcsType("unsafe_u64",()=>Tr());E.registerBcsType("enumKind",e=>Tt(e));[Z,J,Et,Pt,Ut,Sr,Mt,Nt,Fe,St,xt,It,_t,Er,kt,Bt,Te,Ot,zt,Ct,$t,At,ge].forEach(e=>{E.registerBcsType(e.name,()=>e)});const ki=U([h({ImmOrOwned:se}),h({Shared:h({objectId:f(),initialSharedVersion:U([Q(),f()]),mutable:M()})}),h({Receiving:se})]),Ge=h({Pure:S(Q())}),ut=h({Object:ki}),Le=U([Ge,ut]);function Ei(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:bt(e)?e.toBytes():C.ser(t,e,{maxSize:1/0}).toBytes())}}const R={Pure:Ei,ObjectRef({objectId:e,digest:t,version:r}){return{Object:{ImmOrOwned:{digest:t,version:r,objectId:_(e)}}}},SharedObjectRef({objectId:e,mutable:t,initialSharedVersion:r}){return{Object:{Shared:{mutable:t,initialSharedVersion:r,objectId:_(e)}}}},ReceivingRef({objectId:e,digest:t,version:r}){return{Object:{Receiving:{digest:t,version:r,objectId:_(e)}}}}};function Xt(e){return typeof e=="string"?_(e):"ImmOrOwned"in e.Object?_(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?_(e.Object.Receiving.objectId):_(e.Object.Shared.objectId)}function xi(e){return typeof e=="object"&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}function Oi(e){var t;return((t=xi(e))==null?void 0:t.mutable)??!1}function V(e,t){return ir(e,t)}const Ii=e=>U([h({None:U([j(!0),j(null)])}),h({Some:e})]),Se=U([h({kind:j("Input"),index:Q(),value:v(at()),type:v(j("object"))}),h({kind:j("Input"),index:Q(),value:v(at()),type:j("pure")})]),Ai=[Se,h({kind:j("GasCoin")}),h({kind:j("Result"),index:Q()}),h({kind:j("NestedResult"),index:Q(),resultIndex:Q()})],ne=U([...Ai]),xr=h({kind:j("MoveCall"),target:W("target",f().validator),typeArguments:S(f()),arguments:S(ne)}),Or=h({kind:j("TransferObjects"),objects:S(ne),address:ne}),Ir=h({kind:j("SplitCoins"),coin:ne,amounts:S(ne)}),Ar=h({kind:j("MergeCoins"),destination:ne,sources:S(ne)}),$r=h({kind:j("MakeMoveVec"),type:v(Ii(X(f(),cr()))),objects:S(ne)}),Br=h({kind:j("Publish"),modules:S(S(Q())),dependencies:S(f())}),Ur=h({kind:j("Upgrade"),modules:S(S(Q())),dependencies:S(f()),packageId:f(),ticket:ne}),$i=[xr,Or,Ir,Ar,Br,Ur,$r],Bi=U([...$i]),ue={MoveCall(e){return V({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},xr)},TransferObjects(e,t){return t.kind==="Input"&&t.type==="pure"&&typeof t.value!="object"&&(t.value=R.Pure(C.Address.serialize(t.value))),V({kind:"TransferObjects",objects:e,address:t},Or)},SplitCoins(e,t){return t.forEach(r=>{r.kind==="Input"&&r.type==="pure"&&typeof r.value!="object"&&(r.value=R.Pure(C.U64.serialize(r.value)))}),V({kind:"SplitCoins",coin:e,amounts:t},Ir)},MergeCoins(e,t){return V({kind:"MergeCoins",destination:e,sources:t},Ar)},Publish({modules:e,dependencies:t}){return V({kind:"Publish",modules:e.map(r=>typeof r=="string"?Array.from(ae(r)):r),dependencies:t.map(r=>he(r))},Br)},Upgrade({modules:e,dependencies:t,packageId:r,ticket:n}){return V({kind:"Upgrade",modules:e.map(i=>typeof i=="string"?Array.from(ae(i)):i),dependencies:t.map(i=>he(i)),packageId:r,ticket:n},Ur)},MakeMoveVec({type:e,objects:t}){return V({kind:"MakeMoveVec",type:e?{Some:te.parseFromStr(e)}:{None:null},objects:t},$r)}};function Ui(e){function t(r,n){return e(r,n)}return t.u8=r=>e(C.U8.serialize(r)),t.u16=r=>e(C.U16.serialize(r)),t.u32=r=>e(C.U32.serialize(r)),t.u64=r=>e(C.U64.serialize(r)),t.u128=r=>e(C.U128.serialize(r)),t.u256=r=>e(C.U256.serialize(r)),t.bool=r=>e(C.Bool.serialize(r)),t.string=r=>e(C.String.serialize(r)),t.address=r=>e(C.Address.serialize(r)),t.id=t.address,t}function Ci(e,t){const r=Array.from(`${e}::`).map(i=>i.charCodeAt(0)),n=new Uint8Array(r.length+t.length);return n.set(r),n.set(t,r.length),Kr(n,{dkLen:32})}const zi=v(B(U([h({Epoch:Q()}),h({None:U([j(!0),j(null)])})]))),Qt=W("StringEncodedBigint",e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}}),Pi=h({budget:v(Qt),price:v(Qt),payment:v(S(se)),owner:v(f())}),Ue=h({version:j(1),sender:v(f()),expiration:zi,gasConfig:Pi,inputs:S(Se),transactions:S(Bi)});function Yt(e){return _(e).replace("0x","")}class re{constructor(t){this.version=1,this.sender=t==null?void 0:t.sender,this.expiration=t==null?void 0:t.expiration,this.gasConfig=(t==null?void 0:t.gasConfig)??{},this.inputs=(t==null?void 0:t.inputs)??[],this.transactions=(t==null?void 0:t.transactions)??[]}static fromKindBytes(t){const r=C.TransactionKind.parse(t),n="ProgrammableTransaction"in r?r.ProgrammableTransaction:null;if(!n)throw new Error("Unable to deserialize from bytes.");const i=V({version:1,gasConfig:{},inputs:n.inputs.map((s,a)=>V({kind:"Input",value:s,index:a,type:D(s,Ge)?"pure":"object"},Se)),transactions:n.transactions},Ue);return re.restore(i)}static fromBytes(t){var r;const n=C.TransactionData.parse(t),i=n==null?void 0:n.V1,s="ProgrammableTransaction"in i.kind?(r=i==null?void 0:i.kind)==null?void 0:r.ProgrammableTransaction:null;if(!i||!s)throw new Error("Unable to deserialize from bytes.");const a=V({version:1,sender:i.sender,expiration:i.expiration,gasConfig:i.gasData,inputs:s.inputs.map((o,c)=>V({kind:"Input",value:o,index:c,type:D(o,Ge)?"pure":"object"},Se)),transactions:s.transactions},Ue);return re.restore(a)}static restore(t){st(t,Ue);const r=new re;return Object.assign(r,t),r}static getDigestFromBytes(t){const r=Ci("TransactionData",t);return xe(r)}build({maxSizeBytes:t=1/0,overrides:r,onlyTransactionKind:n}={}){const i=this.inputs.map(l=>(st(l.value,Le),l.value)),s={ProgrammableTransaction:{inputs:i,transactions:this.transactions}};if(n)return C.TransactionKind.serialize(s,{maxSize:t}).toBytes();const a=(r==null?void 0:r.expiration)??this.expiration,o=(r==null?void 0:r.sender)??this.sender,c={...this.gasConfig,...r==null?void 0:r.gasConfig};if(!o)throw new Error("Missing transaction sender");if(!c.budget)throw new Error("Missing gas budget");if(!c.payment)throw new Error("Missing gas payment");if(!c.price)throw new Error("Missing gas price");const d={sender:Yt(o),expiration:a||{None:!0},gasData:{payment:c.payment,owner:Yt(this.gasConfig.owner??o),price:BigInt(c.price),budget:BigInt(c.budget)},kind:{ProgrammableTransaction:{inputs:i,transactions:this.transactions}}};return C.TransactionData.serialize({V1:d},{maxSize:t}).toBytes()}getDigest(){const t=this.build({onlyTransactionKind:!1});return re.getDigestFromBytes(t)}snapshot(){return V(this,Ue)}}var Vt=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},k=(e,t,r)=>(Vt(e,t,"read from private field"),r?r.call(e):t.get(e)),ee=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Ce=(e,t,r,n)=>(Vt(e,t,"write to private field"),t.set(e,r),r),z=(e,t,r)=>(Vt(e,t,"access private method"),r),T,be,Me,ve,Ne,oe,le,Rt,Cr,Dt,zr,Wt,Pr,Ft,_r,Ve,dt;const _i={maxPureArgumentSize:16*1024,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:128*1024};function Mi(e){const t={kind:"Result",index:e},r=[],n=i=>r[i]??(r[i]={kind:"NestedResult",index:e,resultIndex:i});return new Proxy(t,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,s){if(s in i)return Reflect.get(i,s);if(s===Symbol.iterator)return function*(){let o=0;for(;;)yield n(o),o++};if(typeof s=="symbol")return;const a=parseInt(s,10);if(!(Number.isNaN(a)||a<0))return n(a)}})}function Ni(e){const t=mt(e);return t?t.Struct.address==="0x2"&&t.Struct.module==="transfer"&&t.Struct.name==="Receiving":!1}function ke(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const Vi=Symbol.for("@mysten/transaction"),rt={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},Ri=1000n,Di=50,Wi=(e,t)=>Array.from({length:Math.ceil(e.length/t)},(r,n)=>e.slice(n*t,n*t+t)),lt=class{constructor(e){ee(this,be),ee(this,ve),ee(this,oe),ee(this,Rt),ee(this,Dt),ee(this,Wt),ee(this,Ft),ee(this,Ve),ee(this,T,void 0),Ce(this,T,new re(e?e.blockData:void 0))}static fromKind(e){const t=new lt;return Ce(t,T,re.fromKindBytes(typeof e=="string"?ae(e):e)),t}static from(e){const t=new lt;return typeof e!="string"||!e.startsWith("{")?Ce(t,T,re.fromBytes(typeof e=="string"?ae(e):e)):Ce(t,T,re.restore(JSON.parse(e))),t}setSender(e){k(this,T).sender=e}setSenderIfNotSet(e){k(this,T).sender||(k(this,T).sender=e)}setExpiration(e){k(this,T).expiration=e}setGasPrice(e){k(this,T).gasConfig.price=String(e)}setGasBudget(e){k(this,T).gasConfig.budget=String(e)}setGasOwner(e){k(this,T).gasConfig.owner=e}setGasPayment(e){k(this,T).gasConfig.payment=e.map(t=>sr(t,se))}get blockData(){return k(this,T).snapshot()}get[Vi](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Ui((e,t)=>bt(e)?z(this,be,Me).call(this,"pure",{Pure:Array.from(e.toBytes())}):z(this,be,Me).call(this,"pure",e instanceof Uint8Array?R.Pure(e):t?R.Pure(e,t):e))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if(typeof e=="object"&&"kind"in e)return e;const t=Xt(e),r=k(this,T).inputs.find(n=>n.type==="object"&&t===Xt(n.value));return r&&D(r.value,ut)&&"Shared"in r.value.Object&&D(e,ut)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??z(this,be,Me).call(this,"object",typeof e=="string"?_(e):e)}objectRef(...e){return this.object(R.ObjectRef(...e))}receivingRef(...e){return this.object(R.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(R.SharedObjectRef(...e))}add(e){const t=k(this,T).transactions.push(e);return Mi(t-1)}splitCoins(e,t){return this.add(ue.SplitCoins(typeof e=="string"?this.object(e):e,t.map(r=>typeof r=="number"||typeof r=="bigint"||typeof r=="string"?this.pure.u64(r):z(this,ve,Ne).call(this,r))))}mergeCoins(e,t){return this.add(ue.MergeCoins(typeof e=="string"?this.object(e):e,t.map(r=>typeof r=="string"?this.object(r):r)))}publish({modules:e,dependencies:t}){return this.add(ue.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,packageId:r,ticket:n}){return this.add(ue.Upgrade({modules:e,dependencies:t,packageId:r,ticket:typeof n=="string"?this.object(n):n}))}moveCall({arguments:e,typeArguments:t,target:r}){return this.add(ue.MoveCall({arguments:e==null?void 0:e.map(n=>z(this,ve,Ne).call(this,n)),typeArguments:t,target:r}))}transferObjects(e,t){return this.add(ue.TransferObjects(e.map(r=>typeof r=="string"?this.object(r):r),typeof t=="string"?this.pure.address(t):z(this,ve,Ne).call(this,t)))}makeMoveVec({type:e,objects:t}){return this.add(ue.MakeMoveVec({type:e,objects:t.map(r=>typeof r=="string"?this.object(r):r)}))}serialize(){return JSON.stringify(k(this,T).snapshot())}async sign(e){const{signer:t,...r}=e,n=await this.build(r);return t.signTransactionBlock(n)}async build(e={}){return await z(this,Ve,dt).call(this,e),k(this,T).build({maxSizeBytes:z(this,oe,le).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await z(this,Ve,dt).call(this,e),k(this,T).getDigest()}};let ze=lt;T=new WeakMap;be=new WeakSet;Me=function(e,t){const r=k(this,T).inputs.length,n=V({kind:"Input",value:typeof t=="bigint"?String(t):t,index:r,type:e},Se);return k(this,T).inputs.push(n),n};ve=new WeakSet;Ne=function(e){return bt(e)?this.pure(e):e};oe=new WeakSet;le=function(e,{protocolConfig:t,limits:r}){if(r&&typeof r[e]=="number")return r[e];if(!t)return _i[e];const n=t==null?void 0:t.attributes[rt[e]];if(!n)throw new Error(`Missing expected protocol config: "${rt[e]}"`);const i="u64"in n?n.u64:"u32"in n?n.u32:n.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${rt[e]}"`);return Number(i)};Rt=new WeakSet;Cr=function(e){const t=z(this,oe,le).call(this,"maxPureArgumentSize",e);k(this,T).inputs.forEach((r,n)=>{if(D(r.value,Ge)&&r.value.Pure.length>t)throw new Error(`Input at index ${n} is too large, max pure input size is ${t} bytes, got ${r.value.Pure.length} bytes`)})};Dt=new WeakSet;zr=async function(e){if(k(this,T).gasConfig.payment){const n=z(this,oe,le).call(this,"maxGasObjects",e);if(k(this,T).gasConfig.payment.length>n)throw new Error(`Payment objects exceed maximum amount: ${n}`)}if(e.onlyTransactionKind||k(this,T).gasConfig.payment)return;const t=k(this,T).gasConfig.owner??k(this,T).sender,r=(await ke(e).getCoins({owner:t,coinType:_e})).data.filter(n=>!k(this,T).inputs.find(i=>D(i.value,Le)&&"Object"in i.value&&"ImmOrOwned"in i.value.Object?n.coinObjectId===i.value.Object.ImmOrOwned.objectId:!1)).slice(0,z(this,oe,le).call(this,"maxGasObjects",e)-1).map(n=>({objectId:n.coinObjectId,digest:n.digest,version:n.version}));if(!r.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(r)};Wt=new WeakSet;Pr=async function(e){e.onlyTransactionKind||k(this,T).gasConfig.price||this.setGasPrice(await ke(e).getReferenceGasPrice())};Ft=new WeakSet;_r=async function(e){const{inputs:t,transactions:r}=k(this,T),n=[],i=[];if(t.forEach(s=>{if(s.type==="object"&&typeof s.value=="string"){i.push({id:_(s.value),input:s});return}}),r.forEach(s=>{if(s.kind==="MoveCall"&&s.arguments.some(a=>a.kind==="Input"&&!D(t[a.index].value,Le))&&n.push(s),s.kind==="SplitCoins"&&s.amounts.forEach(a=>{if(a.kind==="Input"){const o=t[a.index];typeof o.value!="object"&&(o.value=R.Pure(C.U64.serialize(o.value)))}}),s.kind==="TransferObjects"&&s.address.kind==="Input"){const a=t[s.address.index];typeof a.value!="object"&&(a.value=R.Pure(C.Address.serialize(a.value)))}}),n.length&&await Promise.all(n.map(async s=>{const[a,o,c]=s.target.split("::"),d=await ke(e).getNormalizedMoveFunction({package:he(a),module:o,function:c}),l=d.parameters.length>0&&pi(d.parameters.at(-1))?d.parameters.slice(0,d.parameters.length-1):d.parameters;if(l.length!==s.arguments.length)throw new Error("Incorrect number of arguments.");l.forEach((m,w)=>{const g=s.arguments[w];if(g.kind!=="Input")return;const y=t[g.index];if(D(y.value,Le))return;const p=y.value,b=ct(m,p);if(b){y.value=R.Pure(p,b);return}if(mt(m)!=null||typeof m=="object"&&"TypeParameter"in m){if(typeof p!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(p,null,2)}`);i.push({id:p,input:y,normalizedType:m});return}throw new Error(`Unknown call arg type ${JSON.stringify(m,null,2)} for value ${JSON.stringify(p,null,2)}`)})})),i.length){const s=[...new Set(i.map(({id:l})=>l))],a=Wi(s,Di),o=(await Promise.all(a.map(l=>ke(e).multiGetObjects({ids:l,options:{showOwner:!0}})))).flat();let c=new Map(s.map((l,m)=>[l,o[m]]));const d=Array.from(c).filter(([l,m])=>m.error).map(([l,m])=>l);if(d.length)throw new Error(`The following input objects are invalid: ${d.join(", ")}`);i.forEach(({id:l,input:m,normalizedType:w})=>{var g;const y=c.get(l),p=(g=y.data)==null?void 0:g.owner,b=p&&typeof p=="object"&&"Shared"in p?p.Shared.initial_shared_version:void 0;if(b){const A=w!=null&&ot(w)==null&&pr(w)==null,P=Oi(m.value)||A||w!=null&&ot(w)!=null;m.value=R.SharedObjectRef({objectId:l,initialSharedVersion:b,mutable:P})}else w&&Ni(w)?m.value=R.ReceivingRef(Zt(y)):m.value=R.ObjectRef(Zt(y))})}};Ve=new WeakSet;dt=async function(e){if(!e.onlyTransactionKind&&!k(this,T).sender)throw new Error("Missing transaction sender");if(!e.protocolConfig&&!e.limits&&e.client&&(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([z(this,Wt,Pr).call(this,e),z(this,Ft,_r).call(this,e)]),!e.onlyTransactionKind&&(await z(this,Dt,zr).call(this,e),!k(this,T).gasConfig.budget)){const t=await ke(e).dryRunTransactionBlock({transactionBlock:k(this,T).build({maxSizeBytes:z(this,oe,le).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(z(this,oe,le).call(this,"maxTxGas",e)),payment:[]}}})});if(t.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=Ri*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(t.effects.gasUsed.computationCost)+r,i=n+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}z(this,Rt,Cr).call(this,e)};const Fi=async(e,t,r)=>{var n,i,s;if(!tr(r))throw new Error(`Invalid Sui type: ${r}`);const a=await ft(e,t);if(!a)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);const o=(i=(n=a.token_registry.fields)==null?void 0:n.id)==null?void 0:i.id;if(!o)throw new Error("Unable to fetch token registry object ID");const c=Jr((s=a.token_registry)==null?void 0:s.type);if(!c)throw new Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:o,name:{type:`${c}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},er=async(e,t,r,n)=>{var i,s,a,o;const c=await ft(e,t);if(!c)throw new Error("Unable to fetch object fields from token bridge state");const d=(s=(i=c.token_registry)==null?void 0:i.fields)==null?void 0:s.coin_types,l=(o=(a=d==null?void 0:d.fields)==null?void 0:a.id)==null?void 0:o.id;if(!l)throw new Error("Unable to fetch coin types");const m=rr(d==null?void 0:d.type);if(!m)throw new Error("Unable to get key type");const w=await e.getDynamicFieldObject({parentId:l,name:{type:m,value:{addr:[...r],chain:n}}});if(w.error){if(w.error.code==="dynamicFieldNotFound")return null;throw new Error(`Unexpected getDynamicFieldObject response ${w.error}`)}const g=nr(w);if(!g)return null;if(!nt(g))throw new Error("What?");return"value"in g?it(g.value):null};class Gt{constructor(t,r,n,i){F(this,"network"),F(this,"chain"),F(this,"provider"),F(this,"contracts"),F(this,"coreBridgeObjectId"),F(this,"tokenBridgeObjectId"),F(this,"chainId"),this.network=t,this.chain=r,this.provider=n,this.contracts=i,this.chainId=Nr.get(t,r);const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);const a=this.contracts.coreBridge;if(!a)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);this.tokenBridgeObjectId=s,this.coreBridgeObjectId=a}static async fromRpc(t,r){const[n,i]=await qr.chainFromRpc(t),s=r[i];if(s.network!==n)throw new Error(`Network mismatch: ${s.network} != ${n}`);return new Gt(n,i,t,s.contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{return!1}}async getOriginalAsset(t){let r=t.getCoinType();if(!tr(r))throw new Error(`Invalid Sui type: ${r}`);const n=await Fi(this.provider,this.tokenBridgeObjectId,r),i=nr(n);if(!i)throw Je(r);if(!nt(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const s=i.value;if(!$e(s))throw new Error("Expected fields to be a MoveStruct");const a=it(s.type);if(r=it(r),a.includes(`wrapped_asset::WrappedAsset<${r}>`)){const o=s.fields.info;if(!$e(o))throw new Error("Expected fields to be a MoveStruct");const c=o.fields.token_address;if(!$e(c))throw new Error("Expected fields to be a MoveStruct");if(!nt(c.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in c.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const d=c.fields.value;if(!$e(d))throw new Error("Expected fields to be a MoveStruct");return{chain:Vr(Number(o.fields.token_chain)),address:new Rr(d.fields.data)}}throw Je(r)}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(Lt(t.address))throw new Error("Token Address required, 'native' literal not supported");const r=await er(this.provider,this.tokenBridgeObjectId,t.address.toUniversalAddress().toUint8Array(),Ae(t.chain));if(!r)throw Je(Dr(t));return Kt(this.chain,r)}async isTransferCompleted(t){var r,n,i,s,a,o,c,d;const l=await ft(this.provider,this.tokenBridgeObjectId);if(!l)throw new Error("Unable to fetch object fields from token bridge state");const m=(n=(r=l.consumed_vaas)==null?void 0:r.fields)==null?void 0:n.hashes,w=rr((s=(i=m==null?void 0:m.fields)==null?void 0:i.items)==null?void 0:s.type);if(!w)throw new Error("Unable to get key type");const g=(d=(c=(o=(a=m==null?void 0:m.fields)==null?void 0:a.items)==null?void 0:o.fields)==null?void 0:c.id)==null?void 0:d.id;if(!g)throw new Error("Unable to fetch consumed VAAs table");const y=await this.provider.getDynamicFieldObject({parentId:g,name:{type:w,value:{data:[...Wr(t.hash)]}}});if(!y.error)return!0;if(y.error.code==="dynamicFieldNotFound")return!1;throw new Error(`Unexpected getDynamicFieldObject response ${y.error}`)}async*createAttestation(t){const r=0n,n=0n,i=t.toString(),s=await this.provider.getCoinMetadata({coinType:i});if(s===null||s.id===null)throw new Error(`Coin metadata ID for type ${i} not found`);const[a,o]=await this.getPackageIds(),c=new ze,[d]=c.splitCoins(c.gas,[c.pure(r)]),[l]=c.moveCall({target:`${o}::attest_token::attest_token`,arguments:[c.object(this.tokenBridgeObjectId),c.object(s.id),c.pure(n)],typeArguments:[i]});c.moveCall({target:`${a}::publish_message::publish_message`,arguments:[c.object(this.coreBridgeObjectId),d,l,c.object(me)]}),yield this.createUnsignedTx(c,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(t,r){const[n,i]=await this.getPackageIds(),s=r.toString(),a=Math.min(t.payload.decimals,8),o=await this.getCoinBuildOutput(n,i,a),c=await Hr(o,s);yield this.createUnsignedTx(c,"Sui.TokenBridge.PrepareCreateWrapped");let d="",l="",m="",w="",g="",y=!1;for(;!y;){await new Promise($=>setTimeout($,500));const I=await this.provider.queryTransactionBlocks({filter:{FromAddress:s},options:{showObjectChanges:!0},limit:3});for(const $ of I.data)if("objectChanges"in $){for(const x of $.objectChanges)Zr(x)&&x.packageId!==void 0?d=x.packageId:qe(x)&&x.objectType.includes("WrappedAssetSetup")?(l=x.objectId,g=x.objectType.split(", ")[1].replace(">","")):qe(x)&&x.objectType.includes("UpgradeCap")?m=x.objectId:qe(x)&&x.objectType.includes("CoinMetadata")&&(w=x.objectId);if(d!==""&&l!==""&&m!==""&&w!==""){y=!0;break}else d="",l="",m="",w=""}}const p=Xr(d),b=new ze,[A]=b.moveCall({target:`${n}::vaa::parse_and_verify`,arguments:[b.object(this.coreBridgeObjectId),b.pure(He(Jt(t))),b.object(me)]}),[P]=b.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[b.object(this.tokenBridgeObjectId),A]});b.moveCall({target:`${i}::create_wrapped::complete_registration`,arguments:[b.object(this.tokenBridgeObjectId),b.object(w),b.object(l),b.object(m),P],typeArguments:[p,g]}),yield this.createUnsignedTx(b,"Sui.TokenBridge.SubmitAttestation")}async*transfer(t,r,n,i,s){const a=0n,o=0n,c=t.toString(),d=(Lt(n)?_e:n).toString(),l=(await this.provider.getCoins({owner:c,coinType:d})).data,[m,...w]=l.filter(I=>Qr(I.coinType,d));if(m===void 0)throw new Error(`Coins array doesn't contain any coins of type ${d}`);const[g,y]=await this.getPackageIds(),p=new ze,[b]=(()=>{if(d===_e)return p.splitCoins(p.gas,[p.pure(i)]);{const I=p.object(m.coinObjectId);return w.length&&p.mergeCoins(I,w.map($=>p.object($.coinObjectId))),p.splitCoins(I,[p.pure(i)])}})(),[A]=p.splitCoins(p.gas,[p.pure(a)]),[P]=p.moveCall({target:`${y}::state::verified_asset`,arguments:[p.object(this.tokenBridgeObjectId)],typeArguments:[d]});if(s){if(!c)throw new Error("senderAddress is required for transfer with payload");let I=!1;const $=await(async()=>{const ce=await Yr(this.provider,g,c);if(ce!==null)return p.object(ce);{const[Mr]=p.moveCall({target:`${g}::emitter::new`,arguments:[p.object(this.coreBridgeObjectId)]});return I=!0,Mr}})(),[x,N]=p.moveCall({target:`${y}::transfer_tokens_with_payload::prepare_transfer`,arguments:[$,P,b,p.pure(Ae(r.chain)),p.pure(r.address.toUint8Array()),p.pure([...s]),p.pure(0)],typeArguments:[d]});p.moveCall({target:`${y}::coin_utils::return_nonzero`,arguments:[N],typeArguments:[d]});const[K]=p.moveCall({target:`${y}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[p.object(this.tokenBridgeObjectId),x],typeArguments:[d]});p.moveCall({target:`${g}::publish_message::publish_message`,arguments:[p.object(this.coreBridgeObjectId),A,K,p.object(me)]}),I&&p.transferObjects([$],p.pure(c)),yield this.createUnsignedTx(p,"Sui.TokenBridge.TransferWithPayload")}else{const[I,$]=p.moveCall({target:`${y}::transfer_tokens::prepare_transfer`,arguments:[P,b,p.pure(Ae(r.chain)),p.pure(He(r.address.toUint8Array())),p.pure(o),p.pure(0)],typeArguments:[d]});p.moveCall({target:`${y}::coin_utils::return_nonzero`,arguments:[$],typeArguments:[d]});const[x]=p.moveCall({target:`${y}::transfer_tokens::transfer_tokens`,arguments:[p.object(this.tokenBridgeObjectId),I],typeArguments:[d]});p.moveCall({target:`${g}::publish_message::publish_message`,arguments:[p.object(this.coreBridgeObjectId),A,x,p.object(me)]}),yield this.createUnsignedTx(p,"Sui.TokenBridge.Transfer")}}async*redeem(t,r,n=!0){const i=await er(this.provider,this.tokenBridgeObjectId,r.payload.token.address.toUint8Array(),Ae(r.payload.token.chain));if(!i)throw new Error("Unable to fetch token coinType");const[s,a]=await this.getPackageIds(),o=new ze,[c]=o.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[o.object(this.coreBridgeObjectId),o.pure(He(Jt(r))),o.object(me)]}),[d]=o.moveCall({target:`${a}::vaa::verify_only_once`,arguments:[o.object(this.tokenBridgeObjectId),c]}),[l]=o.moveCall({target:`${a}::complete_transfer::authorize_transfer`,arguments:[o.object(this.tokenBridgeObjectId),d],typeArguments:[i]}),[m]=o.moveCall({target:`${a}::complete_transfer::redeem_relayer_payout`,arguments:[l],typeArguments:[i]});o.moveCall({target:`${a}::coin_utils::return_nonzero`,arguments:[m],typeArguments:[i]}),yield this.createUnsignedTx(o,"Sui.TokenBridge.Redeem")}async getWrappedNative(){const t=await this.provider.getCoinMetadata({coinType:_e});if(!t)throw new Error("Coin metadata not found");return Kt(this.chain,t.id)}async getPackageIds(){return Promise.all([qt(this.provider,this.coreBridgeObjectId),qt(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(t,r,n){var i;if(n>8)throw new Error("Decimals is capped at 8");const s=(i=await en(this.provider,this.tokenBridgeObjectId))==null?void 0:i.replace("0x","");if(!s)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const a="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+s+"00020106010000000001090b0031"+n.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[Fr.encode(Gr.decode(a))],dependencies:["0x1","0x2",r,t].map(o=>he(o))}}createUnsignedTx(t,r,n=!1){return new an(t,this.network,this.chain,r,n)}}rn(tn,"TokenBridge",Gt);export{Gt as SuiTokenBridge,er as getTokenCoinType,Fi as getTokenFromTokenRegistry};
