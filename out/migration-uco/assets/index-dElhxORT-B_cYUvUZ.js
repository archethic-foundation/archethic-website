import{q as S,aW as z,aX as y,aY as h,aZ as U,a_ as x,a$ as X,b0 as re,b1 as V,b2 as sn,b3 as j,cf as $e,cg as Nn,ch as Dn,cc as qe,ca as _n,aU as ve,cb as rn,cd as Ve,al as D,aV as je,d as se,aF as Ln,b4 as fe,b5 as Un,b6 as Fn,b7 as $n,b8 as qn,b9 as Vn,cm as an,cp as He}from"./index-Bibw8odz.js";import{b as jn}from"./chain-DfK5JtF7-Jmo_aVnV.js";import{S as Hn,a as xe,b as Jn,_ as Zn}from"./solana-DZGZ-AWd-QVqBWA_N.js";import{r as on}from"./index-DpFNxVts-CtfGCFjC.js";var Xn=Object.defineProperty,Gn=(s,e,n)=>e in s?Xn(s,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[e]=n,te=(s,e,n)=>(Gn(s,typeof e!="symbol"?e+"":e,n),n);class Qn extends TypeError{constructor(e,n){let t;const{message:i,...a}=e,{path:o}=e,d=o.length===0?i:"At path: "+o.join(".")+" -- "+i;super(d),Object.assign(this,a),this.name=this.constructor.name,this.failures=()=>{var c;return(c=t)!=null?c:t=[e,...n()]}}}function Yn(s){return G(s)&&typeof s[Symbol.iterator]=="function"}function G(s){return typeof s=="object"&&s!=null}function H(s){return typeof s=="string"?JSON.stringify(s):""+s}function et(s){const{done:e,value:n}=s.next();return e?void 0:n}function nt(s,e,n,t){if(s===!0)return;s===!1?s={}:typeof s=="string"&&(s={message:s});const{path:i,branch:a}=e,{type:o}=n,{refinement:d,message:c="Expected a value of type `"+o+"`"+(d?" with refinement `"+d+"`":"")+", but received: `"+H(t)+"`"}=s;return{value:t,type:o,refinement:d,key:i[i.length-1],path:i,branch:a,...s,message:c}}function*Je(s,e,n,t){Yn(s)||(s=[s]);for(const i of s){const a=nt(i,e,n,t);a&&(yield a)}}function*We(s,e,n={}){const{path:t=[],branch:i=[s],coerce:a=!1,mask:o=!1}=n,d={path:t,branch:i};if(a&&(s=e.coercer(s,d),o&&e.type!=="type"&&G(e.schema)&&G(s)&&!Array.isArray(s)))for(const k in s)e.schema[k]===void 0&&delete s[k];let c=!0;for(const k of e.validator(s,d))c=!1,yield[k,void 0];for(let[k,I,w]of e.entries(s,d)){const A=We(I,w,{path:k===void 0?t:[...t,k],branch:k===void 0?i:[...i,I],coerce:a,mask:o});for(const K of A)K[0]?(c=!1,yield[K[0],void 0]):a&&(I=K[1],k===void 0?s=I:s instanceof Map?s.set(k,I):s instanceof Set?s.add(I):G(s)&&(s[k]=I))}if(c)for(const k of e.refiner(s,d))c=!1,yield[k,void 0];c&&(yield[void 0,s])}let Z=class{constructor(s){const{type:e,schema:n,validator:t,refiner:i,coercer:a=d=>d,entries:o=function*(){}}=s;this.type=e,this.schema=n,this.entries=o,this.coercer=a,t?this.validator=(d,c)=>{const k=t(d,c);return Je(k,c,this,d)}:this.validator=()=>[],i?this.refiner=(d,c)=>{const k=i(d,c);return Je(k,c,this,d)}:this.refiner=()=>[]}assert(s){return tt(s,this)}create(s){return pe(s,this)}is(s){return un(s,this)}mask(s){return st(s,this)}validate(s,e={}){return be(s,this,e)}};function tt(s,e){const n=be(s,e);if(n[0])throw n[0]}function pe(s,e){const n=be(s,e,{coerce:!0});if(n[0])throw n[0];return n[1]}function st(s,e){const n=be(s,e,{coerce:!0,mask:!0});if(n[0])throw n[0];return n[1]}function un(s,e){return!be(s,e)[0]}function be(s,e,n={}){const t=We(s,e,n),i=et(t);return i[0]?[new Qn(i[0],function*(){for(const a of t)a[0]&&(yield a[0])}),void 0]:[void 0,i[1]]}function Y(s,e){return new Z({type:s,schema:null,validator:e})}function it(){return Y("any",()=>!0)}function g(s){return new Z({type:"array",schema:s,*entries(e){if(s&&Array.isArray(e))for(const[n,t]of e.entries())yield[n,t,s]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+H(e)}})}function J(){return Y("boolean",s=>typeof s=="boolean")}function ze(s){return Y("instance",e=>e instanceof s||"Expected a `"+s.name+"` instance, but received: "+H(e))}function T(s){const e=H(s),n=typeof s;return new Z({type:"literal",schema:n==="string"||n==="number"||n==="boolean"?s:null,validator(t){return t===s||"Expected the literal `"+e+"`, but received: "+H(t)}})}function rt(){return Y("never",()=>!1)}function l(s){return new Z({...s,validator:(e,n)=>e===null||s.validator(e,n),refiner:(e,n)=>e===null||s.refiner(e,n)})}function r(){return Y("number",s=>typeof s=="number"&&!isNaN(s)||"Expected a number, but received: "+H(s))}function f(s){return new Z({...s,validator:(e,n)=>e===void 0||s.validator(e,n),refiner:(e,n)=>e===void 0||s.refiner(e,n)})}function cn(s,e){return new Z({type:"record",schema:null,*entries(n){if(G(n))for(const t in n){const i=n[t];yield[t,t,s],yield[t,i,e]}},validator(n){return G(n)||"Expected an object, but received: "+H(n)}})}function m(){return Y("string",s=>typeof s=="string"||"Expected a string, but received: "+H(s))}function Ce(s){const e=rt();return new Z({type:"tuple",schema:null,*entries(n){if(Array.isArray(n)){const t=Math.max(s.length,n.length);for(let i=0;i<t;i++)yield[i,n[i],s[i]||e]}},validator(n){return Array.isArray(n)||"Expected an array, but received: "+H(n)}})}function u(s){const e=Object.keys(s);return new Z({type:"type",schema:s,*entries(n){if(G(n))for(const t of e)yield[t,n[t],s[t]]},validator(n){return G(n)||"Expected an object, but received: "+H(n)}})}function O(s){const e=s.map(n=>n.type).join(" | ");return new Z({type:"union",schema:null,validator(n,t){const i=[];for(const a of s){const[...o]=We(n,a,t),[d]=o;if(d[0])for(const[c]of o)c&&i.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+H(n),...i]}})}function ke(){return Y("unknown",()=>!0)}function Se(s,e,n){return new Z({...s,coercer:(t,i)=>un(t,e)?s.coercer(n(t,i),i):s.coercer(t,i)})}const Ze=()=>{const s=fe.utils.randomPrivateKey(),e=Be(s),n=new Uint8Array(64);return n.set(s),n.set(e,32),{publicKey:e,secretKey:n}},Be=fe.getPublicKey;function Xe(s){try{return fe.ExtendedPoint.fromHex(s),!0}catch{return!1}}const at=(s,e)=>fe.sign(s,e.slice(0,32)),ot=fe.verify,C=s=>S.Buffer.isBuffer(s)?s:s instanceof Uint8Array?S.Buffer.from(s.buffer,s.byteOffset,s.byteLength):S.Buffer.from(s);class ut{constructor(e){Object.assign(this,e)}encode(){return S.Buffer.from(Un(we,this))}static decode(e){return Fn(we,this,e)}static decodeUnchecked(e){return $n(we,this,e)}}const we=new Map;var mn;let dn;const ct=32,le=32;function mt(s){return s._bn!==void 0}let Ge=1;dn=Symbol.toStringTag;class p extends ut{constructor(e){if(super({}),this._bn=void 0,mt(e))this._bn=e._bn;else{if(typeof e=="string"){const n=D.decode(e);if(n.length!=le)throw new Error("Invalid public key input");this._bn=new ve(n)}else this._bn=new ve(e);if(this._bn.byteLength()>le)throw new Error("Invalid public key input")}}static unique(){const e=new p(Ge);return Ge+=1,new p(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return D.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(S.Buffer);if(e.length===le)return e;const n=S.Buffer.alloc(32);return e.copy(n,32-e.length),n}get[dn](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,n,t){const i=S.Buffer.concat([e.toBuffer(),S.Buffer.from(n),t.toBuffer()]),a=je(i);return new p(a)}static createProgramAddressSync(e,n){let t=S.Buffer.alloc(0);e.forEach(function(a){if(a.length>ct)throw new TypeError("Max seed length exceeded");t=S.Buffer.concat([t,C(a)])}),t=S.Buffer.concat([t,n.toBuffer(),S.Buffer.from("ProgramDerivedAddress")]);const i=je(t);if(Xe(i))throw new Error("Invalid seeds, address must fall off the curve");return new p(i)}static async createProgramAddress(e,n){return this.createProgramAddressSync(e,n)}static findProgramAddressSync(e,n){let t=255,i;for(;t!=0;){try{const a=e.concat(S.Buffer.from([t]));i=this.createProgramAddressSync(a,n)}catch(a){if(a instanceof TypeError)throw a;t--;continue}return[i,t]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,n){return this.findProgramAddressSync(e,n)}static isOnCurve(e){const n=new p(e);return Xe(n.toBytes())}}mn=p;p.default=new mn("11111111111111111111111111111111");we.set(p,{kind:"struct",fields:[["_bn","u256"]]});new p("BPFLoader1111111111111111111111111111111111");const Ke=1232,dt=127,ln=64;class Qe{constructor(e,n){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=n}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const n of this.keySegments()){if(e<n.length)return n[e];e-=n.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((i,a)=>{n.set(i.toBase58(),a)});const t=i=>{const a=n.get(i.toBase58());if(a===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return a};return e.map(i=>({programIdIndex:t(i.programId),accountKeyIndexes:i.keys.map(a=>t(a.pubkey)),data:i.data}))}}const M=(s="publicKey")=>j(32,s),ie=(s="string")=>{const e=y([h("length"),h("lengthPadding"),j(re(h(),-8),"chars")],s),n=e.decode.bind(e),t=e.encode.bind(e),i=e;return i.decode=(a,o)=>n(a,o).chars.toString(),i.encode=(a,o,d)=>{const c={chars:S.Buffer.from(a,"utf8")};return t(c,o,d)},i.alloc=a=>h().span+h().span+S.Buffer.from(a,"utf8").length,i},lt=(s="authorized")=>y([M("staker"),M("withdrawer")],s),gt=(s="lockup")=>y([U("unixTimestamp"),U("epoch"),M("custodian")],s),pt=(s="voteInit")=>y([M("nodePubkey"),M("authorizedVoter"),M("authorizedWithdrawer"),x("commission")],s),yt=(s="voteAuthorizeWithSeedArgs")=>y([h("voteAuthorizationType"),M("currentAuthorityDerivedKeyOwnerPubkey"),ie("currentAuthorityDerivedKeySeed"),M("newAuthorized")],s);function gn(s,e){const n=i=>{if(i.span>=0)return i.span;if(typeof i.alloc=="function")return i.alloc(e[i.property]);if("count"in i&&"elementLayout"in i){const a=e[i.property];if(Array.isArray(a))return a.length*n(i.elementLayout)}else if("fields"in i)return gn({layout:i},e[i.property]);return 0};let t=0;return s.layout.fields.forEach(i=>{t+=n(i)}),t}function ce(s){let e=0,n=0;for(;;){let t=s.shift();if(e|=(t&127)<<n*7,n+=1,!(t&128))break}return e}function me(s,e){let n=e;for(;;){let t=n&127;if(n>>=7,n==0){s.push(t);break}else t|=128,s.push(t)}}function N(s,e){if(!s)throw new Error(e||"Assertion failed")}class Oe{constructor(e,n){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=n}static compile(e,n){const t=new Map,i=o=>{const d=o.toBase58();let c=t.get(d);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},t.set(d,c)),c},a=i(n);a.isSigner=!0,a.isWritable=!0;for(const o of e){i(o.programId).isInvoked=!0;for(const d of o.keys){const c=i(d.pubkey);c.isSigner||(c.isSigner=d.isSigner),c.isWritable||(c.isWritable=d.isWritable)}}return new Oe(n,t)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];N(e.length<=256,"Max static account keys length exceeded");const n=e.filter(([,c])=>c.isSigner&&c.isWritable),t=e.filter(([,c])=>c.isSigner&&!c.isWritable),i=e.filter(([,c])=>!c.isSigner&&c.isWritable),a=e.filter(([,c])=>!c.isSigner&&!c.isWritable),o={numRequiredSignatures:n.length+t.length,numReadonlySignedAccounts:t.length,numReadonlyUnsignedAccounts:a.length};{N(n.length>0,"Expected at least one writable signer key");const[c]=n[0];N(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const d=[...n.map(([c])=>new p(c)),...t.map(([c])=>new p(c)),...i.map(([c])=>new p(c)),...a.map(([c])=>new p(c))];return[o,d]}extractTableLookup(e){const[n,t]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[i,a]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(n.length===0&&i.length===0))return[{accountKey:e.key,writableIndexes:n,readonlyIndexes:i},{writable:t,readonly:a}]}drainKeysFoundInLookupTable(e,n){const t=new Array,i=new Array;for(const[a,o]of this.keyMetaMap.entries())if(n(o)){const d=new p(a),c=e.findIndex(k=>k.equals(d));c>=0&&(N(c<256,"Max lookup table index exceeded"),t.push(c),i.push(d),this.keyMetaMap.delete(a))}return[t,i]}}const pn="Reached end of buffer unexpectedly";function Me(s){if(s.length===0)throw new Error(pn);return s.shift()}function de(s,...e){const[n]=e;if(e.length===2?n+(e[1]??0)>s.length:n>=s.length)throw new Error(pn);return s.splice(...e)}class ye{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(n=>new p(n)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(n=>this.indexToProgramIds.set(n.programIdIndex,this.accountKeys[n.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:D.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Qe(this.staticAccountKeys)}static compile(e){const n=Oe.compile(e.instructions,e.payerKey),[t,i]=n.getMessageComponents(),a=new Qe(i).compileInstructions(e.instructions).map(o=>({programIdIndex:o.programIdIndex,accounts:o.accountKeyIndexes,data:D.encode(o.data)}));return new ye({header:t,accountKeys:i,recentBlockhash:e.recentBlockhash,instructions:a})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const n=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const t=e-n,i=this.accountKeys.length-n-this.header.numReadonlyUnsignedAccounts;return t<i}else{const t=n-this.header.numReadonlySignedAccounts;return e<t}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,n)=>!this.isProgramId(n))}serialize(){const e=this.accountKeys.length;let n=[];me(n,e);const t=this.instructions.map(w=>{const{accounts:A,programIdIndex:K}=w,R=Array.from(D.decode(w.data));let b=[];me(b,A.length);let v=[];return me(v,R.length),{programIdIndex:K,keyIndicesCount:S.Buffer.from(b),keyIndices:A,dataLength:S.Buffer.from(v),data:R}});let i=[];me(i,t.length);let a=S.Buffer.alloc(Ke);S.Buffer.from(i).copy(a);let o=i.length;t.forEach(w=>{const A=y([x("programIdIndex"),j(w.keyIndicesCount.length,"keyIndicesCount"),X(x("keyIndex"),w.keyIndices.length,"keyIndices"),j(w.dataLength.length,"dataLength"),X(x("userdatum"),w.data.length,"data")]).encode(w,a,o);o+=A}),a=a.slice(0,o);const d=y([j(1,"numRequiredSignatures"),j(1,"numReadonlySignedAccounts"),j(1,"numReadonlyUnsignedAccounts"),j(n.length,"keyCount"),X(M("key"),e,"keys"),M("recentBlockhash")]),c={numRequiredSignatures:S.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:S.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:S.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:S.Buffer.from(n),keys:this.accountKeys.map(w=>C(w.toBytes())),recentBlockhash:D.decode(this.recentBlockhash)};let k=S.Buffer.alloc(2048);const I=d.encode(c,k);return a.copy(k,I),k.slice(0,I+a.length)}static from(e){let n=[...e];const t=Me(n);if(t!==(t&dt))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=Me(n),a=Me(n),o=ce(n);let d=[];for(let A=0;A<o;A++){const K=de(n,0,le);d.push(new p(S.Buffer.from(K)))}const c=de(n,0,le),k=ce(n);let I=[];for(let A=0;A<k;A++){const K=Me(n),R=ce(n),b=de(n,0,R),v=ce(n),B=de(n,0,v),Q=D.encode(S.Buffer.from(B));I.push({programIdIndex:K,accounts:b,data:Q})}const w={header:{numRequiredSignatures:t,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:a},recentBlockhash:D.encode(S.Buffer.from(c)),accountKeys:d,instructions:I};return new ye(w)}}const ht=S.Buffer.alloc(ln).fill(0);class q{constructor(e){this.keys=void 0,this.programId=void 0,this.data=S.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:n,isWritable:t})=>({pubkey:e.toJSON(),isSigner:n,isWritable:t})),programId:this.programId.toJSON(),data:[...this.data]}}}class ae{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:n,nonceInfo:t}=e;this.minNonceContextSlot=n,this.nonceInfo=t}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:n,lastValidBlockHeight:t}=e;this.recentBlockhash=n,this.lastValidBlockHeight=t}else{const{recentBlockhash:n,nonceInfo:t}=e;t&&(this.nonceInfo=t),this.recentBlockhash=n}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(n=>{"instructions"in n?this.instructions=this.instructions.concat(n.instructions):"data"in n&&"programId"in n&&"keys"in n?this.instructions.push(n):this.instructions.push(new q(n))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,n;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?n=[this.nonceInfo.nonceInstruction,...this.instructions]:n=this.instructions):(e=this.recentBlockhash,n=this.instructions),!e)throw new Error("Transaction recentBlockhash required");n.length<1&&console.warn("No instructions provided");let t;if(this.feePayer)t=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)t=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let b=0;b<n.length;b++)if(n[b].programId===void 0)throw new Error(`Transaction instruction index ${b} has undefined program id`);const i=[],a=[];n.forEach(b=>{b.keys.forEach(B=>{a.push({...B})});const v=b.programId.toString();i.includes(v)||i.push(v)}),i.forEach(b=>{a.push({pubkey:new p(b),isSigner:!1,isWritable:!1})});const o=[];a.forEach(b=>{const v=b.pubkey.toString(),B=o.findIndex(Q=>Q.pubkey.toString()===v);B>-1?(o[B].isWritable=o[B].isWritable||b.isWritable,o[B].isSigner=o[B].isSigner||b.isSigner):o.push(b)}),o.sort(function(b,v){if(b.isSigner!==v.isSigner)return b.isSigner?-1:1;if(b.isWritable!==v.isWritable)return b.isWritable?-1:1;const B={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return b.pubkey.toBase58().localeCompare(v.pubkey.toBase58(),"en",B)});const d=o.findIndex(b=>b.pubkey.equals(t));if(d>-1){const[b]=o.splice(d,1);b.isSigner=!0,b.isWritable=!0,o.unshift(b)}else o.unshift({pubkey:t,isSigner:!0,isWritable:!0});for(const b of this.signatures){const v=o.findIndex(B=>B.pubkey.equals(b.publicKey));if(v>-1)o[v].isSigner||(o[v].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${b.publicKey.toString()}`)}let c=0,k=0,I=0;const w=[],A=[];o.forEach(({pubkey:b,isSigner:v,isWritable:B})=>{v?(w.push(b.toString()),c+=1,B||(k+=1)):(A.push(b.toString()),B||(I+=1))});const K=w.concat(A),R=n.map(b=>{const{data:v,programId:B}=b;return{programIdIndex:K.indexOf(B.toString()),accounts:b.keys.map(Q=>K.indexOf(Q.pubkey.toString())),data:D.encode(v)}});return R.forEach(b=>{N(b.programIdIndex>=0),b.accounts.forEach(v=>N(v>=0))}),new ye({header:{numRequiredSignatures:c,numReadonlySignedAccounts:k,numReadonlyUnsignedAccounts:I},accountKeys:K,recentBlockhash:e,instructions:R})}_compile(){const e=this.compileMessage(),n=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===n.length&&this.signatures.every((t,i)=>n[i].equals(t.publicKey))||(this.signatures=n.map(t=>({signature:null,publicKey:t}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const n=new Set;this.signatures=e.filter(t=>{const i=t.toString();return n.has(i)?!1:(n.add(i),!0)}).map(t=>({signature:null,publicKey:t}))}sign(...e){if(e.length===0)throw new Error("No signers");const n=new Set,t=[];for(const a of e){const o=a.publicKey.toString();n.has(o)||(n.add(o),t.push(a))}this.signatures=t.map(a=>({signature:null,publicKey:a.publicKey}));const i=this._compile();this._partialSign(i,...t)}partialSign(...e){if(e.length===0)throw new Error("No signers");const n=new Set,t=[];for(const a of e){const o=a.publicKey.toString();n.has(o)||(n.add(o),t.push(a))}const i=this._compile();this._partialSign(i,...t)}_partialSign(e,...n){const t=e.serialize();n.forEach(i=>{const a=at(t,i.secretKey);this._addSignature(i.publicKey,C(a))})}addSignature(e,n){this._compile(),this._addSignature(e,n)}_addSignature(e,n){N(n.length===64);const t=this.signatures.findIndex(i=>e.equals(i.publicKey));if(t<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[t].signature=S.Buffer.from(n)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,n){const t={};for(const{signature:i,publicKey:a}of this.signatures)i===null?n&&(t.missing||(t.missing=[])).push(a):ot(i,e,a.toBytes())||(t.invalid||(t.invalid=[])).push(a);return t.invalid||t.missing?t:void 0}serialize(e){const{requireAllSignatures:n,verifySignatures:t}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),i=this.serializeMessage();if(t){const a=this._getMessageSignednessErrors(i,n);if(a){let o="Signature verification failed.";throw a.invalid&&(o+=`
Invalid signature for public key${a.invalid.length===1?"":"(s)"} [\`${a.invalid.map(d=>d.toBase58()).join("`, `")}\`].`),a.missing&&(o+=`
Missing signature for public key${a.missing.length===1?"":"(s)"} [\`${a.missing.map(d=>d.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(i)}_serialize(e){const{signatures:n}=this,t=[];me(t,n.length);const i=t.length+n.length*64+e.length,a=S.Buffer.alloc(i);return N(n.length<256),S.Buffer.from(t).copy(a,0),n.forEach(({signature:o},d)=>{o!==null&&(N(o.length===64,"signature has invalid length"),S.Buffer.from(o).copy(a,t.length+d*64))}),e.copy(a,t.length+n.length*64),N(a.length<=Ke,`Transaction too large: ${a.length} > ${Ke}`),a}get keys(){return N(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return N(this.instructions.length===1),this.instructions[0].programId}get data(){return N(this.instructions.length===1),this.instructions[0].data}static from(e){let n=[...e];const t=ce(n);let i=[];for(let a=0;a<t;a++){const o=de(n,0,ln);i.push(D.encode(S.Buffer.from(o)))}return ae.populate(ye.from(n),i)}static populate(e,n=[]){const t=new ae;return t.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(t.feePayer=e.accountKeys[0]),n.forEach((i,a)=>{const o={signature:i==D.encode(ht)?null:D.decode(i),publicKey:e.accountKeys[a]};t.signatures.push(o)}),e.instructions.forEach(i=>{const a=i.accounts.map(o=>{const d=e.accountKeys[o];return{pubkey:d,isSigner:t.signatures.some(c=>c.publicKey.toString()===d.toString())||e.isAccountSigner(o),isWritable:e.isAccountWritable(o)}});t.instructions.push(new q({keys:a,programId:e.accountKeys[i.programIdIndex],data:D.decode(i.data)}))}),t._message=e,t._json=t.toJSON(),t}}new p("SysvarC1ock11111111111111111111111111111111");new p("SysvarEpochSchedu1e111111111111111111111111");new p("Sysvar1nstructions1111111111111111111111111");const Te=new p("SysvarRecentB1ockHashes11111111111111111111"),Ye=new p("SysvarRent111111111111111111111111111111111");new p("SysvarRewards111111111111111111111111111111");new p("SysvarS1otHashes111111111111111111111111111");new p("SysvarS1otHistory11111111111111111111111111");new p("SysvarStakeHistory1111111111111111111111111");function _(s,e){const n=s.layout.span>=0?s.layout.span:gn(s,e),t=S.Buffer.alloc(n),i=Object.assign({instruction:s.index},e);return s.layout.encode(i,t),t}const ft=z("lamportsPerSignature"),bt=y([h("version"),h("state"),M("authorizedPubkey"),M("nonce"),y([ft],"feeCalculator")]),en=bt.span,kt=s=>{const e=s.decode.bind(s),n=s.encode.bind(s);return{decode:e,encode:n}},St=s=>e=>{const n=j(s,e),{encode:t,decode:i}=kt(n),a=n;return a.decode=(o,d)=>{const c=i(o,d);return qn(S.Buffer.from(c))},a.encode=(o,d,c)=>{const k=Vn(o,s);return t(k,d,c)},a},oe=St(8),L=Object.freeze({Create:{index:0,layout:y([h("instruction"),U("lamports"),U("space"),M("programId")])},Assign:{index:1,layout:y([h("instruction"),M("programId")])},Transfer:{index:2,layout:y([h("instruction"),oe("lamports")])},CreateWithSeed:{index:3,layout:y([h("instruction"),M("base"),ie("seed"),U("lamports"),U("space"),M("programId")])},AdvanceNonceAccount:{index:4,layout:y([h("instruction")])},WithdrawNonceAccount:{index:5,layout:y([h("instruction"),U("lamports")])},InitializeNonceAccount:{index:6,layout:y([h("instruction"),M("authorized")])},AuthorizeNonceAccount:{index:7,layout:y([h("instruction"),M("authorized")])},Allocate:{index:8,layout:y([h("instruction"),U("space")])},AllocateWithSeed:{index:9,layout:y([h("instruction"),M("base"),ie("seed"),U("space"),M("programId")])},AssignWithSeed:{index:10,layout:y([h("instruction"),M("base"),ie("seed"),M("programId")])},TransferWithSeed:{index:11,layout:y([h("instruction"),oe("lamports"),ie("seed"),M("programId")])},UpgradeNonceAccount:{index:12,layout:y([h("instruction")])}});class he{constructor(){}static createAccount(e){const n=L.Create,t=_(n,{lamports:e.lamports,space:e.space,programId:C(e.programId.toBuffer())});return new q({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:t})}static transfer(e){let n,t;if("basePubkey"in e){const i=L.TransferWithSeed;n=_(i,{lamports:BigInt(e.lamports),seed:e.seed,programId:C(e.programId.toBuffer())}),t=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const i=L.Transfer;n=_(i,{lamports:BigInt(e.lamports)}),t=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new q({keys:t,programId:this.programId,data:n})}static assign(e){let n,t;if("basePubkey"in e){const i=L.AssignWithSeed;n=_(i,{base:C(e.basePubkey.toBuffer()),seed:e.seed,programId:C(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const i=L.Assign;n=_(i,{programId:C(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new q({keys:t,programId:this.programId,data:n})}static createAccountWithSeed(e){const n=L.CreateWithSeed,t=_(n,{base:C(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:C(e.programId.toBuffer())});let i=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&i.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new q({keys:i,programId:this.programId,data:t})}static createNonceAccount(e){const n=new ae;"basePubkey"in e&&"seed"in e?n.add(he.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:en,programId:this.programId})):n.add(he.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:en,programId:this.programId}));const t={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return n.add(this.nonceInitialize(t)),n}static nonceInitialize(e){const n=L.InitializeNonceAccount,t=_(n,{authorized:C(e.authorizedPubkey.toBuffer())}),i={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Te,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1}],programId:this.programId,data:t};return new q(i)}static nonceAdvance(e){const n=L.AdvanceNonceAccount,t=_(n),i={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Te,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t};return new q(i)}static nonceWithdraw(e){const n=L.WithdrawNonceAccount,t=_(n,{lamports:e.lamports});return new q({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Te,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceAuthorize(e){const n=L.AuthorizeNonceAccount,t=_(n,{authorized:C(e.newAuthorizedPubkey.toBuffer())});return new q({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static allocate(e){let n,t;if("basePubkey"in e){const i=L.AllocateWithSeed;n=_(i,{base:C(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:C(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const i=L.Allocate;n=_(i,{space:e.space}),t=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new q({keys:t,programId:this.programId,data:n})}}he.programId=new p("11111111111111111111111111111111");new p("BPFLoader2111111111111111111111111111111111");y([h("typeIndex"),oe("deactivationSlot"),z("lastExtendedSlot"),x("lastExtendedStartIndex"),x(),X(M(),re(x(),-1),"authority")]);const E=Se(ze(p),m(),s=>new p(s)),yn=Ce([m(),T("base64")]),Re=Se(ze(S.Buffer),yn,s=>S.Buffer.from(s[0],"base64"));function hn(s){return O([u({jsonrpc:T("2.0"),id:m(),result:s}),u({jsonrpc:T("2.0"),id:m(),error:u({code:ke(),message:m(),data:f(it())})})])}const Mt=hn(ke());function P(s){return Se(hn(s),Mt,e=>"error"in e?e:{...e,result:pe(e.result,s)})}function F(s){return P(u({context:u({slot:r()}),value:s}))}function Ie(s){return u({context:u({slot:r()}),value:s})}const wt=u({foundation:r(),foundationTerm:r(),initial:r(),taper:r(),terminal:r()});P(g(l(u({epoch:r(),effectiveSlot:r(),amount:r(),postBalance:r(),commission:f(l(r()))}))));const vt=g(u({slot:r(),prioritizationFee:r()})),Pt=u({total:r(),validator:r(),foundation:r(),epoch:r()}),It=u({epoch:r(),slotIndex:r(),slotsInEpoch:r(),absoluteSlot:r(),blockHeight:f(r()),transactionCount:f(r())}),At=u({slotsPerEpoch:r(),leaderScheduleSlotOffset:r(),warmup:J(),firstNormalEpoch:r(),firstNormalSlot:r()}),Tt=cn(m(),g(r())),ee=l(O([u({}),m()])),xt=u({err:ee}),Bt=T("receivedSignature");u({"solana-core":m(),"feature-set":f(r())});F(u({err:l(O([u({}),m()])),logs:l(g(m())),accounts:f(l(g(l(u({executable:J(),owner:m(),lamports:r(),data:g(m()),rentEpoch:f(r())}))))),unitsConsumed:f(r()),returnData:f(l(u({programId:m(),data:Ce([m(),T("base64")])})))}));F(u({byIdentity:cn(m(),g(r())),range:u({firstSlot:r(),lastSlot:r()})}));P(wt);P(Pt);P(vt);P(It);P(At);P(Tt);P(r());F(u({total:r(),circulating:r(),nonCirculating:r(),nonCirculatingAccounts:g(E)}));const Kt=u({amount:m(),uiAmount:l(r()),decimals:r(),uiAmountString:f(m())});F(g(u({address:E,amount:m(),uiAmount:l(r()),decimals:r(),uiAmountString:f(m())})));F(g(u({pubkey:E,account:u({executable:J(),owner:E,lamports:r(),data:Re,rentEpoch:r()})})));const Ee=u({program:m(),parsed:ke(),space:r()});F(g(u({pubkey:E,account:u({executable:J(),owner:E,lamports:r(),data:Ee,rentEpoch:r()})})));F(g(u({lamports:r(),address:E})));const Ne=u({executable:J(),owner:E,lamports:r(),data:Re,rentEpoch:r()});u({pubkey:E,account:Ne});const Et=Se(O([ze(S.Buffer),Ee]),O([yn,Ee]),s=>Array.isArray(s)?pe(s,Re):s),Wt=u({executable:J(),owner:E,lamports:r(),data:Et,rentEpoch:r()});u({pubkey:E,account:Wt});u({state:O([T("active"),T("inactive"),T("activating"),T("deactivating")]),active:r(),inactive:r()});P(g(u({signature:m(),slot:r(),err:ee,memo:l(m()),blockTime:f(l(r()))})));P(g(u({signature:m(),slot:r(),err:ee,memo:l(m()),blockTime:f(l(r()))})));u({subscription:r(),result:Ie(Ne)});const zt=u({pubkey:E,account:Ne});u({subscription:r(),result:Ie(zt)});const Ct=u({parent:r(),slot:r(),root:r()});u({subscription:r(),result:Ct});const Ot=O([u({type:O([T("firstShredReceived"),T("completed"),T("optimisticConfirmation"),T("root")]),slot:r(),timestamp:r()}),u({type:T("createdBank"),parent:r(),slot:r(),timestamp:r()}),u({type:T("frozen"),slot:r(),timestamp:r(),stats:u({numTransactionEntries:r(),numSuccessfulTransactions:r(),numFailedTransactions:r(),maxTransactionsPerEntry:r()})}),u({type:T("dead"),slot:r(),timestamp:r(),err:m()})]);u({subscription:r(),result:Ot});u({subscription:r(),result:Ie(O([xt,Bt]))});u({subscription:r(),result:r()});u({pubkey:m(),gossip:l(m()),tpu:l(m()),rpc:l(m()),version:l(m())});const nn=u({votePubkey:m(),nodePubkey:m(),activatedStake:r(),epochVoteAccount:J(),epochCredits:g(Ce([r(),r(),r()])),commission:r(),lastVote:r(),rootSlot:l(r())});P(u({current:g(nn),delinquent:g(nn)}));const Rt=O([T("processed"),T("confirmed"),T("finalized")]),Nt=u({slot:r(),confirmations:l(r()),err:ee,confirmationStatus:f(Rt)});F(g(l(Nt)));P(r());const fn=u({accountKey:E,writableIndexes:g(r()),readonlyIndexes:g(r())}),De=u({signatures:g(m()),message:u({accountKeys:g(m()),header:u({numRequiredSignatures:r(),numReadonlySignedAccounts:r(),numReadonlyUnsignedAccounts:r()}),instructions:g(u({accounts:g(r()),data:m(),programIdIndex:r()})),recentBlockhash:m(),addressTableLookups:f(g(fn))})}),bn=u({pubkey:E,signer:J(),writable:J(),source:f(O([T("transaction"),T("lookupTable")]))}),kn=u({accountKeys:g(bn),signatures:g(m())}),Sn=u({parsed:ke(),program:m(),programId:E}),Mn=u({accounts:g(E),data:m(),programId:E}),Dt=O([Mn,Sn]),_t=O([u({parsed:ke(),program:m(),programId:m()}),u({accounts:g(m()),data:m(),programId:m()})]),wn=Se(Dt,_t,s=>"accounts"in s?pe(s,Mn):pe(s,Sn)),vn=u({signatures:g(m()),message:u({accountKeys:g(bn),instructions:g(wn),recentBlockhash:m(),addressTableLookups:f(l(g(fn)))})}),Pe=u({accountIndex:r(),mint:m(),owner:f(m()),uiTokenAmount:Kt}),Pn=u({writable:g(E),readonly:g(E)}),Ae=u({err:ee,fee:r(),innerInstructions:f(l(g(u({index:r(),instructions:g(u({accounts:g(r()),data:m(),programIdIndex:r()}))})))),preBalances:g(r()),postBalances:g(r()),logMessages:f(l(g(m()))),preTokenBalances:f(l(g(Pe))),postTokenBalances:f(l(g(Pe))),loadedAddresses:f(Pn),computeUnitsConsumed:f(r())}),_e=u({err:ee,fee:r(),innerInstructions:f(l(g(u({index:r(),instructions:g(wn)})))),preBalances:g(r()),postBalances:g(r()),logMessages:f(l(g(m()))),preTokenBalances:f(l(g(Pe))),postTokenBalances:f(l(g(Pe))),loadedAddresses:f(Pn),computeUnitsConsumed:f(r())}),ue=O([T(0),T("legacy")]),ne=u({pubkey:m(),lamports:r(),postBalance:l(r()),rewardType:l(m()),commission:f(l(r()))});P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),transactions:g(u({transaction:De,meta:l(Ae),version:f(ue)})),rewards:f(g(ne)),blockTime:l(r()),blockHeight:l(r())})));P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),rewards:f(g(ne)),blockTime:l(r()),blockHeight:l(r())})));P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),transactions:g(u({transaction:kn,meta:l(Ae),version:f(ue)})),rewards:f(g(ne)),blockTime:l(r()),blockHeight:l(r())})));P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),transactions:g(u({transaction:vn,meta:l(_e),version:f(ue)})),rewards:f(g(ne)),blockTime:l(r()),blockHeight:l(r())})));P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),transactions:g(u({transaction:kn,meta:l(_e),version:f(ue)})),rewards:f(g(ne)),blockTime:l(r()),blockHeight:l(r())})));P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),rewards:f(g(ne)),blockTime:l(r()),blockHeight:l(r())})));P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),transactions:g(u({transaction:De,meta:l(Ae)})),rewards:f(g(ne)),blockTime:l(r())})));P(l(u({blockhash:m(),previousBlockhash:m(),parentSlot:r(),signatures:g(m()),blockTime:l(r())})));P(l(u({slot:r(),meta:l(Ae),blockTime:f(l(r())),transaction:De,version:f(ue)})));P(l(u({slot:r(),transaction:vn,meta:l(_e),blockTime:f(l(r())),version:f(ue)})));F(u({blockhash:m(),feeCalculator:u({lamportsPerSignature:r()})}));F(u({blockhash:m(),lastValidBlockHeight:r()}));F(J());const Lt=u({slot:r(),numTransactions:r(),numSlots:r(),samplePeriodSecs:r()});P(g(Lt));F(l(u({feeCalculator:u({lamportsPerSignature:r()})})));P(m());P(m());const Ut=u({err:ee,logs:g(m()),signature:m()});u({result:Ie(Ut),subscription:r()});class ge{constructor(e){this._keypair=void 0,this._keypair=e??Ze()}static generate(){return new ge(Ze())}static fromSecretKey(e,n){if(e.byteLength!==64)throw new Error("bad secret key size");const t=e.slice(32,64);if(!n||!n.skipValidation){const i=e.slice(0,32),a=Be(i);for(let o=0;o<32;o++)if(t[o]!==a[o])throw new Error("provided secretKey is invalid")}return new ge({publicKey:t,secretKey:e})}static fromSeed(e){const n=Be(e),t=new Uint8Array(64);return t.set(e),t.set(n,32),new ge({publicKey:n,secretKey:t})}get publicKey(){return new p(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:y([h("instruction"),oe("recentSlot"),x("bumpSeed")])},FreezeLookupTable:{index:1,layout:y([h("instruction")])},ExtendLookupTable:{index:2,layout:y([h("instruction"),oe(),X(M(),re(h(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:y([h("instruction")])},CloseLookupTable:{index:4,layout:y([h("instruction")])}});new p("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:y([x("instruction"),h("units"),h("additionalFee")])},RequestHeapFrame:{index:1,layout:y([x("instruction"),h("bytes")])},SetComputeUnitLimit:{index:2,layout:y([x("instruction"),h("units")])},SetComputeUnitPrice:{index:3,layout:y([x("instruction"),oe("microLamports")])}});new p("ComputeBudget111111111111111111111111111111");y([x("numSignatures"),x("padding"),V("signatureOffset"),V("signatureInstructionIndex"),V("publicKeyOffset"),V("publicKeyInstructionIndex"),V("messageDataOffset"),V("messageDataSize"),V("messageInstructionIndex")]);new p("Ed25519SigVerify111111111111111111111111111");sn.utils.isValidPrivateKey;sn.getPublicKey;y([x("numSignatures"),V("signatureOffset"),x("signatureInstructionIndex"),V("ethAddressOffset"),x("ethAddressInstructionIndex"),V("messageDataOffset"),V("messageDataSize"),x("messageInstructionIndex"),j(20,"ethAddress"),j(64,"signature"),x("recoveryId")]);new p("KeccakSecp256k11111111111111111111111111111");var In;new p("StakeConfig11111111111111111111111111111111");class An{constructor(e,n,t){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=n,this.custodian=t}}In=An;An.default=new In(0,0,p.default);Object.freeze({Initialize:{index:0,layout:y([h("instruction"),lt(),gt()])},Authorize:{index:1,layout:y([h("instruction"),M("newAuthorized"),h("stakeAuthorizationType")])},Delegate:{index:2,layout:y([h("instruction")])},Split:{index:3,layout:y([h("instruction"),U("lamports")])},Withdraw:{index:4,layout:y([h("instruction"),U("lamports")])},Deactivate:{index:5,layout:y([h("instruction")])},Merge:{index:7,layout:y([h("instruction")])},AuthorizeWithSeed:{index:8,layout:y([h("instruction"),M("newAuthorized"),h("stakeAuthorizationType"),ie("authoritySeed"),M("authorityOwner")])}});new p("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:y([h("instruction"),pt()])},Authorize:{index:1,layout:y([h("instruction"),M("newAuthorized"),h("voteAuthorizationType")])},Withdraw:{index:3,layout:y([h("instruction"),U("lamports")])},UpdateValidatorIdentity:{index:4,layout:y([h("instruction")])},AuthorizeWithSeed:{index:10,layout:y([h("instruction"),yt()])}});new p("Vote111111111111111111111111111111111111111");new p("Va1idator1nfo111111111111111111111111111111");u({name:m(),website:f(m()),details:f(m()),keybaseUsername:f(m())});new p("Vote111111111111111111111111111111111111111");y([M("nodePubkey"),M("authorizedWithdrawer"),x("commission"),z(),X(y([z("slot"),h("confirmationCount")]),re(h(),-8),"votes"),x("rootSlotValid"),z("rootSlot"),z(),X(y([z("epoch"),M("authorizedVoter")]),re(h(),-8),"authorizedVoters"),y([X(y([M("authorizedPubkey"),z("epochOfLastAuthorizedSwitch"),z("targetEpoch")]),32,"buf"),z("idx"),x("isEmpty")],"priorVoters"),z(),X(y([z("epoch"),z("credits"),z("prevCredits")]),re(h(),-8),"epochCredits"),y([z("slot"),z("timestamp")],"lastTimestamp")]);const Le=new p("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new p("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const Ft=new p("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new p("So11111111111111111111111111111111111111112");new p("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");class $t extends Error{constructor(e){super(e)}}class qt extends $t{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}const Vt=y([h("mintAuthorityOption"),$e("mintAuthority"),Nn("supply"),x("decimals"),Dn("isInitialized"),h("freezeAuthorityOption"),$e("freezeAuthority")]);Vt.span;function jt(s,e,n=!1,t=Le,i=Ft){if(!n&&!p.isOnCurve(e.toBuffer()))throw new qt;const[a]=p.findProgramAddressSync([e.toBuffer(),t.toBuffer(),s.toBuffer()],i);return a}function Tn(s,e){return new an(En.TokenMessengerIdl,new p(s),e===void 0?{connection:null}:e)}function Ht(s,e){return Tn(s,on(e))}function xn(s,e){return new an(En.MessageTransmitterIdl,new p(s),e===void 0?{connection:null}:e)}function Jt(s,e){return xn(s,on(e))}const W=(s,e,n)=>{const t=[se.Buffer.from(He.bytes.utf8.encode(s))];if(n)for(const a of n)typeof a=="string"?t.push(se.Buffer.from(He.bytes.utf8.encode(a))):Array.isArray(a)?t.push(se.Buffer.from(a)):se.Buffer.isBuffer(a)?t.push(a):t.push(a.toBuffer());const i=p.findProgramAddressSync(t,e);return{publicKey:i[0],bump:i[1]}};function Zt(s,e,n,t,i,a,o,d,c){const k=W("message_transmitter",s),I=W("token_messenger",e),w=W("token_minter",e),A=W("local_token",e,[n]),K=W("remote_token_messenger",e,[t.toString()]),R=W("sender_authority",e),b=Tn(e),v=W("__event_authority",e);return b.methods.depositForBurn({amount:new ve(d.toString()),destinationDomain:t,mintRecipient:new p(o.toUint8Array())}).accounts({owner:i,senderAuthorityPda:R.publicKey,burnTokenAccount:a,messageTransmitter:k.publicKey,tokenMessenger:I.publicKey,remoteTokenMessenger:K.publicKey,tokenMinter:w.publicKey,localToken:A.publicKey,burnTokenMint:n,messageTransmitterProgram:s,tokenMessengerMinterProgram:e,tokenProgram:Le,eventAuthority:v.publicKey,eventRentPayer:i,messageSentEventData:c}).instruction()}const tn=6400n;function Bn(s){return(s-BigInt(1))/tn*tn+BigInt(1)}function Kn(s,e,n){const t=e.toString();return W("used_nonces",n,[t,Bn(s).toString()]).publicKey}async function Xt(s,e,n,t,i,a){const o=se.Buffer.from(rn.serialize(t)),d=se.Buffer.from(Ln.decode(i)),c=new p(n),k=new p(t.payload.burnToken.toUint8Array()),I=new xe(t.payload.mintRecipient).unwrap(),w=a?new p(a):I,A=t.sourceDomain.toString(),K=W("message_transmitter",s),R=W("token_messenger",e),b=W("token_minter",e),v=W("local_token",e,[c]),B=W("remote_token_messenger",e,[A]),Q=W("token_pair",e,[A,k]),Wn=W("custody",e,[c]),zn=W("message_transmitter_authority",s,[e]).publicKey,Cn=Kn(t.nonce,t.sourceDomain,s),On=W("__event_authority",s),Rn=W("__event_authority",e),$=[];$.push({isSigner:!1,isWritable:!1,pubkey:R.publicKey}),$.push({isSigner:!1,isWritable:!1,pubkey:B.publicKey}),$.push({isSigner:!1,isWritable:!0,pubkey:b.publicKey}),$.push({isSigner:!1,isWritable:!0,pubkey:v.publicKey}),$.push({isSigner:!1,isWritable:!1,pubkey:Q.publicKey}),$.push({isSigner:!1,isWritable:!0,pubkey:I}),$.push({isSigner:!1,isWritable:!0,pubkey:Wn.publicKey}),$.push({isSigner:!1,isWritable:!1,pubkey:Le}),$.push({isSigner:!1,isWritable:!1,pubkey:Rn.publicKey}),$.push({isSigner:!1,isWritable:!1,pubkey:e});const Fe=xn(s);return Fe.methods.receiveMessage({message:o,attestation:d}).accounts({payer:w,caller:w,authorityPda:zn,messageTransmitter:K.publicKey,usedNonces:Cn,receiver:e,systemProgram:he.programId,eventAuthority:On.publicKey,program:Fe.programId}).remainingAccounts($).transaction()}class Ue{constructor(e,n,t,i){te(this,"network"),te(this,"chain"),te(this,"connection"),te(this,"contracts"),te(this,"tokenMessenger"),te(this,"messageTransmitter");var a,o;if(this.network=e,this.chain=n,this.connection=t,this.contracts=i,e==="Devnet")throw new Error("CircleBridge not supported on Devnet");const d=(a=i.cctp)==null?void 0:a.messageTransmitter;if(!d)throw new Error(`Circle Messenge Transmitter contract for domain ${n} not found`);this.messageTransmitter=Jt(new p(d),this.connection);const c=(o=i.cctp)==null?void 0:o.tokenMessenger;if(!c)throw new Error(`Circle Token Messenger contract for domain ${n} not found`);this.tokenMessenger=Ht(new p(c),this.connection)}static async fromRpc(e,n){const[t,i]=await Hn.chainFromRpc(e),a=n[i];if(a.network!==t)throw new Error(`Network mismatch: ${a.network} != ${t}`);return new Ue(t,i,e,a.contracts)}async*redeem(e,n,t){const i=new p(qe.get(this.network,this.chain)),a=new xe(e).unwrap(),o=await Xt(this.messageTransmitter.programId,this.tokenMessenger.programId,i,n,t,a),d=new ae;d.feePayer=a,d.add(o),yield this.createUnsignedTx({transaction:d},"CircleBridge.Redeem")}async*transfer(e,n,t){const i=new p(qe.get(this.network,this.chain)),a=new xe(e).unwrap(),o=jt(i,a),d=_n.get(this.network,n.chain),c=n.address.toUniversalAddress(),k=ge.generate(),I=await Zt(this.messageTransmitter.programId,this.tokenMessenger.programId,i,d,a,o,c,t,k.publicKey),w=new ae;w.feePayer=a,w.add(I),yield this.createUnsignedTx({transaction:w,signers:[k]},"CircleBridge.Transfer")}async isTransferCompleted(e){const n=Kn(e.nonce,e.sourceDomain,this.messageTransmitter.programId),t=Bn(e.nonce),{usedNonces:i}=await this.messageTransmitter.account.usedNonces.fetch(n),a=Number(e.nonce-t),o=i[Math.floor(a/64)];if(!o)throw new Error("Invalid nonce byte index");const d=a%64,c=new ve((BigInt(1)<<BigInt(d)).toString());return!o.and(c).isZero()}async parseTransactionDetails(e){const n=await this.connection.getTransaction(e);if(!n||!n.meta)throw new Error("Transaction not found");const t=n.transaction.message.getAccountKeys();if(t.length<2)throw new Error("No message account found");const i=t.get(1),a=await this.connection.getAccountInfo(i);if(!a)throw new Error("No account data found");const o=new Uint8Array(a.data).slice(44),[d,c]=rn.deserialize(o),{payload:k}=d,I=k.messageSender,w=k.mintRecipient,A=Ve(this.network,d.sourceDomain),K=Ve(this.network,d.destinationDomain),R={chain:A,address:k.burnToken};return{from:{chain:A,address:I},to:{chain:K,address:w},token:R,amount:k.amount,message:d,id:{hash:c}}}createUnsignedTx(e,n,t=!1){return new Jn(e,this.network,this.chain,n,t)}}const Gt={version:"0.1.0",name:"token_messenger_minter",instructions:[{name:"initialize",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"upgradeAuthority",isMut:!1,isSigner:!0},{name:"authorityPda",isMut:!1,isSigner:!1},{name:"tokenMessenger",isMut:!0,isSigner:!1},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"tokenMessengerMinterProgramData",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"InitializeParams"}}]},{name:"transferOwnership",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"TransferOwnershipParams"}}]},{name:"acceptOwnership",accounts:[{name:"pendingOwner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AcceptOwnershipParams"}}]},{name:"addRemoteTokenMessenger",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AddRemoteTokenMessengerParams"}}]},{name:"removeRemoteTokenMessenger",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"RemoveRemoteTokenMessengerParams"}}]},{name:"depositForBurn",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!1},{name:"burnTokenAccount",isMut:!0,isSigner:!1},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"burnTokenMint",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"DepositForBurnParams"}}],returns:"u64"},{name:"depositForBurnWithCaller",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!1},{name:"burnTokenAccount",isMut:!0,isSigner:!1},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"burnTokenMint",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"DepositForBurnWithCallerParams"}}],returns:"u64"},{name:"replaceDepositForBurn",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!1},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"tokenMessengerMinterProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"ReplaceDepositForBurnParams"}}],returns:"u64"},{name:"handleReceiveMessage",accounts:[{name:"authorityPda",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"remoteTokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"tokenPair",isMut:!1,isSigner:!1},{name:"recipientTokenAccount",isMut:!0,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"HandleReceiveMessageParams"}}]},{name:"setTokenController",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetTokenControllerParams"}}]},{name:"pause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"PauseParams"}}]},{name:"unpause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UnpauseParams"}}]},{name:"updatePauser",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"tokenMessenger",isMut:!1,isSigner:!1},{name:"tokenMinter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UpdatePauserParams"}}]},{name:"setMaxBurnAmountPerMessage",accounts:[{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetMaxBurnAmountPerMessageParams"}}]},{name:"addLocalToken",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"localTokenMint",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AddLocalTokenParams"}}]},{name:"removeLocalToken",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!0,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"RemoveLocalTokenParams"}}]},{name:"linkTokenPair",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"tokenPair",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"LinkTokenPairParams"}}]},{name:"unlinkTokenPair",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"tokenPair",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UninkTokenPairParams"}}]},{name:"burnTokenCustody",accounts:[{name:"payee",isMut:!0,isSigner:!0},{name:"tokenController",isMut:!1,isSigner:!0},{name:"tokenMinter",isMut:!1,isSigner:!1},{name:"localToken",isMut:!1,isSigner:!1},{name:"custodyTokenAccount",isMut:!0,isSigner:!1},{name:"custodyTokenMint",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"BurnTokenCustodyParams"}}]}],accounts:[{name:"tokenMessenger",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"pendingOwner",type:"publicKey"},{name:"localMessageTransmitter",type:"publicKey"},{name:"messageBodyVersion",type:"u32"},{name:"authorityBump",type:"u8"}]}},{name:"remoteTokenMessenger",type:{kind:"struct",fields:[{name:"domain",type:"u32"},{name:"tokenMessenger",type:"publicKey"}]}},{name:"tokenMinter",type:{kind:"struct",fields:[{name:"tokenController",type:"publicKey"},{name:"pauser",type:"publicKey"},{name:"paused",type:"bool"},{name:"bump",type:"u8"}]}},{name:"tokenPair",type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"remoteToken",type:"publicKey"},{name:"localToken",type:"publicKey"},{name:"bump",type:"u8"}]}},{name:"localToken",type:{kind:"struct",fields:[{name:"custody",type:"publicKey"},{name:"mint",type:"publicKey"},{name:"burnLimitPerMessage",type:"u64"},{name:"messagesSent",type:"u64"},{name:"messagesReceived",type:"u64"},{name:"amountSent",type:"u128"},{name:"amountReceived",type:"u128"},{name:"bump",type:"u8"},{name:"custodyBump",type:"u8"}]}}],types:[{name:"AcceptOwnershipParams",type:{kind:"struct",fields:[]}},{name:"AddRemoteTokenMessengerParams",type:{kind:"struct",fields:[{name:"domain",type:"u32"},{name:"tokenMessenger",type:"publicKey"}]}},{name:"DepositForBurnWithCallerParams",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"destinationDomain",type:"u32"},{name:"mintRecipient",type:"publicKey"},{name:"destinationCaller",type:"publicKey"}]}},{name:"DepositForBurnParams",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"destinationDomain",type:"u32"},{name:"mintRecipient",type:"publicKey"}]}},{name:"HandleReceiveMessageParams",type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"sender",type:"publicKey"},{name:"messageBody",type:"bytes"},{name:"authorityBump",type:"u8"}]}},{name:"InitializeParams",type:{kind:"struct",fields:[{name:"tokenController",type:"publicKey"},{name:"localMessageTransmitter",type:"publicKey"},{name:"messageBodyVersion",type:"u32"}]}},{name:"RemoveRemoteTokenMessengerParams",type:{kind:"struct",fields:[]}},{name:"ReplaceDepositForBurnParams",type:{kind:"struct",fields:[{name:"originalMessage",type:"bytes"},{name:"originalAttestation",type:"bytes"},{name:"newDestinationCaller",type:"publicKey"},{name:"newMintRecipient",type:"publicKey"}]}},{name:"TransferOwnershipParams",type:{kind:"struct",fields:[{name:"newOwner",type:"publicKey"}]}},{name:"AddLocalTokenParams",type:{kind:"struct",fields:[]}},{name:"BurnTokenCustodyParams",type:{kind:"struct",fields:[{name:"amount",type:"u64"}]}},{name:"LinkTokenPairParams",type:{kind:"struct",fields:[{name:"localToken",type:"publicKey"},{name:"remoteDomain",type:"u32"},{name:"remoteToken",type:"publicKey"}]}},{name:"PauseParams",type:{kind:"struct",fields:[]}},{name:"RemoveLocalTokenParams",type:{kind:"struct",fields:[]}},{name:"SetMaxBurnAmountPerMessageParams",type:{kind:"struct",fields:[{name:"burnLimitPerMessage",type:"u64"}]}},{name:"SetTokenControllerParams",type:{kind:"struct",fields:[{name:"tokenController",type:"publicKey"}]}},{name:"UninkTokenPairParams",type:{kind:"struct",fields:[]}},{name:"UnpauseParams",type:{kind:"struct",fields:[]}},{name:"UpdatePauserParams",type:{kind:"struct",fields:[{name:"newPauser",type:"publicKey"}]}},{name:"TokenMinterError",type:{kind:"enum",variants:[{name:"InvalidAuthority"},{name:"InvalidTokenMinterState"},{name:"ProgramPaused"},{name:"InvalidTokenPairState"},{name:"InvalidLocalTokenState"},{name:"InvalidPauser"},{name:"InvalidTokenController"},{name:"BurnAmountExceeded"},{name:"InvalidAmount"}]}}],events:[{name:"OwnershipTransferStarted",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"OwnershipTransferred",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"DepositForBurn",fields:[{name:"nonce",type:"u64",index:!1},{name:"burnToken",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1},{name:"depositor",type:"publicKey",index:!1},{name:"mintRecipient",type:"publicKey",index:!1},{name:"destinationDomain",type:"u32",index:!1},{name:"destinationTokenMessenger",type:"publicKey",index:!1},{name:"destinationCaller",type:"publicKey",index:!1}]},{name:"MintAndWithdraw",fields:[{name:"mintRecipient",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1},{name:"mintToken",type:"publicKey",index:!1}]},{name:"RemoteTokenMessengerAdded",fields:[{name:"domain",type:"u32",index:!1},{name:"tokenMessenger",type:"publicKey",index:!1}]},{name:"RemoteTokenMessengerRemoved",fields:[{name:"domain",type:"u32",index:!1},{name:"tokenMessenger",type:"publicKey",index:!1}]},{name:"SetTokenController",fields:[{name:"tokenController",type:"publicKey",index:!1}]},{name:"PauserChanged",fields:[{name:"newAddress",type:"publicKey",index:!1}]},{name:"SetBurnLimitPerMessage",fields:[{name:"token",type:"publicKey",index:!1},{name:"burnLimitPerMessage",type:"u64",index:!1}]},{name:"LocalTokenAdded",fields:[{name:"custody",type:"publicKey",index:!1},{name:"mint",type:"publicKey",index:!1}]},{name:"LocalTokenRemoved",fields:[{name:"custody",type:"publicKey",index:!1},{name:"mint",type:"publicKey",index:!1}]},{name:"TokenPairLinked",fields:[{name:"localToken",type:"publicKey",index:!1},{name:"remoteDomain",type:"u32",index:!1},{name:"remoteToken",type:"publicKey",index:!1}]},{name:"TokenPairUnlinked",fields:[{name:"localToken",type:"publicKey",index:!1},{name:"remoteDomain",type:"u32",index:!1},{name:"remoteToken",type:"publicKey",index:!1}]},{name:"Pause",fields:[]},{name:"Unpause",fields:[]},{name:"TokenCustodyBurned",fields:[{name:"custodyTokenAccount",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]}],errors:[{code:6e3,name:"InvalidAuthority",msg:"Invalid authority"},{code:6001,name:"InvalidTokenMessengerState",msg:"Invalid token messenger state"},{code:6002,name:"InvalidTokenMessenger",msg:"Invalid token messenger"},{code:6003,name:"InvalidOwner",msg:"Invalid owner"},{code:6004,name:"MalformedMessage",msg:"Malformed message"},{code:6005,name:"InvalidMessageBodyVersion",msg:"Invalid message body version"},{code:6006,name:"InvalidAmount",msg:"Invalid amount"},{code:6007,name:"InvalidDestinationDomain",msg:"Invalid destination domain"},{code:6008,name:"InvalidDestinationCaller",msg:"Invalid destination caller"},{code:6009,name:"InvalidMintRecipient",msg:"Invalid mint recipient"},{code:6010,name:"InvalidSender",msg:"Invalid sender"},{code:6011,name:"InvalidTokenPair",msg:"Invalid token pair"},{code:6012,name:"InvalidTokenMint",msg:"Invalid token mint"}]},Qt={version:"0.1.0",name:"message_transmitter",instructions:[{name:"initialize",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"upgradeAuthority",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageTransmitterProgramData",isMut:!1,isSigner:!1},{name:"messageTransmitterProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"InitializeParams"}}]},{name:"transferOwnership",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"TransferOwnershipParams"}}]},{name:"acceptOwnership",accounts:[{name:"pendingOwner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"AcceptOwnershipParams"}}]},{name:"updatePauser",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UpdatePauserParams"}}]},{name:"updateAttesterManager",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UpdateAttesterManagerParams"}}]},{name:"pause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"PauseParams"}}]},{name:"unpause",accounts:[{name:"pauser",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"UnpauseParams"}}]},{name:"setMaxMessageBodySize",accounts:[{name:"owner",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetMaxMessageBodySizeParams"}}]},{name:"enableAttester",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"attesterManager",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"EnableAttesterParams"}}]},{name:"disableAttester",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"attesterManager",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"DisableAttesterParams"}}]},{name:"setSignatureThreshold",accounts:[{name:"attesterManager",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SetSignatureThresholdParams"}}]},{name:"sendMessage",accounts:[{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"senderProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SendMessageParams"}}],returns:"u64"},{name:"sendMessageWithCaller",accounts:[{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"senderProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"SendMessageWithCallerParams"}}],returns:"u64"},{name:"replaceMessage",accounts:[{name:"eventRentPayer",isMut:!0,isSigner:!0},{name:"senderAuthorityPda",isMut:!1,isSigner:!0},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!0},{name:"senderProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"ReplaceMessageParams"}}],returns:"u64"},{name:"receiveMessage",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"caller",isMut:!1,isSigner:!0},{name:"authorityPda",isMut:!1,isSigner:!1},{name:"messageTransmitter",isMut:!1,isSigner:!1},{name:"usedNonces",isMut:!0,isSigner:!1},{name:"receiver",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"eventAuthority",isMut:!1,isSigner:!1},{name:"program",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"ReceiveMessageParams"}}]},{name:"reclaimEventAccount",accounts:[{name:"payee",isMut:!0,isSigner:!0,docs:["rent SOL receiver, should match original rent payer"]},{name:"messageTransmitter",isMut:!0,isSigner:!1},{name:"messageSentEventData",isMut:!0,isSigner:!1}],args:[{name:"params",type:{defined:"ReclaimEventAccountParams"}}]},{name:"getNoncePda",accounts:[{name:"messageTransmitter",isMut:!1,isSigner:!1}],args:[{name:"params",type:{defined:"GetNoncePDAParams"}}],returns:"publicKey"},{name:"isNonceUsed",accounts:[{name:"usedNonces",isMut:!1,isSigner:!1,docs:["Account will be explicitly loaded to avoid error when it's not initialized"]}],args:[{name:"params",type:{defined:"IsNonceUsedParams"}}],returns:"bool"}],accounts:[{name:"messageSent",type:{kind:"struct",fields:[{name:"rentPayer",type:"publicKey"},{name:"message",type:"bytes"}]}},{name:"messageTransmitter",docs:["Main state of the MessageTransmitter program"],type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"pendingOwner",type:"publicKey"},{name:"attesterManager",type:"publicKey"},{name:"pauser",type:"publicKey"},{name:"paused",type:"bool"},{name:"localDomain",type:"u32"},{name:"version",type:"u32"},{name:"signatureThreshold",type:"u32"},{name:"enabledAttesters",type:{vec:"publicKey"}},{name:"maxMessageBodySize",type:"u64"},{name:"nextAvailableNonce",type:"u64"}]}},{name:"usedNonces",docs:["UsedNonces account holds an array of bits that indicate which nonces were already used","so they can't be resused to receive new messages. Array starts with the first_nonce and","holds flags for UsedNonces::MAX_NONCES. Nonces are recorded separately for each remote_domain."],type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"firstNonce",type:"u64"},{name:"usedNonces",type:{array:["u64",100]}}]}}],types:[{name:"AcceptOwnershipParams",type:{kind:"struct",fields:[]}},{name:"DisableAttesterParams",type:{kind:"struct",fields:[{name:"attester",type:"publicKey"}]}},{name:"EnableAttesterParams",type:{kind:"struct",fields:[{name:"newAttester",type:"publicKey"}]}},{name:"GetNoncePDAParams",type:{kind:"struct",fields:[{name:"nonce",type:"u64"},{name:"sourceDomain",type:"u32"}]}},{name:"InitializeParams",type:{kind:"struct",fields:[{name:"localDomain",type:"u32"},{name:"attester",type:"publicKey"},{name:"maxMessageBodySize",type:"u64"},{name:"version",type:"u32"}]}},{name:"IsNonceUsedParams",type:{kind:"struct",fields:[{name:"nonce",type:"u64"}]}},{name:"PauseParams",type:{kind:"struct",fields:[]}},{name:"ReceiveMessageParams",type:{kind:"struct",fields:[{name:"message",type:"bytes"},{name:"attestation",type:"bytes"}]}},{name:"HandleReceiveMessageParams",type:{kind:"struct",fields:[{name:"remoteDomain",type:"u32"},{name:"sender",type:"publicKey"},{name:"messageBody",type:"bytes"},{name:"authorityBump",type:"u8"}]}},{name:"ReclaimEventAccountParams",type:{kind:"struct",fields:[{name:"attestation",type:"bytes"}]}},{name:"ReplaceMessageParams",type:{kind:"struct",fields:[{name:"originalMessage",type:"bytes"},{name:"originalAttestation",type:"bytes"},{name:"newMessageBody",type:"bytes"},{name:"newDestinationCaller",type:"publicKey"}]}},{name:"SendMessageWithCallerParams",type:{kind:"struct",fields:[{name:"destinationDomain",type:"u32"},{name:"recipient",type:"publicKey"},{name:"messageBody",type:"bytes"},{name:"destinationCaller",type:"publicKey"}]}},{name:"SendMessageParams",type:{kind:"struct",fields:[{name:"destinationDomain",type:"u32"},{name:"recipient",type:"publicKey"},{name:"messageBody",type:"bytes"}]}},{name:"SetMaxMessageBodySizeParams",type:{kind:"struct",fields:[{name:"newMaxMessageBodySize",type:"u64"}]}},{name:"SetSignatureThresholdParams",type:{kind:"struct",fields:[{name:"newSignatureThreshold",type:"u32"}]}},{name:"TransferOwnershipParams",type:{kind:"struct",fields:[{name:"newOwner",type:"publicKey"}]}},{name:"UnpauseParams",type:{kind:"struct",fields:[]}},{name:"UpdateAttesterManagerParams",type:{kind:"struct",fields:[{name:"newAttesterManager",type:"publicKey"}]}},{name:"UpdatePauserParams",type:{kind:"struct",fields:[{name:"newPauser",type:"publicKey"}]}},{name:"MathError",type:{kind:"enum",variants:[{name:"MathOverflow"},{name:"MathUnderflow"},{name:"ErrorInDivision"}]}}],events:[{name:"OwnershipTransferStarted",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"OwnershipTransferred",fields:[{name:"previousOwner",type:"publicKey",index:!1},{name:"newOwner",type:"publicKey",index:!1}]},{name:"PauserChanged",fields:[{name:"newAddress",type:"publicKey",index:!1}]},{name:"AttesterManagerUpdated",fields:[{name:"previousAttesterManager",type:"publicKey",index:!1},{name:"newAttesterManager",type:"publicKey",index:!1}]},{name:"MessageReceived",fields:[{name:"caller",type:"publicKey",index:!1},{name:"sourceDomain",type:"u32",index:!1},{name:"nonce",type:"u64",index:!1},{name:"sender",type:"publicKey",index:!1},{name:"messageBody",type:"bytes",index:!1}]},{name:"SignatureThresholdUpdated",fields:[{name:"oldSignatureThreshold",type:"u32",index:!1},{name:"newSignatureThreshold",type:"u32",index:!1}]},{name:"AttesterEnabled",fields:[{name:"attester",type:"publicKey",index:!1}]},{name:"AttesterDisabled",fields:[{name:"attester",type:"publicKey",index:!1}]},{name:"MaxMessageBodySizeUpdated",fields:[{name:"newMaxMessageBodySize",type:"u64",index:!1}]},{name:"Pause",fields:[]},{name:"Unpause",fields:[]}],errors:[{code:6e3,name:"InvalidAuthority",msg:"Invalid authority"},{code:6001,name:"ProgramPaused",msg:"Instruction is not allowed at this time"},{code:6002,name:"InvalidMessageTransmitterState",msg:"Invalid message transmitter state"},{code:6003,name:"InvalidSignatureThreshold",msg:"Invalid signature threshold"},{code:6004,name:"SignatureThresholdAlreadySet",msg:"Signature threshold already set"},{code:6005,name:"InvalidOwner",msg:"Invalid owner"},{code:6006,name:"InvalidPauser",msg:"Invalid pauser"},{code:6007,name:"InvalidAttesterManager",msg:"Invalid attester manager"},{code:6008,name:"InvalidAttester",msg:"Invalid attester"},{code:6009,name:"AttesterAlreadyEnabled",msg:"Attester already enabled"},{code:6010,name:"TooFewEnabledAttesters",msg:"Too few enabled attesters"},{code:6011,name:"SignatureThresholdTooLow",msg:"Signature threshold is too low"},{code:6012,name:"AttesterAlreadyDisabled",msg:"Attester already disabled"},{code:6013,name:"MessageBodyLimitExceeded",msg:"Message body exceeds max size"},{code:6014,name:"InvalidDestinationCaller",msg:"Invalid destination caller"},{code:6015,name:"InvalidRecipient",msg:"Invalid message recipient"},{code:6016,name:"SenderNotPermitted",msg:"Sender is not permitted"},{code:6017,name:"InvalidSourceDomain",msg:"Invalid source domain"},{code:6018,name:"InvalidDestinationDomain",msg:"Invalid destination domain"},{code:6019,name:"InvalidMessageVersion",msg:"Invalid message version"},{code:6020,name:"InvalidUsedNoncesAccount",msg:"Invalid used nonces account"},{code:6021,name:"InvalidRecipientProgram",msg:"Invalid recipient program"},{code:6022,name:"InvalidNonce",msg:"Invalid nonce"},{code:6023,name:"NonceAlreadyUsed",msg:"Nonce already used"},{code:6024,name:"MessageTooShort",msg:"Message is too short"},{code:6025,name:"MalformedMessage",msg:"Malformed message"},{code:6026,name:"InvalidSignatureOrderOrDupe",msg:"Invalid signature order or dupe"},{code:6027,name:"InvalidAttesterSignature",msg:"Invalid attester signature"},{code:6028,name:"InvalidAttestationLength",msg:"Invalid attestation length"},{code:6029,name:"InvalidSignatureRecoveryId",msg:"Invalid signature recovery ID"},{code:6030,name:"InvalidSignatureSValue",msg:"Invalid signature S value"},{code:6031,name:"InvalidMessageHash",msg:"Invalid message hash"}]};jn(Zn,"CircleBridge",Ue);const En={TokenMessengerIdl:Gt,MessageTransmitterIdl:Qt};export{Ue as SolanaCircleBridge,En as idl};
