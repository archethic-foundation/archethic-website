import{q as x,aW as ne,aX as A,aY as _,aZ as le,a_ as U,a$ as se,b0 as ze,b1 as pe,b2 as jt,b3 as Y,d as $,s as kr,z as Hn,bz as Ge,c3 as jn,al as re,aU as bt,aV as wr,ci as Sr,cj as Gn,ck as Ir,cl as Jn,b4 as Je,b5 as Yn,b6 as Xn,b7 as Zn,b8 as Qn,b9 as $r,bW as vr,cm as es,o as ts,ba as rs,bb as ns,bc as ss,bd as is}from"./index-Bibw8odz.js";import{r as os}from"./index-DpFNxVts-CtfGCFjC.js";import{P as He,S as as,a as mt,b as cs,_ as us}from"./solana-DZGZ-AWd-QVqBWA_N.js";import{T as ds}from"./create-D7FD56l0-D2uTFRvt.js";import{b as ls}from"./chain-DfK5JtF7-Jmo_aVnV.js";var hs=Object.defineProperty,gs=(i,e,t)=>e in i?hs(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,q=(i,e,t)=>(gs(i,typeof e!="symbol"?e+"":e,t),t);function Ee(i,e){return He.findProgramAddressSync(i,new He(e))[0]}function ma(i,e){return{pubkey:new He(i),isWritable:!0,isSigner:e}}function ya(i,e){return{pubkey:new He(i),isWritable:!1,isSigner:e}}function ut(i){if(i===null)throw Error("account info is null");return i.data}class Gt{}q(Gt,"programId",new He("BPFLoaderUpgradeab1e11111111111111111111111"));function ps(i){return Ee([new He(i).toBuffer()],Gt.programId)}class ms extends Error{constructor(e){super(e),this.name="IdlError"}}function Dr(i,e){switch(e.type.kind){case"struct":return e.type.fields.map(t=>Le(i,t.type)).reduce((t,r)=>t+r,0);case"enum":{const t=e.type.variants.map(r=>r.fields?r.fields.map(n=>typeof n=="object"&&"name"in n?Le(i,n.type):Le(i,n)).reduce((n,s)=>n+s,0):0);return Math.max(...t)+1}case"alias":return Le(i,e.type.value)}}function Le(i,e){var t;switch(e){case"bool":return 1;case"u8":return 1;case"i8":return 1;case"i16":return 2;case"u16":return 2;case"u32":return 4;case"i32":return 4;case"f32":return 4;case"u64":return 8;case"i64":return 8;case"f64":return 8;case"u128":return 16;case"i128":return 16;case"u256":return 32;case"i256":return 32;case"bytes":return 1;case"string":return 1;case"publicKey":return 32;default:if("vec"in e)return 1;if("option"in e)return 1+Le(i,e.option);if("coption"in e)return 4+Le(i,e.coption);if("defined"in e){const r=((t=i.types)==null?void 0:t.filter(s=>s.name===e.defined))??[];if(r.length!==1)throw new ms(`Type not found: ${JSON.stringify(e)}`);let n=r[0];return Dr(i,n)}if("array"in e){let r=e.array[0],n=e.array[1];return Le(i,r)*n}throw new Error(`Invalid type ${JSON.stringify(e)}`)}}function tt(i){return i.replace(/(?:^\w|[A-Z]|\b\w)/g,function(e,t){return t===0?e.toLowerCase():e.toUpperCase()}).replace(/[\s\-_]+/g,"")}function ys(i){return i.charAt(0).toUpperCase()+i.slice(1)}class fs extends TypeError{constructor(e,t){let r;const{message:n,...s}=e,{path:o}=e,a=o.length===0?n:"At path: "+o.join(".")+" -- "+n;super(a),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>{var c;return(c=r)!=null?c:r=[e,...t()]}}}function bs(i){return Be(i)&&typeof i[Symbol.iterator]=="function"}function Be(i){return typeof i=="object"&&i!=null}function me(i){return typeof i=="string"?JSON.stringify(i):""+i}function ks(i){const{done:e,value:t}=i.next();return e?void 0:t}function ws(i,e,t,r){if(i===!0)return;i===!1?i={}:typeof i=="string"&&(i={message:i});const{path:n,branch:s}=e,{type:o}=t,{refinement:a,message:c="Expected a value of type `"+o+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+me(r)+"`"}=i;return{value:r,type:o,refinement:a,key:n[n.length-1],path:n,branch:s,...i,message:c}}function*Ar(i,e,t,r){bs(i)||(i=[i]);for(const n of i){const s=ws(n,e,t,r);s&&(yield s)}}function*Jt(i,e,t={}){const{path:r=[],branch:n=[i],coerce:s=!1,mask:o=!1}=t,a={path:r,branch:n};if(s&&(i=e.coercer(i,a),o&&e.type!=="type"&&Be(e.schema)&&Be(i)&&!Array.isArray(i)))for(const d in i)e.schema[d]===void 0&&delete i[d];let c=!0;for(const d of e.validator(i,a))c=!1,yield[d,void 0];for(let[d,p,m]of e.entries(i,a)){const y=Jt(p,m,{path:d===void 0?r:[...r,d],branch:d===void 0?n:[...n,p],coerce:s,mask:o});for(const l of y)l[0]?(c=!1,yield[l[0],void 0]):s&&(p=l[1],d===void 0?i=p:i instanceof Map?i.set(d,p):i instanceof Set?i.add(p):Be(i)&&(i[d]=p))}if(c)for(const d of e.refiner(i,a))c=!1,yield[d,void 0];c&&(yield[void 0,i])}let Ie=class{constructor(i){const{type:e,schema:t,validator:r,refiner:n,coercer:s=a=>a,entries:o=function*(){}}=i;this.type=e,this.schema=t,this.entries=o,this.coercer=s,r?this.validator=(a,c)=>{const d=r(a,c);return Ar(d,c,this,a)}:this.validator=()=>[],n?this.refiner=(a,c)=>{const d=n(a,c);return Ar(d,c,this,a)}:this.refiner=()=>[]}assert(i){return Fr(i,this)}create(i){return k(i,this)}is(i){return Hr(i,this)}mask(i){return Ss(i,this)}validate(i,e={}){return dt(i,this,e)}};function Fr(i,e){const t=dt(i,e);if(t[0])throw t[0]}function k(i,e){const t=dt(i,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function Ss(i,e){const t=dt(i,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function Hr(i,e){return!dt(i,e)[0]}function dt(i,e,t={}){const r=Jt(i,e,t),n=ks(r);return n[0]?[new fs(n[0],function*(){for(const s of r)s[0]&&(yield s[0])}),void 0]:[void 0,n[1]]}function Me(i,e){return new Ie({type:i,schema:null,validator:e})}function Is(){return Me("any",()=>!0)}function S(i){return new Ie({type:"array",schema:i,*entries(e){if(i&&Array.isArray(e))for(const[t,r]of e.entries())yield[t,r,i]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+me(e)}})}function Se(){return Me("boolean",i=>typeof i=="boolean")}function Yt(i){return Me("instance",e=>e instanceof i||"Expected a `"+i.name+"` instance, but received: "+me(e))}function X(i){const e=me(i),t=typeof i;return new Ie({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?i:null,validator(r){return r===i||"Expected the literal `"+e+"`, but received: "+me(r)}})}function vs(){return Me("never",()=>!1)}function w(i){return new Ie({...i,validator:(e,t)=>e===null||i.validator(e,t),refiner:(e,t)=>e===null||i.refiner(e,t)})}function u(){return Me("number",i=>typeof i=="number"&&!isNaN(i)||"Expected a number, but received: "+me(i))}function T(i){return new Ie({...i,validator:(e,t)=>e===void 0||i.validator(e,t),refiner:(e,t)=>e===void 0||i.refiner(e,t)})}function jr(i,e){return new Ie({type:"record",schema:null,*entries(t){if(Be(t))for(const r in t){const n=t[r];yield[r,r,i],yield[r,n,e]}},validator(t){return Be(t)||"Expected an object, but received: "+me(t)}})}function b(){return Me("string",i=>typeof i=="string"||"Expected a string, but received: "+me(i))}function Xt(i){const e=vs();return new Ie({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(i.length,t.length);for(let n=0;n<r;n++)yield[n,t[n],i[n]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+me(t)}})}function g(i){const e=Object.keys(i);return new Ie({type:"type",schema:i,*entries(t){if(Be(t))for(const r of e)yield[r,t[r],i[r]]},validator(t){return Be(t)||"Expected an object, but received: "+me(t)}})}function ce(i){const e=i.map(t=>t.type).join(" | ");return new Ie({type:"union",schema:null,validator(t,r){const n=[];for(const s of i){const[...o]=Jt(t,s,r),[a]=o;if(a[0])for(const[c]of o)c&&n.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+me(t),...n]}})}function lt(){return Me("unknown",()=>!0)}function ht(i,e,t){return new Ie({...i,coercer:(r,n)=>Hr(r,e)?i.coercer(t(r,n),n):i.coercer(r,n)})}const As=Je.utils.randomPrivateKey,_r=()=>{const i=Je.utils.randomPrivateKey(),e=kt(i),t=new Uint8Array(64);return t.set(i),t.set(e,32),{publicKey:e,secretKey:t}},kt=Je.getPublicKey;function Pr(i){try{return Je.ExtendedPoint.fromHex(i),!0}catch{return!1}}const Zt=(i,e)=>Je.sign(i,e.slice(0,32)),_s=Je.verify,K=i=>x.Buffer.isBuffer(i)?i:i instanceof Uint8Array?x.Buffer.from(i.buffer,i.byteOffset,i.byteLength):x.Buffer.from(i);class Qt{constructor(e){Object.assign(this,e)}encode(){return x.Buffer.from(Yn(nt,this))}static decode(e){return Xn(nt,this,e)}static decodeUnchecked(e){return Zn(nt,this,e)}}class Ps extends Qt{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const nt=new Map;var Gr;let Jr;const Yr=32,we=32;function Es(i){return i._bn!==void 0}let Er=1;Jr=Symbol.toStringTag;class h extends Qt{constructor(e){if(super({}),this._bn=void 0,Es(e))this._bn=e._bn;else{if(typeof e=="string"){const t=re.decode(e);if(t.length!=we)throw new Error("Invalid public key input");this._bn=new bt(t)}else this._bn=new bt(e);if(this._bn.byteLength()>we)throw new Error("Invalid public key input")}}static unique(){const e=new h(Er);return Er+=1,new h(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return re.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(x.Buffer);if(e.length===we)return e;const t=x.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Jr](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const n=x.Buffer.concat([e.toBuffer(),x.Buffer.from(t),r.toBuffer()]),s=wr(n);return new h(s)}static createProgramAddressSync(e,t){let r=x.Buffer.alloc(0);e.forEach(function(s){if(s.length>Yr)throw new TypeError("Max seed length exceeded");r=x.Buffer.concat([r,K(s)])}),r=x.Buffer.concat([r,t.toBuffer(),x.Buffer.from("ProgramDerivedAddress")]);const n=wr(r);if(Pr(n))throw new Error("Invalid seeds, address must fall off the curve");return new h(n)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r=255,n;for(;r!=0;){try{const s=e.concat(x.Buffer.from([r]));n=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;r--;continue}return[n,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new h(e);return Pr(t.toBytes())}}Gr=h;h.default=new Gr("11111111111111111111111111111111");nt.set(h,{kind:"struct",fields:[["_bn","u256"]]});class Bs{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=K(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=K(As()),this._publicKey=K(kt(this._secretKey))}get publicKey(){return new h(this._publicKey)}get secretKey(){return x.Buffer.concat([this._secretKey,this._publicKey],64)}}const xs=new h("BPFLoader1111111111111111111111111111111111"),xe=1232,It=127,it=64;class er extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(er.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class tr extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(tr.prototype,"name",{value:"TransactionExpiredTimeoutError"});class De extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(De.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class ot{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const t=new Map;this.keySegments().flat().forEach((n,s)=>{t.set(n.toBase58(),s)});const r=n=>{const s=t.get(n.toBase58());if(s===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return s};return e.map(n=>({programIdIndex:r(n.programId),accountKeyIndexes:n.keys.map(s=>r(s.pubkey)),data:n.data}))}}const W=(i="publicKey")=>Y(32,i),Ts=(i="signature")=>Y(64,i),Re=(i="string")=>{const e=A([_("length"),_("lengthPadding"),Y(ze(_(),-8),"chars")],i),t=e.decode.bind(e),r=e.encode.bind(e),n=e;return n.decode=(s,o)=>t(s,o).chars.toString(),n.encode=(s,o,a)=>{const c={chars:x.Buffer.from(s,"utf8")};return r(c,o,a)},n.alloc=s=>_().span+_().span+x.Buffer.from(s,"utf8").length,n},Cs=(i="authorized")=>A([W("staker"),W("withdrawer")],i),Ls=(i="lockup")=>A([le("unixTimestamp"),le("epoch"),W("custodian")],i),Rs=(i="voteInit")=>A([W("nodePubkey"),W("authorizedVoter"),W("authorizedWithdrawer"),U("commission")],i),zs=(i="voteAuthorizeWithSeedArgs")=>A([_("voteAuthorizationType"),W("currentAuthorityDerivedKeyOwnerPubkey"),Re("currentAuthorityDerivedKeySeed"),W("newAuthorized")],i);function Xr(i,e){const t=n=>{if(n.span>=0)return n.span;if(typeof n.alloc=="function")return n.alloc(e[n.property]);if("count"in n&&"elementLayout"in n){const s=e[n.property];if(Array.isArray(s))return s.length*t(n.elementLayout)}else if("fields"in n)return Xr({layout:n},e[n.property]);return 0};let r=0;return i.layout.fields.forEach(n=>{r+=t(n)}),r}function ie(i){let e=0,t=0;for(;;){let r=i.shift();if(e|=(r&127)<<t*7,t+=1,!(r&128))break}return e}function ue(i,e){let t=e;for(;;){let r=t&127;if(t>>=7,t==0){i.push(r);break}else r|=128,i.push(r)}}function M(i,e){if(!i)throw new Error(e||"Assertion failed")}class vt{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=o=>{const a=o.toBase58();let c=r.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(a,c)),c},s=n(t);s.isSigner=!0,s.isWritable=!0;for(const o of e){n(o.programId).isInvoked=!0;for(const a of o.keys){const c=n(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new vt(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];M(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),n=e.filter(([,c])=>!c.isSigner&&c.isWritable),s=e.filter(([,c])=>!c.isSigner&&!c.isWritable),o={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:s.length};{M(t.length>0,"Expected at least one writable signer key");const[c]=t[0];M(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new h(c)),...r.map(([c])=>new h(c)),...n.map(([c])=>new h(c)),...s.map(([c])=>new h(c))];return[o,a]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[n,s]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(t.length===0&&n.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:s}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[s,o]of this.keyMetaMap.entries())if(t(o)){const a=new h(s),c=e.findIndex(d=>d.equals(a));c>=0&&(M(c<256,"Max lookup table index exceeded"),r.push(c),n.push(a),this.keyMetaMap.delete(s))}return[r,n]}}const Zr="Reached end of buffer unexpectedly";function fe(i){if(i.length===0)throw new Error(Zr);return i.shift()}function oe(i,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>i.length:t>=i.length)throw new Error(Zr);return i.splice(...e)}class ye{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new h(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:re.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new ot(this.staticAccountKeys)}static compile(e){const t=vt.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),s=new ot(n).compileInstructions(e.instructions).map(o=>({programIdIndex:o.programIdIndex,accounts:o.accountKeyIndexes,data:re.encode(o.data)}));return new ye({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:s})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,n=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<n}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];ue(t,e);const r=this.instructions.map(m=>{const{accounts:y,programIdIndex:l}=m,I=Array.from(re.decode(m.data));let f=[];ue(f,y.length);let B=[];return ue(B,I.length),{programIdIndex:l,keyIndicesCount:x.Buffer.from(f),keyIndices:y,dataLength:x.Buffer.from(B),data:I}});let n=[];ue(n,r.length);let s=x.Buffer.alloc(xe);x.Buffer.from(n).copy(s);let o=n.length;r.forEach(m=>{const y=A([U("programIdIndex"),Y(m.keyIndicesCount.length,"keyIndicesCount"),se(U("keyIndex"),m.keyIndices.length,"keyIndices"),Y(m.dataLength.length,"dataLength"),se(U("userdatum"),m.data.length,"data")]).encode(m,s,o);o+=y}),s=s.slice(0,o);const a=A([Y(1,"numRequiredSignatures"),Y(1,"numReadonlySignedAccounts"),Y(1,"numReadonlyUnsignedAccounts"),Y(t.length,"keyCount"),se(W("key"),e,"keys"),W("recentBlockhash")]),c={numRequiredSignatures:x.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:x.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:x.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:x.Buffer.from(t),keys:this.accountKeys.map(m=>K(m.toBytes())),recentBlockhash:re.decode(this.recentBlockhash)};let d=x.Buffer.alloc(2048);const p=a.encode(c,d);return s.copy(d,p),d.slice(0,p+s.length)}static from(e){let t=[...e];const r=fe(t);if(r!==(r&It))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const n=fe(t),s=fe(t),o=ie(t);let a=[];for(let y=0;y<o;y++){const l=oe(t,0,we);a.push(new h(x.Buffer.from(l)))}const c=oe(t,0,we),d=ie(t);let p=[];for(let y=0;y<d;y++){const l=fe(t),I=ie(t),f=oe(t,0,I),B=ie(t),R=oe(t,0,B),D=re.encode(x.Buffer.from(R));p.push({programIdIndex:l,accounts:f,data:D})}const m={header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:s},recentBlockhash:re.encode(x.Buffer.from(c)),accountKeys:a,instructions:p};return new ye(m)}}class We{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new ot(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const n=e-r,s=this.addressTableLookups.reduce((o,a)=>o+a.writableIndexes.length,0);return n<s}else if(e>=this.header.numRequiredSignatures){const n=e-t,s=r-t-this.header.numReadonlyUnsignedAccounts;return n<s}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find(s=>s.key.equals(r.accountKey));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const s of r.writableIndexes)if(s<n.state.addresses.length)t.writable.push(n.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`);for(const s of r.readonlyIndexes)if(s<n.state.addresses.length)t.readonly.push(n.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){const t=vt.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},s=e.addressLookupTableAccounts||[];for(const d of s){const p=t.extractTableLookup(d);if(p!==void 0){const[m,{writable:y,readonly:l}]=p;r.push(m),n.writable.push(...y),n.readonly.push(...l)}}const[o,a]=t.getMessageComponents(),c=new ot(a,n).compileInstructions(e.instructions);return new We({header:o,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:c,addressTableLookups:r})}serialize(){const e=Array();ue(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();ue(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),s=Array();ue(s,this.addressTableLookups.length);const o=A([U("prefix"),A([U("numRequiredSignatures"),U("numReadonlySignedAccounts"),U("numReadonlyUnsignedAccounts")],"header"),Y(e.length,"staticAccountKeysLength"),se(W(),this.staticAccountKeys.length,"staticAccountKeys"),W("recentBlockhash"),Y(r.length,"instructionsLength"),Y(t.length,"serializedInstructions"),Y(s.length,"addressTableLookupsLength"),Y(n.length,"serializedAddressTableLookups")]),a=new Uint8Array(xe),c=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(d=>d.toBytes()),recentBlockhash:re.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:n},a);return a.slice(0,c)}serializeInstructions(){let e=0;const t=new Uint8Array(xe);for(const r of this.compiledInstructions){const n=Array();ue(n,r.accountKeyIndexes.length);const s=Array();ue(s,r.data.length);const o=A([U("programIdIndex"),Y(n.length,"encodedAccountKeyIndexesLength"),se(U(),r.accountKeyIndexes.length,"accountKeyIndexes"),Y(s.length,"encodedDataLength"),Y(r.data.length,"data")]);e+=o.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(xe);for(const r of this.addressTableLookups){const n=Array();ue(n,r.writableIndexes.length);const s=Array();ue(s,r.readonlyIndexes.length);const o=A([W("accountKey"),Y(n.length,"encodedWritableIndexesLength"),se(U(),r.writableIndexes.length,"writableIndexes"),Y(s.length,"encodedReadonlyIndexesLength"),se(U(),r.readonlyIndexes.length,"readonlyIndexes")]);e+=o.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=fe(t),n=r&It;M(r!==n,"Expected versioned message but received legacy message");const s=n;M(s===0,`Expected versioned message with version 0 but found version ${s}`);const o={numRequiredSignatures:fe(t),numReadonlySignedAccounts:fe(t),numReadonlyUnsignedAccounts:fe(t)},a=[],c=ie(t);for(let I=0;I<c;I++)a.push(new h(oe(t,0,we)));const d=re.encode(oe(t,0,we)),p=ie(t),m=[];for(let I=0;I<p;I++){const f=fe(t),B=ie(t),R=oe(t,0,B),D=ie(t),ge=new Uint8Array(oe(t,0,D));m.push({programIdIndex:f,accountKeyIndexes:R,data:ge})}const y=ie(t),l=[];for(let I=0;I<y;I++){const f=new h(oe(t,0,we)),B=ie(t),R=oe(t,0,B),D=ie(t),ge=oe(t,0,D);l.push({accountKey:f,writableIndexes:R,readonlyIndexes:ge})}return new We({header:o,staticAccountKeys:a,recentBlockhash:d,compiledInstructions:m,addressTableLookups:l})}}const rr={deserializeMessageVersion(i){const e=i[0],t=e&It;return t===e?"legacy":t},deserialize:i=>{const e=rr.deserializeMessageVersion(i);if(e==="legacy")return ye.from(i);if(e===0)return We.deserialize(i);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let _e=function(i){return i[i.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",i[i.PROCESSED=1]="PROCESSED",i[i.TIMED_OUT=2]="TIMED_OUT",i[i.NONCE_INVALID=3]="NONCE_INVALID",i}({});const Ks=x.Buffer.alloc(it).fill(0);class F{constructor(e){this.keys=void 0,this.programId=void 0,this.data=x.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class N{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new F(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let f=0;f<t.length;f++)if(t[f].programId===void 0)throw new Error(`Transaction instruction index ${f} has undefined program id`);const n=[],s=[];t.forEach(f=>{f.keys.forEach(R=>{s.push({...R})});const B=f.programId.toString();n.includes(B)||n.push(B)}),n.forEach(f=>{s.push({pubkey:new h(f),isSigner:!1,isWritable:!1})});const o=[];s.forEach(f=>{const B=f.pubkey.toString(),R=o.findIndex(D=>D.pubkey.toString()===B);R>-1?(o[R].isWritable=o[R].isWritable||f.isWritable,o[R].isSigner=o[R].isSigner||f.isSigner):o.push(f)}),o.sort(function(f,B){if(f.isSigner!==B.isSigner)return f.isSigner?-1:1;if(f.isWritable!==B.isWritable)return f.isWritable?-1:1;const R={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return f.pubkey.toBase58().localeCompare(B.pubkey.toBase58(),"en",R)});const a=o.findIndex(f=>f.pubkey.equals(r));if(a>-1){const[f]=o.splice(a,1);f.isSigner=!0,f.isWritable=!0,o.unshift(f)}else o.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const f of this.signatures){const B=o.findIndex(R=>R.pubkey.equals(f.publicKey));if(B>-1)o[B].isSigner||(o[B].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${f.publicKey.toString()}`)}let c=0,d=0,p=0;const m=[],y=[];o.forEach(({pubkey:f,isSigner:B,isWritable:R})=>{B?(m.push(f.toString()),c+=1,R||(d+=1)):(y.push(f.toString()),R||(p+=1))});const l=m.concat(y),I=t.map(f=>{const{data:B,programId:R}=f;return{programIdIndex:l.indexOf(R.toString()),accounts:f.keys.map(D=>l.indexOf(D.pubkey.toString())),data:re.encode(B)}});return I.forEach(f=>{M(f.programIdIndex>=0),f.accounts.forEach(B=>M(B>=0))}),new ye({header:{numRequiredSignatures:c,numReadonlySignedAccounts:d,numReadonlyUnsignedAccounts:p},accountKeys:l,recentBlockhash:e,instructions:I})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,n)=>t[n].equals(r.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(r=>{const n=r.toString();return t.has(n)?!1:(t.add(n),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const s of e){const o=s.publicKey.toString();t.has(o)||(t.add(o),r.push(s))}this.signatures=r.map(s=>({signature:null,publicKey:s.publicKey}));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const s of e){const o=s.publicKey.toString();t.has(o)||(t.add(o),r.push(s))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(n=>{const s=Zt(r,n.secretKey);this._addSignature(n.publicKey,K(s))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){M(t.length===64);const r=this.signatures.findIndex(n=>e.equals(n.publicKey));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=x.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:s}of this.signatures)n===null?t&&(r.missing||(r.missing=[])).push(s):_s(n,e,s.toBytes())||(r.invalid||(r.invalid=[])).push(s);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const s=this._getMessageSignednessErrors(n,t);if(s){let o="Signature verification failed.";throw s.invalid&&(o+=`
Invalid signature for public key${s.invalid.length===1?"":"(s)"} [\`${s.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),s.missing&&(o+=`
Missing signature for public key${s.missing.length===1?"":"(s)"} [\`${s.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];ue(r,t.length);const n=r.length+t.length*64+e.length,s=x.Buffer.alloc(n);return M(t.length<256),x.Buffer.from(r).copy(s,0),t.forEach(({signature:o},a)=>{o!==null&&(M(o.length===64,"signature has invalid length"),x.Buffer.from(o).copy(s,r.length+a*64))}),e.copy(s,r.length+t.length*64),M(s.length<=xe,`Transaction too large: ${s.length} > ${xe}`),s}get keys(){return M(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return M(this.instructions.length===1),this.instructions[0].programId}get data(){return M(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const r=ie(t);let n=[];for(let s=0;s<r;s++){const o=oe(t,0,it);n.push(re.encode(x.Buffer.from(o)))}return N.populate(ye.from(t),n)}static populate(e,t=[]){const r=new N;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((n,s)=>{const o={signature:n==re.encode(Ks)?null:re.decode(n),publicKey:e.accountKeys[s]};r.signatures.push(o)}),e.instructions.forEach(n=>{const s=n.accounts.map(o=>{const a=e.accountKeys[o];return{pubkey:a,isSigner:r.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(o),isWritable:e.isAccountWritable(o)}});r.instructions.push(new F({keys:s,programId:e.accountKeys[n.programIdIndex],data:re.decode(n.data)}))}),r._message=e,r._json=r.toJSON(),r}}class nr{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:s}=e,{numRequiredSignatures:o,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=r,d=o-a;M(d>0,"Message header is invalid");const p=e.staticAccountKeys.length-o-c;M(p>=0,"Message header is invalid");const m=e.getAccountKeys(t),y=m.get(0);if(y===void 0)throw new Error("Failed to decompile message because no account keys were found");const l=[];for(const I of n){const f=[];for(const R of I.accountKeyIndexes){const D=m.get(R);if(D===void 0)throw new Error(`Failed to find key for account key index ${R}`);const ge=R<o;let $e;ge?$e=R<d:R<m.staticAccountKeys.length?$e=R-o<p:$e=R-m.staticAccountKeys.length<m.accountKeysFromLookups.writable.length,f.push({pubkey:D,isSigner:R<r.numRequiredSignatures,isWritable:$e})}const B=m.get(I.programIdIndex);if(B===void 0)throw new Error(`Failed to find program id for program id index ${I.programIdIndex}`);l.push(new F({programId:B,data:K(I.data),keys:f}))}return new nr({payerKey:y,instructions:l,recentBlockhash:s})}compileToLegacyMessage(){return ye.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return We.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class sr{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)M(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const r=[];for(let n=0;n<e.header.numRequiredSignatures;n++)r.push(new Uint8Array(it));this.signatures=r}this.message=e}serialize(){const e=this.message.serialize(),t=Array();ue(t,this.signatures.length);const r=A([Y(t.length,"encodedSignaturesLength"),se(Ts(),this.signatures.length,"signatures"),Y(e.length,"serializedMessage")]),n=new Uint8Array(2048),s=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,s)}static deserialize(e){let t=[...e];const r=[],n=ie(t);for(let o=0;o<n;o++)r.push(new Uint8Array(oe(t,0,it)));const s=rr.deserialize(new Uint8Array(t));return new sr(s,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const s=r.findIndex(o=>o.equals(n.publicKey));M(s>=0,`Cannot sign with non signer key ${n.publicKey.toBase58()}`),this.signatures[s]=Zt(t,n.secretKey)}}addSignature(e,t){M(t.byteLength===64,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(n=>n.equals(e));M(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const Ws=160,Os=64,Ns=Ws/Os,Qr=1e3/Ns,ae=new h("SysvarC1ock11111111111111111111111111111111"),Ms=new h("SysvarEpochSchedu1e111111111111111111111111"),en=new h("Sysvar1nstructions1111111111111111111111111"),yt=new h("SysvarRecentB1ockHashes11111111111111111111"),he=new h("SysvarRent111111111111111111111111111111111"),Us=new h("SysvarRewards111111111111111111111111111111"),qs=new h("SysvarS1otHashes111111111111111111111111111"),Vs=new h("SysvarS1otHistory11111111111111111111111111"),ft=new h("SysvarStakeHistory1111111111111111111111111");async function Ut(i,e,t,r){const n=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},s=await i.sendTransaction(e,t,n);let o;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)o=(await i.confirmTransaction({abortSignal:r==null?void 0:r.abortSignal,signature:s,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},r&&r.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;o=(await i.confirmTransaction({abortSignal:r==null?void 0:r.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:s},r&&r.commitment)).value}else(r==null?void 0:r.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await i.confirmTransaction(s,r&&r.commitment)).value;if(o.err)throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);return s}function Ce(i){return new Promise(e=>setTimeout(e,i))}function O(i,e){const t=i.layout.span>=0?i.layout.span:Xr(i,e),r=x.Buffer.alloc(t),n=Object.assign({instruction:i.index},e);return i.layout.encode(n,r),r}function V(i,e){let t;try{t=i.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.instruction!==i.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${i.index}`);return t}const tn=ne("lamportsPerSignature"),rn=A([_("version"),_("state"),W("authorizedPubkey"),W("nonce"),A([tn],"feeCalculator")]),qt=rn.span;class At{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=rn.decode(K(e),0);return new At({authorizedPubkey:new h(t.authorizedPubkey),nonce:new h(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const $s=i=>{const e=i.decode.bind(i),t=i.encode.bind(i);return{decode:e,encode:t}},Ds=i=>e=>{const t=Y(i,e),{encode:r,decode:n}=$s(t),s=t;return s.decode=(o,a)=>{const c=n(o,a);return Qn(x.Buffer.from(c))},s.encode=(o,a,c)=>{const d=$r(o,i);return r(d,a,c)},s},je=Ds(8);class Fs{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=_("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(j))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=V(j.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new h(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=V(j.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=V(j.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new h(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=V(j.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:s}=V(j.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new h(t),seed:r,space:n,programId:new h(s)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=V(j.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new h(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=V(j.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new h(t),seed:r,programId:new h(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:s,programId:o}=V(j.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new h(t),seed:r,lamports:n,space:s,programId:new h(o)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=V(j.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new h(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),V(j.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=V(j.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=V(j.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new h(t)}}static checkProgramId(e){if(!e.equals(H.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const j=Object.freeze({Create:{index:0,layout:A([_("instruction"),le("lamports"),le("space"),W("programId")])},Assign:{index:1,layout:A([_("instruction"),W("programId")])},Transfer:{index:2,layout:A([_("instruction"),je("lamports")])},CreateWithSeed:{index:3,layout:A([_("instruction"),W("base"),Re("seed"),le("lamports"),le("space"),W("programId")])},AdvanceNonceAccount:{index:4,layout:A([_("instruction")])},WithdrawNonceAccount:{index:5,layout:A([_("instruction"),le("lamports")])},InitializeNonceAccount:{index:6,layout:A([_("instruction"),W("authorized")])},AuthorizeNonceAccount:{index:7,layout:A([_("instruction"),W("authorized")])},Allocate:{index:8,layout:A([_("instruction"),le("space")])},AllocateWithSeed:{index:9,layout:A([_("instruction"),W("base"),Re("seed"),le("space"),W("programId")])},AssignWithSeed:{index:10,layout:A([_("instruction"),W("base"),Re("seed"),W("programId")])},TransferWithSeed:{index:11,layout:A([_("instruction"),je("lamports"),Re("seed"),W("programId")])},UpgradeNonceAccount:{index:12,layout:A([_("instruction")])}});class H{constructor(){}static createAccount(e){const t=j.Create,r=O(t,{lamports:e.lamports,space:e.space,programId:K(e.programId.toBuffer())});return new F({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const n=j.TransferWithSeed;t=O(n,{lamports:BigInt(e.lamports),seed:e.seed,programId:K(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const n=j.Transfer;t=O(n,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new F({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const n=j.AssignWithSeed;t=O(n,{base:K(e.basePubkey.toBuffer()),seed:e.seed,programId:K(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=j.Assign;t=O(n,{programId:K(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new F({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=j.CreateWithSeed,r=O(t,{base:K(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:K(e.programId.toBuffer())});let n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&n.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new F({keys:n,programId:this.programId,data:r})}static createNonceAccount(e){const t=new N;"basePubkey"in e&&"seed"in e?t.add(H.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:qt,programId:this.programId})):t.add(H.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:qt,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=j.InitializeNonceAccount,r=O(t,{authorized:K(e.authorizedPubkey.toBuffer())}),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:yt,isSigner:!1,isWritable:!1},{pubkey:he,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new F(n)}static nonceAdvance(e){const t=j.AdvanceNonceAccount,r=O(t),n={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:yt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new F(n)}static nonceWithdraw(e){const t=j.WithdrawNonceAccount,r=O(t,{lamports:e.lamports});return new F({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:yt,isSigner:!1,isWritable:!1},{pubkey:he,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=j.AuthorizeNonceAccount,r=O(t,{authorized:K(e.newAuthorizedPubkey.toBuffer())});return new F({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const n=j.AllocateWithSeed;t=O(n,{base:K(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:K(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const n=j.Allocate;t=O(n,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new F({keys:r,programId:this.programId,data:t})}}H.programId=new h("11111111111111111111111111111111");const Hs=xe-300;class Oe{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Oe.chunkSize)+1+1)}static async load(e,t,r,n,s){{const m=await e.getMinimumBalanceForRentExemption(s.length),y=await e.getAccountInfo(r.publicKey,"confirmed");let l=null;if(y!==null){if(y.executable)return console.error("Program load failed, account is already executable"),!1;y.data.length!==s.length&&(l=l||new N,l.add(H.allocate({accountPubkey:r.publicKey,space:s.length}))),y.owner.equals(n)||(l=l||new N,l.add(H.assign({accountPubkey:r.publicKey,programId:n}))),y.lamports<m&&(l=l||new N,l.add(H.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:m-y.lamports})))}else l=new N().add(H.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:m>0?m:1,space:s.length,programId:n}));l!==null&&await Ut(e,l,[t,r],{commitment:"confirmed"})}const o=A([_("instruction"),_("offset"),_("bytesLength"),_("bytesLengthPadding"),se(U("byte"),ze(_(),-8),"bytes")]),a=Oe.chunkSize;let c=0,d=s,p=[];for(;d.length>0;){const m=d.slice(0,a),y=x.Buffer.alloc(a+16);o.encode({instruction:0,offset:c,bytes:m,bytesLength:0,bytesLengthPadding:0},y);const l=new N().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:y});p.push(Ut(e,l,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await Ce(1e3/4),c+=a,d=d.slice(a)}await Promise.all(p);{const m=A([_("instruction")]),y=x.Buffer.alloc(m.span);m.encode({instruction:1},y);const l=new N().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:he,isSigner:!1,isWritable:!1}],programId:n,data:y}),I="processed",f=await e.sendTransaction(l,[t,r],{preflightCommitment:I}),{context:B,value:R}=await e.confirmTransaction({signature:f,lastValidBlockHeight:l.lastValidBlockHeight,blockhash:l.recentBlockhash},I);if(R.err)throw new Error(`Transaction ${f} failed (${JSON.stringify(R)})`);for(;;){try{if(await e.getSlot({commitment:I})>B.slot)break}catch{}await new Promise(D=>setTimeout(D,Math.round(Qr/2)))}}return!0}}Oe.chunkSize=Hs;const js=new h("BPFLoader2111111111111111111111111111111111");class Gs{static getMinNumSignatures(e){return Oe.getMinNumSignatures(e)}static load(e,t,r,n,s){return Oe.load(e,t,r,s,n)}}function Js(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var Ys=Object.prototype.toString,Xs=Object.keys||function(i){var e=[];for(var t in i)e.push(t);return e};function rt(i,e){var t,r,n,s,o,a,c;if(i===!0)return"true";if(i===!1)return"false";switch(typeof i){case"object":if(i===null)return null;if(i.toJSON&&typeof i.toJSON=="function")return rt(i.toJSON(),e);if(c=Ys.call(i),c==="[object Array]"){for(n="[",r=i.length-1,t=0;t<r;t++)n+=rt(i[t],!0)+",";return r>-1&&(n+=rt(i[t],!0)),n+"]"}else if(c==="[object Object]"){for(s=Xs(i).sort(),r=s.length,n="",t=0;t<r;)o=s[t],a=rt(i[o],!1),a!==void 0&&(n&&(n+=","),n+=JSON.stringify(o)+":"+a),t++;return"{"+n+"}"}else return JSON.stringify(i);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(i);default:return isFinite(i)?i:null}}var Zs=function(i){var e=rt(i,!1);if(e!==void 0)return""+e},Br=Js(Zs);const et=32;function Kt(i){let e=0;for(;i>1;)i/=2,e++;return e}function Qs(i){return i===0?1:(i--,i|=i>>1,i|=i>>2,i|=i>>4,i|=i>>8,i|=i>>16,i|=i>>32,i+1)}class nn{constructor(e,t,r,n,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=s}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Kt(Qs(e+et+1))-Kt(et)-1,r=this.getSlotsInEpoch(t),n=e-(r-et);return[t,n]}else{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),n=this.firstNormalEpoch+r,s=t%this.slotsPerEpoch;return[n,s]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*et:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Kt(et)):this.slotsPerEpoch}}class Vt extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}const ei={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class P extends Error{constructor({code:e,message:t,data:r},n){super(n!=null?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var ti=globalThis.fetch;class ri extends ns{constructor(e,t,r){const n=s=>{const o=is(s,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(n,e,t,r),this.underlyingSocket=void 0}call(...e){var t;const r=(t=this.underlyingSocket)==null?void 0:t.readyState;return r===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}notify(...e){var t;const r=(t=this.underlyingSocket)==null?void 0:t.readyState;return r===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}}function ni(i,e){let t;try{t=i.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.typeIndex!==i.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);return t}const xr=56;class $t{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=ni(si,e),r=e.length-xr;M(r>=0,"lookup table is invalid"),M(r%32===0,"lookup table is invalid");const n=r/32,{addresses:s}=A([se(W(),n,"addresses")]).decode(e.slice(xr));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new h(t.authority[0]):void 0,addresses:s.map(o=>new h(o))}}}const si={index:1,layout:A([_("typeIndex"),je("deactivationSlot"),ne("lastExtendedSlot"),U("lastExtendedStartIndex"),U(),se(W(),ze(U(),-1),"authority")])},ii=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function oi(i){const e=i.match(ii);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${i}\``);const[t,r,n,s]=e,o=i.startsWith("https:")?"wss:":"ws:",a=n==null?null:parseInt(n.slice(1),10),c=a==null?"":`:${a+1}`;return`${o}//${r}${c}${s}`}const ee=ht(Yt(h),b(),i=>new h(i)),sn=Xt([b(),X("base64")]),ir=ht(Yt(x.Buffer),sn,i=>x.Buffer.from(i[0],"base64")),on=30*1e3;function ai(i){if(/^https?:/.test(i)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return i}function G(i){let e,t;if(typeof i=="string")e=i;else if(i){const{commitment:r,...n}=i;e=r,t=n}return{commitment:e,config:t}}function an(i){return ce([g({jsonrpc:X("2.0"),id:b(),result:i}),g({jsonrpc:X("2.0"),id:b(),error:g({code:lt(),message:b(),data:T(Is())})})])}const ci=an(lt());function z(i){return ht(an(i),ci,e=>"error"in e?e:{...e,result:k(e.result,i)})}function Z(i){return z(g({context:g({slot:u()}),value:i}))}function _t(i){return g({context:g({slot:u()}),value:i})}function Wt(i,e){return i===0?new We({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new h(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:re.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new ye(e)}const ui=g({foundation:u(),foundationTerm:u(),initial:u(),taper:u(),terminal:u()}),di=z(S(w(g({epoch:u(),effectiveSlot:u(),amount:u(),postBalance:u(),commission:T(w(u()))})))),li=S(g({slot:u(),prioritizationFee:u()})),hi=g({total:u(),validator:u(),foundation:u(),epoch:u()}),gi=g({epoch:u(),slotIndex:u(),slotsInEpoch:u(),absoluteSlot:u(),blockHeight:T(u()),transactionCount:T(u())}),pi=g({slotsPerEpoch:u(),leaderScheduleSlotOffset:u(),warmup:Se(),firstNormalEpoch:u(),firstNormalSlot:u()}),mi=jr(b(),S(u())),Ue=w(ce([g({}),b()])),yi=g({err:Ue}),fi=X("receivedSignature"),bi=g({"solana-core":b(),"feature-set":T(u())}),Tr=Z(g({err:w(ce([g({}),b()])),logs:w(S(b())),accounts:T(w(S(w(g({executable:Se(),owner:b(),lamports:u(),data:S(b()),rentEpoch:T(u())}))))),unitsConsumed:T(u()),returnData:T(w(g({programId:b(),data:Xt([b(),X("base64")])})))})),ki=Z(g({byIdentity:jr(b(),S(u())),range:g({firstSlot:u(),lastSlot:u()})}));function wi(i,e,t,r,n,s){const o=t||ti;let a;s!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return r&&(c=async(d,p)=>{const m=await new Promise((y,l)=>{try{r(d,p,(I,f)=>y([I,f]))}catch(I){l(I)}});return await o(...m)}),new ss(async(d,p)=>{const m={method:"POST",body:d,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Io)};try{let y=5,l,I=500;for(;c?l=await c(i,m):l=await o(i,m),!(l.status!==429||n===!0||(y-=1,y===0));)console.error(`Server responded with ${l.status} ${l.statusText}.  Retrying after ${I}ms delay...`),await Ce(I),I*=2;const f=await l.text();l.ok?p(null,f):p(new Error(`${l.status} ${l.statusText}: ${f}`))}catch(y){y instanceof Error&&p(y)}},{})}function Si(i){return(e,t)=>new Promise((r,n)=>{i.request(e,t,(s,o)=>{if(s){n(s);return}r(o)})})}function Ii(i){return e=>new Promise((t,r)=>{e.length===0&&t([]);const n=e.map(s=>i.request(s.methodName,s.args));i.request(n,(s,o)=>{if(s){r(s);return}t(o)})})}const vi=z(ui),Ai=z(hi),_i=z(li),Pi=z(gi),Ei=z(pi),Bi=z(mi),xi=z(u()),Ti=Z(g({total:u(),circulating:u(),nonCirculating:u(),nonCirculatingAccounts:S(ee)})),Dt=g({amount:b(),uiAmount:w(u()),decimals:u(),uiAmountString:T(b())}),Ci=Z(S(g({address:ee,amount:b(),uiAmount:w(u()),decimals:u(),uiAmountString:T(b())}))),Li=Z(S(g({pubkey:ee,account:g({executable:Se(),owner:ee,lamports:u(),data:ir,rentEpoch:u()})}))),Ft=g({program:b(),parsed:lt(),space:u()}),Ri=Z(S(g({pubkey:ee,account:g({executable:Se(),owner:ee,lamports:u(),data:Ft,rentEpoch:u()})}))),zi=Z(S(g({lamports:u(),address:ee}))),at=g({executable:Se(),owner:ee,lamports:u(),data:ir,rentEpoch:u()}),Ki=g({pubkey:ee,account:at}),Wi=ht(ce([Yt(x.Buffer),Ft]),ce([sn,Ft]),i=>Array.isArray(i)?k(i,ir):i),Ht=g({executable:Se(),owner:ee,lamports:u(),data:Wi,rentEpoch:u()}),Oi=g({pubkey:ee,account:Ht}),Ni=g({state:ce([X("active"),X("inactive"),X("activating"),X("deactivating")]),active:u(),inactive:u()}),Mi=z(S(g({signature:b(),slot:u(),err:Ue,memo:w(b()),blockTime:T(w(u()))}))),Ui=z(S(g({signature:b(),slot:u(),err:Ue,memo:w(b()),blockTime:T(w(u()))}))),qi=g({subscription:u(),result:_t(at)}),Vi=g({pubkey:ee,account:at}),$i=g({subscription:u(),result:_t(Vi)}),Di=g({parent:u(),slot:u(),root:u()}),Fi=g({subscription:u(),result:Di}),Hi=ce([g({type:ce([X("firstShredReceived"),X("completed"),X("optimisticConfirmation"),X("root")]),slot:u(),timestamp:u()}),g({type:X("createdBank"),parent:u(),slot:u(),timestamp:u()}),g({type:X("frozen"),slot:u(),timestamp:u(),stats:g({numTransactionEntries:u(),numSuccessfulTransactions:u(),numFailedTransactions:u(),maxTransactionsPerEntry:u()})}),g({type:X("dead"),slot:u(),timestamp:u(),err:b()})]),ji=g({subscription:u(),result:Hi}),Gi=g({subscription:u(),result:_t(ce([yi,fi]))}),Ji=g({subscription:u(),result:u()}),Yi=g({pubkey:b(),gossip:w(b()),tpu:w(b()),rpc:w(b()),version:w(b())}),Cr=g({votePubkey:b(),nodePubkey:b(),activatedStake:u(),epochVoteAccount:Se(),epochCredits:S(Xt([u(),u(),u()])),commission:u(),lastVote:u(),rootSlot:w(u())}),Xi=z(g({current:S(Cr),delinquent:S(Cr)})),Zi=ce([X("processed"),X("confirmed"),X("finalized")]),Qi=g({slot:u(),confirmations:w(u()),err:Ue,confirmationStatus:T(Zi)}),eo=Z(S(w(Qi))),to=z(u()),cn=g({accountKey:ee,writableIndexes:S(u()),readonlyIndexes:S(u())}),or=g({signatures:S(b()),message:g({accountKeys:S(b()),header:g({numRequiredSignatures:u(),numReadonlySignedAccounts:u(),numReadonlyUnsignedAccounts:u()}),instructions:S(g({accounts:S(u()),data:b(),programIdIndex:u()})),recentBlockhash:b(),addressTableLookups:T(S(cn))})}),un=g({pubkey:ee,signer:Se(),writable:Se(),source:T(ce([X("transaction"),X("lookupTable")]))}),dn=g({accountKeys:S(un),signatures:S(b())}),ln=g({parsed:lt(),program:b(),programId:ee}),hn=g({accounts:S(ee),data:b(),programId:ee}),ro=ce([hn,ln]),no=ce([g({parsed:lt(),program:b(),programId:b()}),g({accounts:S(b()),data:b(),programId:b()})]),gn=ht(ro,no,i=>"accounts"in i?k(i,hn):k(i,ln)),pn=g({signatures:S(b()),message:g({accountKeys:S(un),instructions:S(gn),recentBlockhash:b(),addressTableLookups:T(w(S(cn)))})}),wt=g({accountIndex:u(),mint:b(),owner:T(b()),uiTokenAmount:Dt}),mn=g({writable:S(ee),readonly:S(ee)}),Pt=g({err:Ue,fee:u(),innerInstructions:T(w(S(g({index:u(),instructions:S(g({accounts:S(u()),data:b(),programIdIndex:u()}))})))),preBalances:S(u()),postBalances:S(u()),logMessages:T(w(S(b()))),preTokenBalances:T(w(S(wt))),postTokenBalances:T(w(S(wt))),loadedAddresses:T(mn),computeUnitsConsumed:T(u())}),ar=g({err:Ue,fee:u(),innerInstructions:T(w(S(g({index:u(),instructions:S(gn)})))),preBalances:S(u()),postBalances:S(u()),logMessages:T(w(S(b()))),preTokenBalances:T(w(S(wt))),postTokenBalances:T(w(S(wt))),loadedAddresses:T(mn),computeUnitsConsumed:T(u())}),Ye=ce([X(0),X("legacy")]),qe=g({pubkey:b(),lamports:u(),postBalance:w(u()),rewardType:w(b()),commission:T(w(u()))}),so=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),transactions:S(g({transaction:or,meta:w(Pt),version:T(Ye)})),rewards:T(S(qe)),blockTime:w(u()),blockHeight:w(u())}))),io=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),rewards:T(S(qe)),blockTime:w(u()),blockHeight:w(u())}))),oo=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),transactions:S(g({transaction:dn,meta:w(Pt),version:T(Ye)})),rewards:T(S(qe)),blockTime:w(u()),blockHeight:w(u())}))),ao=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),transactions:S(g({transaction:pn,meta:w(ar),version:T(Ye)})),rewards:T(S(qe)),blockTime:w(u()),blockHeight:w(u())}))),co=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),transactions:S(g({transaction:dn,meta:w(ar),version:T(Ye)})),rewards:T(S(qe)),blockTime:w(u()),blockHeight:w(u())}))),uo=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),rewards:T(S(qe)),blockTime:w(u()),blockHeight:w(u())}))),lo=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),transactions:S(g({transaction:or,meta:w(Pt)})),rewards:T(S(qe)),blockTime:w(u())}))),Lr=z(w(g({blockhash:b(),previousBlockhash:b(),parentSlot:u(),signatures:S(b()),blockTime:w(u())}))),Ot=z(w(g({slot:u(),meta:w(Pt),blockTime:T(w(u())),transaction:or,version:T(Ye)}))),pt=z(w(g({slot:u(),transaction:pn,meta:w(ar),blockTime:T(w(u())),version:T(Ye)}))),ho=Z(g({blockhash:b(),feeCalculator:g({lamportsPerSignature:u()})})),go=Z(g({blockhash:b(),lastValidBlockHeight:u()})),po=Z(Se()),mo=g({slot:u(),numTransactions:u(),numSlots:u(),samplePeriodSecs:u()}),yo=z(S(mo)),fo=Z(w(g({feeCalculator:g({lamportsPerSignature:u()})}))),bo=z(b()),ko=z(b()),wo=g({err:Ue,logs:S(b()),signature:b()}),So=g({result:_t(wo),subscription:u()}),Io={"solana-client":"js/0.0.0-development"};class vo{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const d={};return async p=>{const{commitment:m,config:y}=G(p),l=this._buildArgs([],m,void 0,y),I=Br(l);return d[I]=d[I]??(async()=>{try{const f=await this._rpcRequest("getBlockHeight",l),B=k(f,z(u()));if("error"in B)throw new P(B.error,"failed to get block height information");return B.result}finally{delete d[I]}})(),await d[I]}})();let r,n,s,o,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,n=t.httpHeaders,s=t.fetch,o=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=ai(e),this._rpcWsEndpoint=r||oi(e),this._rpcClient=wi(e,n,s,o,a,c),this._rpcRequest=Si(this._rpcClient),this._rpcBatchRequest=Ii(this._rpcClient),this._rpcWebSocket=new ri(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgs([e.toBase58()],r,void 0,n),o=await this._rpcRequest("getBalance",s),a=k(o,Z(u()));if("error"in a)throw new P(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=k(t,z(w(u())));if("error"in r)throw new P(r.error,`failed to get block time for slot ${e}`);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=k(e,z(u()));if("error"in t)throw new P(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=k(e,xi);if("error"in t)throw new P(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),n=k(r,Ti);if("error"in n)throw new P(n.error,"failed to get supply");return n.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenSupply",r),s=k(n,Z(Dt));if("error"in s)throw new P(s.error,"failed to get token supply");return s.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenAccountBalance",r),s=k(n,Z(Dt));if("error"in s)throw new P(s.error,"failed to get token account balance");return s.result}async getTokenAccountsByOwner(e,t,r){const{commitment:n,config:s}=G(r);let o=[e.toBase58()];"mint"in t?o.push({mint:t.mint.toBase58()}):o.push({programId:t.programId.toBase58()});const a=this._buildArgs(o,n,"base64",s),c=await this._rpcRequest("getTokenAccountsByOwner",a),d=k(c,Li);if("error"in d)throw new P(d.error,`failed to get token accounts owned by account ${e.toBase58()}`);return d.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const s=this._buildArgs(n,r,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",s),a=k(o,Ri);if("error"in a)throw new P(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=await this._rpcRequest("getLargestAccounts",r),s=k(n,zi);if("error"in s)throw new P(s.error,"failed to get largest accounts");return s.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenLargestAccounts",r),s=k(n,Ci);if("error"in s)throw new P(s.error,"failed to get token largest accounts");return s.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgs([e.toBase58()],r,"base64",n),o=await this._rpcRequest("getAccountInfo",s),a=k(o,Z(w(at)));if("error"in a)throw new P(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgs([e.toBase58()],r,"jsonParsed",n),o=await this._rpcRequest("getAccountInfo",s),a=k(o,Z(w(Ht)));if("error"in a)throw new P(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:n}=G(t),s=e.map(d=>d.toBase58()),o=this._buildArgs([s],r,"jsonParsed",n),a=await this._rpcRequest("getMultipleAccounts",o),c=k(a,Z(S(w(Ht))));if("error"in c)throw new P(c.error,`failed to get info for accounts ${s}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:n}=G(t),s=e.map(d=>d.toBase58()),o=this._buildArgs([s],r,"base64",n),a=await this._rpcRequest("getMultipleAccounts",o),c=k(a,Z(S(w(at))));if("error"in c)throw new P(c.error,`failed to get info for accounts ${s}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const{commitment:n,config:s}=G(t),o=this._buildArgs([e.toBase58()],n,void 0,{...s,epoch:r??(s==null?void 0:s.epoch)}),a=await this._rpcRequest("getStakeActivation",o),c=k(a,z(Ni));if("error"in c)throw new P(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:r,config:n}=G(t),{encoding:s,...o}=n||{},a=this._buildArgs([e.toBase58()],r,s||"base64",o),c=await this._rpcRequest("getProgramAccounts",a),d=S(Ki),p=o.withContext===!0?k(c,Z(d)):k(c,z(d));if("error"in p)throw new P(p.error,`failed to get accounts owned by program ${e.toBase58()}`);return p.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgs([e.toBase58()],r,"jsonParsed",n),o=await this._rpcRequest("getProgramAccounts",s),a=k(o,z(S(Oi)));if("error"in a)throw new P(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var r;let n;if(typeof e=="string")n=e;else{const o=e;if((r=o.abortSignal)!=null&&r.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=re.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return M(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{e!=null&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,s=!1;const o=new Promise((a,c)=>{try{r=this.onSignature(t,(p,m)=>{r=void 0;const y={context:m,value:p};a({__type:_e.PROCESSED,response:y})},e);const d=new Promise(p=>{r==null?p():n=this._onSubscriptionStateChange(r,m=>{m==="subscribed"&&p()})});(async()=>{if(await d,s)return;const p=await this.getSignatureStatus(t);if(s||p==null)return;const{context:m,value:y}=p;if(y!=null)if(y!=null&&y.err)c(y.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(y.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(y.confirmationStatus==="processed"||y.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}s=!0,a({__type:_e.PROCESSED,response:{context:m,value:y}})}})()}catch(d){c(d)}});return{abortConfirmation:()=>{n&&(n(),n=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let s=!1;const o=new Promise(m=>{const y=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let l=await y();if(!s){for(;l<=r;)if(await Ce(1e3),s||(l=await y(),s))return;m({__type:_e.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),d=this.getCancellationPromise(t);let p;try{const m=await Promise.race([d,c,o]);if(m.__type===_e.PROCESSED)p=m.response;else throw new er(n)}finally{s=!0,a()}return p}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:s,signature:o}}){let a=!1;const c=new Promise(l=>{let I=s,f=null;const B=async()=>{try{const{context:R,value:D}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return f=R.slot,D==null?void 0:D.nonce}catch{return I}};(async()=>{if(I=await B(),!a)for(;;){if(s!==I){l({__type:_e.NONCE_INVALID,slotInWhichNonceDidAdvance:f});return}if(await Ce(2e3),a||(I=await B(),a))return}})()}),{abortConfirmation:d,confirmationPromise:p}=this.getTransactionConfirmationPromise({commitment:e,signature:o}),m=this.getCancellationPromise(t);let y;try{const l=await Promise.race([m,p,c]);if(l.__type===_e.PROCESSED)y=l.response;else{let I;for(;;){const f=await this.getSignatureStatus(o);if(f==null)break;if(f.context.slot<(l.slotInWhichNonceDidAdvance??r)){await Ce(400);continue}I=f;break}if(I!=null&&I.value){const f=e||"finalized",{confirmationStatus:B}=I.value;switch(f){case"processed":case"recent":if(B!=="processed"&&B!=="confirmed"&&B!=="finalized")throw new De(o);break;case"confirmed":case"single":case"singleGossip":if(B!=="confirmed"&&B!=="finalized")throw new De(o);break;case"finalized":case"max":case"root":if(B!=="finalized")throw new De(o);break;default:}y={context:I.context,value:{err:I.value.err}}}else throw new De(o)}}finally{a=!0,d()}return y}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const n=new Promise(c=>{let d=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{d=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>c({__type:_e.TIMED_OUT,timeoutMs:d}),d)}),{abortConfirmation:s,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([o,n]);if(c.__type===_e.PROCESSED)a=c.response;else throw new tr(t,c.timeoutMs/1e3)}finally{clearTimeout(r),s()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=k(e,z(S(Yi)));if("error"in t)throw new P(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),n=k(r,Xi);if("error"in n)throw new P(n.error,"failed to get vote accounts");return n.result}async getSlot(e){const{commitment:t,config:r}=G(e),n=this._buildArgs([],t,void 0,r),s=await this._rpcRequest("getSlot",n),o=k(s,z(u()));if("error"in o)throw new P(o.error,"failed to get slot");return o.result}async getSlotLeader(e){const{commitment:t,config:r}=G(e),n=this._buildArgs([],t,void 0,r),s=await this._rpcRequest("getSlotLeader",n),o=k(s,z(b()));if("error"in o)throw new P(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(e,t){const r=[e,t],n=await this._rpcRequest("getSlotLeaders",r),s=k(n,z(S(ee)));if("error"in s)throw new P(s.error,"failed to get slot leaders");return s.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);M(n.length===1);const s=n[0];return{context:r,value:s}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=await this._rpcRequest("getSignatureStatuses",r),s=k(n,eo);if("error"in s)throw new P(s.error,"failed to get signature status");return s.result}async getTransactionCount(e){const{commitment:t,config:r}=G(e),n=this._buildArgs([],t,void 0,r),s=await this._rpcRequest("getTransactionCount",n),o=k(s,z(u()));if("error"in o)throw new P(o.error,"failed to get transaction count");return o.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),n=k(r,vi);if("error"in n)throw new P(n.error,"failed to get inflation");return n.result}async getInflationReward(e,t,r){const{commitment:n,config:s}=G(r),o=this._buildArgs([e.map(d=>d.toBase58())],n,void 0,{...s,epoch:t??(s==null?void 0:s.epoch)}),a=await this._rpcRequest("getInflationReward",o),c=k(a,di);if("error"in c)throw new P(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=k(e,Ai);if("error"in t)throw new P(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=G(e),n=this._buildArgs([],t,void 0,r),s=await this._rpcRequest("getEpochInfo",n),o=k(s,Pi);if("error"in o)throw new P(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=k(e,Ei);if("error"in t)throw new P(t.error,"failed to get epoch schedule");const r=t.result;return new nn(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=k(e,Bi);if("error"in t)throw new P(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),s=k(n,to);return"error"in s?(console.warn("Unable to fetch minimum balance for rent exemption"),0):s.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),n=k(r,ho);if("error"in n)throw new P(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=k(t,yo);if("error"in r)throw new P(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),s=k(n,fo);if("error"in s)throw new P(s.error,"failed to get fee calculator");const{context:o,value:a}=s.result;return{context:o,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const r=K(e.serialize()).toString("base64"),n=this._buildArgs([r],t),s=await this._rpcRequest("getFeeForMessage",n),o=k(s,Z(w(u())));if("error"in o)throw new P(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(e){var t;const r=(t=e==null?void 0:e.lockedWritableAccounts)==null?void 0:t.map(a=>a.toBase58()),n=r!=null&&r.length?[r]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),o=k(s,_i);if("error"in o)throw new P(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=G(e),n=this._buildArgs([],t,void 0,r),s=await this._rpcRequest("getLatestBlockhash",n),o=k(s,go);if("error"in o)throw new P(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgs([e],r,void 0,n),o=await this._rpcRequest("isBlockhashValid",s),a=k(o,po);if("error"in a)throw new P(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=k(e,z(bi));if("error"in t)throw new P(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=k(e,z(b()));if("error"in t)throw new P(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgsAtLeastConfirmed([e],r,void 0,n),o=await this._rpcRequest("getBlock",s);try{switch(n==null?void 0:n.transactionDetails){case"accounts":{const a=k(o,oo);if("error"in a)throw a.error;return a.result}case"none":{const a=k(o,io);if("error"in a)throw a.error;return a.result}default:{const a=k(o,so);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:d,meta:p,version:m})=>({meta:p,transaction:{...d,message:Wt(m,d.message)},version:m}))}:null}}}catch(a){throw new P(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),o=await this._rpcRequest("getBlock",s);try{switch(n==null?void 0:n.transactionDetails){case"accounts":{const a=k(o,co);if("error"in a)throw a.error;return a.result}case"none":{const a=k(o,uo);if("error"in a)throw a.error;return a.result}default:{const a=k(o,ao);if("error"in a)throw a.error;return a.result}}}catch(a){throw new P(a,"failed to get block")}}async getBlockProduction(e){let t,r;if(typeof e=="string")r=e;else if(e){const{commitment:a,...c}=e;r=a,t=c}const n=this._buildArgs([],r,"base64",t),s=await this._rpcRequest("getBlockProduction",n),o=k(s,ki);if("error"in o)throw new P(o.error,"failed to get block production information");return o.result}async getTransaction(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgsAtLeastConfirmed([e],r,void 0,n),o=await this._rpcRequest("getTransaction",s),a=k(o,Ot);if("error"in a)throw new P(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Wt(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:r,config:n}=G(t),s=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),o=await this._rpcRequest("getTransaction",s),a=k(o,pt);if("error"in a)throw new P(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:r,config:n}=G(t),s=e.map(o=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([o],r,"jsonParsed",n)}));return(await this._rpcBatchRequest(s)).map(o=>{const a=k(o,pt);if("error"in a)throw new P(a.error,"failed to get transactions");return a.result})}async getTransactions(e,t){const{commitment:r,config:n}=G(t),s=e.map(o=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([o],r,void 0,n)}));return(await this._rpcBatchRequest(s)).map(o=>{const a=k(o,Ot);if("error"in a)throw new P(a.error,"failed to get transactions");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Wt(c.version,c.transaction.message)}}})}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedBlock",r),s=k(n,lo);if("error"in s)throw new P(s.error,"failed to get confirmed block");const o=s.result;if(!o)throw new Error("Confirmed block "+e+" not found");const a={...o,transactions:o.transactions.map(({transaction:c,meta:d})=>{const p=new ye(c.message);return{meta:d,transaction:{...c,message:p}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:d})=>({meta:d,transaction:N.populate(c.message,c.signatures)}))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],r),s=await this._rpcRequest("getBlocks",n),o=k(s,z(S(u())));if("error"in o)throw new P(o.error,"failed to get blocks");return o.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),s=k(n,Lr);if("error"in s)throw new P(s.error,"failed to get block");const o=s.result;if(!o)throw new Error("Block "+e+" not found");return o}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),s=k(n,Lr);if("error"in s)throw new P(s.error,"failed to get confirmed block");const o=s.result;if(!o)throw new Error("Confirmed block "+e+" not found");return o}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedTransaction",r),s=k(n,Ot);if("error"in s)throw new P(s.error,"failed to get transaction");const o=s.result;if(!o)return o;const a=new ye(o.transaction.message),c=o.transaction.signatures;return{...o,transaction:N.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),s=k(n,pt);if("error"in s)throw new P(s.error,"failed to get confirmed transaction");return s.result}async getParsedConfirmedTransactions(e,t){const r=e.map(n=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([n],t,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(n=>{const s=k(n,pt);if("error"in s)throw new P(s.error,"failed to get confirmed transactions");return s.result})}async getConfirmedSignaturesForAddress(e,t,r){let n={},s=await this.getFirstAvailableBlock();for(;!("until"in n)&&(t--,!(t<=0||t<s));)try{const a=await this.getConfirmedBlockSignatures(t,"finalized");a.signatures.length>0&&(n.until=a.signatures[a.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}let o=await this.getSlot("finalized");for(;!("before"in n)&&(r++,!(r>o));)try{const a=await this.getConfirmedBlockSignatures(r);a.signatures.length>0&&(n.before=a.signatures[a.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}return(await this.getConfirmedSignaturesForAddress2(e,n)).map(a=>a.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),s=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),o=k(s,Mi);if("error"in o)throw new P(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),s=await this._rpcRequest("getSignaturesForAddress",n),o=k(s,Ui);if("error"in o)throw new P(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let s=null;return n!==null&&(s=new $t({key:e,state:$t.deserialize(n.data)})),{context:r,value:s}}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let s=null;return n!==null&&(s=At.fromAccountData(n.data)),{context:r,value:s}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),n=k(r,bo);if("error"in n)throw new P(n.error,`airdrop to ${e.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Ce(100);const t=Date.now()-this._blockhashInfo.lastFetch>=on;if(this._blockhashInfo.latestBlockhash!==null&&!t)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){const s=await this.getLatestBlockhash("finalized");if(r!==s.blockhash)return this._blockhashInfo={latestBlockhash:s,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},s;await Ce(Qr/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=G(e),n=this._buildArgs([],t,"base64",r),s=await this._rpcRequest("getStakeMinimumDelegation",n),o=k(s,Z(u()));if("error"in o)throw new P(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(e,t,r){if("message"in e){const l=e.serialize(),I=x.Buffer.from(l).toString("base64");if(Array.isArray(t)||r!==void 0)throw new Error("Invalid arguments");const f=t||{};f.encoding="base64","commitment"in f||(f.commitment=this.commitment);const B=[I,f],R=await this._rpcRequest("simulateTransaction",B),D=k(R,Tr);if("error"in D)throw new Error("failed to simulate transaction: "+D.error.message);return D.result}let n;if(e instanceof N){let l=e;n=new N,n.feePayer=l.feePayer,n.instructions=e.instructions,n.nonceInfo=l.nonceInfo,n.signatures=l.signatures}else n=N.populate(e),n._message=n._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(n.nonceInfo&&s)n.sign(...s);else{let l=this._disableBlockhashCaching;for(;;){const I=await this._blockhashWithExpiryBlockHeight(l);if(n.lastValidBlockHeight=I.lastValidBlockHeight,n.recentBlockhash=I.blockhash,!s)break;if(n.sign(...s),!n.signature)throw new Error("!signature");const f=n.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(f)&&!this._blockhashInfo.transactionSignatures.includes(f)){this._blockhashInfo.simulatedSignatures.push(f);break}else l=!0}}const o=n._compile(),a=o.serialize(),c=n._serialize(a).toString("base64"),d={encoding:"base64",commitment:this.commitment};if(r){const l=(Array.isArray(r)?r:o.nonProgramIds()).map(I=>I.toBase58());d.accounts={encoding:"base64",addresses:l}}s&&(d.sigVerify=!0);const p=[c,d],m=await this._rpcRequest("simulateTransaction",p),y=k(m,Tr);if("error"in y){let l;if("data"in y.error&&(l=y.error.data.logs,l&&Array.isArray(l))){const I=`
    `,f=I+l.join(I);console.error(y.error.message,f)}throw new Vt("failed to simulate transaction: "+y.error.message,l)}return y.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const o=e.serialize();return await this.sendRawTransaction(o,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(e.nonceInfo)e.sign(...n);else{let o=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(o);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...n),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))o=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const s=e.serialize();return await this.sendRawTransaction(s,r)}async sendRawTransaction(e,t){const r=K(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,s=n===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(r.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),s&&(r.preflightCommitment=s);const o=[e,r],a=await this._rpcRequest("sendTransaction",o),c=k(a,ko);if("error"in c){let d;throw"data"in c.error&&(d=c.error.data.logs),new Vt("failed to send transaction: "+c.error.message,d)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,r])=>{this._setSubscription(t,{...r,state:"pending"})})}_setSubscription(e,t){var r;const n=(r=this._subscriptionsByHash[e])==null?void 0:r.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const n=this._subscriptionsByHash[r];if(n!==void 0)switch(n.state){case"pending":case"unsubscribed":if(n.callbacks.size===0){delete this._subscriptionsByHash[r],n.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:s,method:o}=n;try{this._setSubscription(r,{...n,state:"subscribing"});const a=await this._rpcWebSocket.call(o,s);this._setSubscription(r,{...n,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=n.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${o} error for argument`,s,a.message),!t())return;this._setSubscription(r,{...n,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":n.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:s,unsubscribeMethod:o}=n;if(this._subscriptionsAutoDisposedByRpc.has(s))this._subscriptionsAutoDisposedByRpc.delete(s);else{this._setSubscription(r,{...n,state:"unsubscribing"}),this._setSubscription(r,{...n,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[s])}catch(a){if(a instanceof Error&&console.error(`${o} error:`,a.message),!t())return;this._setSubscription(r,{...n,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...n,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];r!==void 0&&r.forEach(n=>{try{n(...t)}catch(s){console.error(s)}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=k(e,qi);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=Br([e.method,t]),s=this._subscriptionsByHash[n];return s===void 0?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:s.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const o=this._subscriptionsByHash[n];M(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),o.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},n)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=k(e,$i);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const s=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",n?{filters:n}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},s)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=k(e,So);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=k(e,Fi);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=k(e,ji);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,n){const s=t||this._commitment;if(s||r||n){let o={};r&&(o.encoding=r),s&&(o.commitment=s),n&&(o=Object.assign(o,n)),e.push(o)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const s=t||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=k(e,Gi);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),s=this._makeSubscription({callback:(o,a)=>{if(o.type==="status"){t(o.result,a);try{this.removeSignatureListener(s)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return s}onSignatureWithOptions(e,t,r){const{commitment:n,...s}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},o=this._buildArgs([e],n,void 0,s),a=this._makeSubscription({callback:(c,d)=>{t(c,d);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=k(e,Ji);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Te{constructor(e){this._keypair=void 0,this._keypair=e??_r()}static generate(){return new Te(_r())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const n=e.slice(0,32),s=kt(n);for(let o=0;o<32;o++)if(r[o]!==s[o])throw new Error("provided secretKey is invalid")}return new Te({publicKey:r,secretKey:e})}static fromSeed(e){const t=kt(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Te({publicKey:t,secretKey:r})}get publicKey(){return new h(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Pe=Object.freeze({CreateLookupTable:{index:0,layout:A([_("instruction"),je("recentSlot"),U("bumpSeed")])},FreezeLookupTable:{index:1,layout:A([_("instruction")])},ExtendLookupTable:{index:2,layout:A([_("instruction"),je(),se(W(),ze(_(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:A([_("instruction")])},CloseLookupTable:{index:4,layout:A([_("instruction")])}});class Ao{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=_("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(Pe))if(s.index==t){r=n;break}if(!r)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return r}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=V(Pe.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=V(Pe.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(r=>new h(r))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(cr.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class cr{constructor(){}static createLookupTable(e){const[t,r]=h.findProgramAddressSync([e.authority.toBuffer(),$r(BigInt(e.recentSlot),8)],this.programId),n=Pe.CreateLookupTable,s=O(n,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:H.programId,isSigner:!1,isWritable:!1}];return[new F({programId:this.programId,keys:o,data:s}),t]}static freezeLookupTable(e){const t=Pe.FreezeLookupTable,r=O(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new F({programId:this.programId,keys:n,data:r})}static extendLookupTable(e){const t=Pe.ExtendLookupTable,r=O(t,{addresses:e.addresses.map(s=>s.toBytes())}),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&n.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:H.programId,isSigner:!1,isWritable:!1}),new F({programId:this.programId,keys:n,data:r})}static deactivateLookupTable(e){const t=Pe.DeactivateLookupTable,r=O(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new F({programId:this.programId,keys:n,data:r})}static closeLookupTable(e){const t=Pe.CloseLookupTable,r=O(t),n=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new F({programId:this.programId,keys:n,data:r})}}cr.programId=new h("AddressLookupTab1e1111111111111111111111111");class _o{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=U("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(be))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=V(be.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=V(be.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=V(be.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=V(be.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(ur.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const be=Object.freeze({RequestUnits:{index:0,layout:A([U("instruction"),_("units"),_("additionalFee")])},RequestHeapFrame:{index:1,layout:A([U("instruction"),_("bytes")])},SetComputeUnitLimit:{index:2,layout:A([U("instruction"),_("units")])},SetComputeUnitPrice:{index:3,layout:A([U("instruction"),je("microLamports")])}});class ur{constructor(){}static requestUnits(e){const t=be.RequestUnits,r=O(t,e);return new F({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const t=be.RequestHeapFrame,r=O(t,e);return new F({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const t=be.SetComputeUnitLimit,r=O(t,e);return new F({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const t=be.SetComputeUnitPrice,r=O(t,{microLamports:BigInt(e.microLamports)});return new F({keys:[],programId:this.programId,data:r})}}ur.programId=new h("ComputeBudget111111111111111111111111111111");const Rr=64,zr=32,Kr=64,Wr=A([U("numSignatures"),U("padding"),pe("signatureOffset"),pe("signatureInstructionIndex"),pe("publicKeyOffset"),pe("publicKeyInstructionIndex"),pe("messageDataOffset"),pe("messageDataSize"),pe("messageInstructionIndex")]);class Et{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,instructionIndex:s}=e;M(t.length===zr,`Public Key must be ${zr} bytes but received ${t.length} bytes`),M(n.length===Kr,`Signature must be ${Kr} bytes but received ${n.length} bytes`);const o=Wr.span,a=o+t.length,c=a+n.length,d=1,p=x.Buffer.alloc(c+r.length),m=s??65535;return Wr.encode({numSignatures:d,padding:0,signatureOffset:a,signatureInstructionIndex:m,publicKeyOffset:o,publicKeyInstructionIndex:m,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:m},p),p.fill(t,o),p.fill(n,a),p.fill(r,c),new F({keys:[],programId:Et.programId,data:p})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;M(t.length===Rr,`Private key must be ${Rr} bytes but received ${t.length} bytes`);try{const s=Te.fromSecretKey(t),o=s.publicKey.toBytes(),a=Zt(r,s.secretKey);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:a,instructionIndex:n})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}Et.programId=new h("Ed25519SigVerify111111111111111111111111111");const Po=(i,e)=>{const t=jt.sign(i,e);return[t.toCompactRawBytes(),t.recovery]};jt.utils.isValidPrivateKey;const Eo=jt.getPublicKey,Or=32,Nt=20,Nr=64,Bo=11,Mt=A([U("numSignatures"),pe("signatureOffset"),U("signatureInstructionIndex"),pe("ethAddressOffset"),U("ethAddressInstructionIndex"),pe("messageDataOffset"),pe("messageDataSize"),U("messageInstructionIndex"),Y(20,"ethAddress"),Y(64,"signature"),U("recoveryId")]);class Ke{constructor(){}static publicKeyToEthAddress(e){M(e.length===Nr,`Public key must be ${Nr} bytes but received ${e.length} bytes`);try{return x.Buffer.from(vr(K(e))).slice(-Nt)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:s,instructionIndex:o}=e;return Ke.createInstructionWithEthAddress({ethAddress:Ke.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:s,instructionIndex:o})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:n,recoveryId:s,instructionIndex:o=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=x.Buffer.from(t.substr(2),"hex"):a=x.Buffer.from(t,"hex"):a=t,M(a.length===Nt,`Address must be ${Nt} bytes but received ${a.length} bytes`);const c=1+Bo,d=c,p=c+a.length,m=p+n.length+1,y=1,l=x.Buffer.alloc(Mt.span+r.length);return Mt.encode({numSignatures:y,signatureOffset:p,signatureInstructionIndex:o,ethAddressOffset:d,ethAddressInstructionIndex:o,messageDataOffset:m,messageDataSize:r.length,messageInstructionIndex:o,signature:K(n),ethAddress:K(a),recoveryId:s},l),l.fill(K(r),Mt.span),new F({keys:[],programId:Ke.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;M(t.length===Or,`Private key must be ${Or} bytes but received ${t.length} bytes`);try{const s=K(t),o=Eo(s,!1).slice(1),a=x.Buffer.from(vr(K(r))),[c,d]=Po(a,s);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:c,recoveryId:d,instructionIndex:n})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}Ke.programId=new h("KeccakSecp256k11111111111111111111111111111");var yn;const fn=new h("StakeConfig11111111111111111111111111111111");class bn{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class gt{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}yn=gt;gt.default=new yn(0,0,h.default);class xo{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=_("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(te))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a StakeInstruction");return r}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:r}=V(te.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new bn(new h(t.staker),new h(t.withdrawer)),lockup:new gt(r.unixTimestamp,r.epoch,new h(r.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),V(te.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:r}=V(te.Authorize,e.data),n={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new h(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(n.custodianPubkey=e.keys[3].pubkey),n}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:r,authoritySeed:n,authorityOwner:s}=V(te.AuthorizeWithSeed,e.data),o={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:n,authorityOwner:new h(s),newAuthorizedPubkey:new h(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(o.custodianPubkey=e.keys[3].pubkey),o}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=V(te.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),V(te.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=V(te.Withdraw,e.data),r={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(r.custodianPubkey=e.keys[5].pubkey),r}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),V(te.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(Bt.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const te=Object.freeze({Initialize:{index:0,layout:A([_("instruction"),Cs(),Ls()])},Authorize:{index:1,layout:A([_("instruction"),W("newAuthorized"),_("stakeAuthorizationType")])},Delegate:{index:2,layout:A([_("instruction")])},Split:{index:3,layout:A([_("instruction"),le("lamports")])},Withdraw:{index:4,layout:A([_("instruction"),le("lamports")])},Deactivate:{index:5,layout:A([_("instruction")])},Merge:{index:7,layout:A([_("instruction")])},AuthorizeWithSeed:{index:8,layout:A([_("instruction"),W("newAuthorized"),_("stakeAuthorizationType"),Re("authoritySeed"),W("authorityOwner")])}}),To=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Bt{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,s=n||gt.default,o=te.Initialize,a=O(o,{authorized:{staker:K(r.staker.toBuffer()),withdrawer:K(r.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:K(s.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:he,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new F(c)}static createAccountWithSeed(e){const t=new N;t.add(H.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static createAccount(e){const t=new N;t.add(H.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,s=te.Delegate,o=O(s);return new N().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:ae,isSigner:!1,isWritable:!1},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:fn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:s,custodianPubkey:o}=e,a=te.Authorize,c=O(a,{newAuthorized:K(n.toBuffer()),stakeAuthorizationType:s.index}),d=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ae,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&d.push({pubkey:o,isSigner:!0,isWritable:!1}),new N().add({keys:d,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:s,newAuthorizedPubkey:o,stakeAuthorizationType:a,custodianPubkey:c}=e,d=te.AuthorizeWithSeed,p=O(d,{newAuthorized:K(o.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:n,authorityOwner:K(s.toBuffer())}),m=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:ae,isSigner:!1,isWritable:!1}];return c&&m.push({pubkey:c,isSigner:!0,isWritable:!1}),new N().add({keys:m,programId:this.programId,data:p})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:s}=e,o=te.Split,a=O(o,{lamports:s});return new F({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){const r=new N;return r.add(H.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,basePubkey:o,seed:a,lamports:c}=e,d=new N;return d.add(H.allocate({accountPubkey:s,basePubkey:o,seed:a,space:this.space,programId:this.programId})),t&&t>0&&d.add(H.transfer({fromPubkey:e.authorizedPubkey,toPubkey:s,lamports:t})),d.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,lamports:c}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,s=te.Merge,o=O(s);return new N().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:ae,isSigner:!1,isWritable:!1},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:s,custodianPubkey:o}=e,a=te.Withdraw,c=O(a,{lamports:s}),d=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:ae,isSigner:!1,isWritable:!1},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&d.push({pubkey:o,isSigner:!0,isWritable:!1}),new N().add({keys:d,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=te.Deactivate,s=O(n);return new N().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ae,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}}Bt.programId=new h("Stake11111111111111111111111111111111111111");Bt.space=200;class kn{constructor(e,t,r,n){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=r,this.commission=n}}class Co{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=_("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(ke))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a VoteInstruction");return r}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=V(ke.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new kn(new h(t.nodePubkey),new h(t.authorizedVoter),new h(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:r}=V(ke.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new h(t),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:r,newAuthorized:n,voteAuthorizationType:s}}=V(ke.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new h(t),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new h(n),voteAuthorizationType:{index:s},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=V(ke.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Xe.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ke=Object.freeze({InitializeAccount:{index:0,layout:A([_("instruction"),Rs()])},Authorize:{index:1,layout:A([_("instruction"),W("newAuthorized"),_("voteAuthorizationType")])},Withdraw:{index:3,layout:A([_("instruction"),le("lamports")])},UpdateValidatorIdentity:{index:4,layout:A([_("instruction")])},AuthorizeWithSeed:{index:10,layout:A([_("instruction"),zs()])}}),Lo=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Xe{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,s=ke.InitializeAccount,o=O(s,{voteInit:{nodePubkey:K(n.nodePubkey.toBuffer()),authorizedVoter:K(n.authorizedVoter.toBuffer()),authorizedWithdrawer:K(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:he,isSigner:!1,isWritable:!1},{pubkey:ae,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new F(a)}static createAccount(e){const t=new N;return t.add(H.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:s}=e,o=ke.Authorize,a=O(o,{newAuthorized:K(n.toBuffer()),voteAuthorizationType:s.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ae,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new N().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:s,voteAuthorizationType:o,votePubkey:a}=e,c=ke.AuthorizeWithSeed,d=O(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:K(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:K(s.toBuffer()),voteAuthorizationType:o.index}}),p=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:ae,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new N().add({keys:p,programId:this.programId,data:d})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:s}=e,o=ke.Withdraw,a=O(o,{lamports:n}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return new N().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return Xe.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,s=ke.UpdateValidatorIdentity,o=O(s),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new N().add({keys:a,programId:this.programId,data:o})}}Xe.programId=new h("Vote111111111111111111111111111111111111111");Xe.space=3762;const wn=new h("Va1idator1nfo111111111111111111111111111111"),Ro=g({name:b(),website:T(b()),details:T(b()),keybaseUsername:T(b())});class dr{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(ie(t)!==2)return null;const r=[];for(let n=0;n<2;n++){const s=new h(oe(t,0,we)),o=fe(t)===1;r.push({publicKey:s,isSigner:o})}if(r[0].publicKey.equals(wn)&&r[1].isSigner){const n=Re().decode(x.Buffer.from(t)),s=JSON.parse(n);return Fr(s,Ro),new dr(r[1].publicKey,s)}return null}}const zo=new h("Vote111111111111111111111111111111111111111"),Ko=A([W("nodePubkey"),W("authorizedWithdrawer"),U("commission"),ne(),se(A([ne("slot"),_("confirmationCount")]),ze(_(),-8),"votes"),U("rootSlotValid"),ne("rootSlot"),ne(),se(A([ne("epoch"),W("authorizedVoter")]),ze(_(),-8),"authorizedVoters"),A([se(A([W("authorizedPubkey"),ne("epochOfLastAuthorizedSwitch"),ne("targetEpoch")]),32,"buf"),ne("idx"),U("isEmpty")],"priorVoters"),ne(),se(A([ne("epoch"),ne("credits"),ne("prevCredits")]),ze(_(),-8),"epochCredits"),A([ne("slot"),ne("timestamp")],"lastTimestamp")]);class lr{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const t=Ko.decode(K(e),4);let r=t.rootSlot;return t.rootSlotValid||(r=null),new lr({nodePubkey:new h(t.nodePubkey),authorizedWithdrawer:new h(t.authorizedWithdrawer),commission:t.commission,votes:t.votes,rootSlot:r,authorizedVoters:t.authorizedVoters.map(Wo),priorVoters:Oo(t.priorVoters),epochCredits:t.epochCredits,lastTimestamp:t.lastTimestamp})}}function Wo({authorizedVoter:i,epoch:e}){return{epoch:e,authorizedVoter:new h(i)}}function Mr({authorizedPubkey:i,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new h(i),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function Oo({buf:i,idx:e,isEmpty:t}){return t?[]:[...i.slice(e+1).map(Mr),...i.slice(0,e).map(Mr)]}const Ur={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function No(i,e){const t=e===!1?"http":"https";if(!i)return Ur[t].devnet;const r=Ur[t][i];if(!r)throw new Error(`Unknown ${t} cluster: ${i}`);return r}async function Mo(i,e,t,r){let n,s;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(n=t,s=r):s=t;const o=s&&{skipPreflight:s.skipPreflight,preflightCommitment:s.preflightCommitment||s.commitment,minContextSlot:s.minContextSlot},a=await i.sendRawTransaction(e,o),c=s&&s.commitment,d=(await(n?i.confirmTransaction(n,c):i.confirmTransaction(a,c))).value;if(d.err)throw new Error(`Raw transaction ${a} failed (${JSON.stringify(d)})`);return a}const Uo=1e9,qo=Object.freeze(Object.defineProperty({__proto__:null,Account:Bs,AddressLookupTableAccount:$t,AddressLookupTableInstruction:Ao,AddressLookupTableProgram:cr,Authorized:bn,BLOCKHASH_CACHE_TIMEOUT_MS:on,BPF_LOADER_DEPRECATED_PROGRAM_ID:xs,BPF_LOADER_PROGRAM_ID:js,BpfLoader:Gs,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:be,ComputeBudgetInstruction:_o,ComputeBudgetProgram:ur,Connection:vo,Ed25519Program:Et,Enum:Ps,EpochSchedule:nn,FeeCalculatorLayout:tn,Keypair:Te,LAMPORTS_PER_SOL:Uo,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:Pe,Loader:Oe,Lockup:gt,MAX_SEED_LENGTH:Yr,Message:ye,MessageAccountKeys:ot,MessageV0:We,NONCE_ACCOUNT_LENGTH:qt,NonceAccount:At,PACKET_DATA_SIZE:xe,PUBLIC_KEY_LENGTH:we,PublicKey:h,SIGNATURE_LENGTH_IN_BYTES:it,SOLANA_SCHEMA:nt,STAKE_CONFIG_ID:fn,STAKE_INSTRUCTION_LAYOUTS:te,SYSTEM_INSTRUCTION_LAYOUTS:j,SYSVAR_CLOCK_PUBKEY:ae,SYSVAR_EPOCH_SCHEDULE_PUBKEY:Ms,SYSVAR_INSTRUCTIONS_PUBKEY:en,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:yt,SYSVAR_RENT_PUBKEY:he,SYSVAR_REWARDS_PUBKEY:Us,SYSVAR_SLOT_HASHES_PUBKEY:qs,SYSVAR_SLOT_HISTORY_PUBKEY:Vs,SYSVAR_STAKE_HISTORY_PUBKEY:ft,Secp256k1Program:Ke,SendTransactionError:Vt,SolanaJSONRPCError:P,SolanaJSONRPCErrorCode:ei,StakeAuthorizationLayout:To,StakeInstruction:xo,StakeProgram:Bt,Struct:Qt,SystemInstruction:Fs,SystemProgram:H,Transaction:N,TransactionExpiredBlockheightExceededError:er,TransactionExpiredNonceInvalidError:De,TransactionExpiredTimeoutError:tr,TransactionInstruction:F,TransactionMessage:nr,TransactionStatus:_e,VALIDATOR_INFO_KEY:wn,VERSION_PREFIX_MASK:It,VOTE_PROGRAM_ID:zo,ValidatorInfo:dr,VersionedMessage:rr,VersionedTransaction:sr,VoteAccount:lr,VoteAuthorizationLayout:Lo,VoteInit:kn,VoteInstruction:Co,VoteProgram:Xe,clusterApiUrl:No,sendAndConfirmRawTransaction:Mo,sendAndConfirmTransaction:Ut},Symbol.toStringTag,{value:"Module"})),Sn=[{name:"discriminator",binary:"bytes",size:4},{name:"consistencyLevel",binary:"uint",size:1,endianness:"little"},{name:"emitterAuthority",...Sr},{name:"messageStatus",binary:"uint",size:1,endianness:"little"},{name:"gap",binary:"uint",size:3},{name:"timestamp",binary:"uint",size:4,endianness:"little"},{name:"nonce",binary:"uint",size:4,endianness:"little"},{name:"sequence",binary:"uint",size:8,endianness:"little"},{name:"emitterChain",binary:"uint",size:2,endianness:"little"},{name:"emitterAddress",...Sr},{name:"payloadLength",binary:"uint",size:4,endianness:"little"},{name:"payload",binary:"bytes"}];function In(i){return Gn(Sn,i)}function Ze(i,e,t,r){const n=typeof e=="string"?$.Buffer.from(e,"hex"):$.Buffer.from(e);if(n.length!=32)throw Error("address.length != 32");const s=$.Buffer.alloc(8);return s.writeBigUInt64BE(typeof r=="number"?BigInt(r):r),Ee([n,(()=>{const o=$.Buffer.alloc(2);return o.writeUInt16BE(t),o})(),s],i)}async function Vo(i,e,t,r,n,s){return i.getAccountInfo(Ze(e,t,r,n),s).then(o=>!!ut(o)[0])}function ve(i){return Ee([$.Buffer.from("Bridge")],i)}async function vn(i,e,t){return i.getAccountInfo(ve(e),t).then(r=>Tt.deserialize(ut(r)))}class xt{constructor(e,t){q(this,"guardianSetExpirationTime"),q(this,"fee"),this.guardianSetExpirationTime=e,this.fee=t}static deserialize(e){if(e.length!=12)throw new Error("data.length != 12");const t=e.readUInt32LE(0),r=e.readBigUInt64LE(4);return new xt(t,r)}}class Tt{constructor(e,t,r){q(this,"guardianSetIndex"),q(this,"lastLamports"),q(this,"config"),this.guardianSetIndex=e,this.lastLamports=t,this.config=r}static deserialize(e){if(e.length!=24)throw new Error("data.length != 24");const t=e.readUInt32LE(0),r=e.readBigUInt64LE(4),n=xt.deserialize(e.subarray(12));return new Tt(t,r,n)}}function Ct(i,e){return Ee([$.Buffer.from("Sequence"),new h(i).toBytes()],e)}async function An(i,e,t,r){return i.getAccountInfo(Ct(e,t),r).then(n=>Lt.deserialize(ut(n)))}class Lt{constructor(e,t,r){q(this,"sequence"),q(this,"bump"),q(this,"emitterType"),this.sequence=e,this.bump=t,this.emitterType=r}static deserialize(e){if(e.length!==8&&e.length!==10)throw new Error("data.length != 8 or data.length != 10");let t,r;const n=e.readBigUInt64LE(0);return e.length===10&&(t=e[8],r=e[9]),new Lt(n,t,r)}value(){return this.sequence}}function hr(i){return Ee([$.Buffer.from("emitter")],i)}function gr(i,e){const t=hr(i);return{emitter:t,sequence:Ct(t,e)}}async function $o(i,e,t,r){return An(i,hr(e),t,r)}function Qe(i){return Ee([$.Buffer.from("fee_collector")],i)}const qr=65,st=20;function Do(i,e,t){return new F({keys:[],programId:Ke.programId,data:Fo.serialize(i,e,t)})}class Fo{static serialize(e,t,r){if(e.length==0)throw Error("signatures.length == 0");if(e.length!=t.length)throw Error("signatures.length != keys.length");if(r.length!=32)throw Error("message.length != 32");const n=e.length,s=11,o=1+n*s,a=qr+st,c=o+n*a,d=32,p=$.Buffer.alloc(c+d);p.writeUInt8(n,0),p.write(r.toString("hex"),c,"hex");for(let m=0;m<n;++m){const y=e.at(m);if((y==null?void 0:y.length)!=qr)throw Error(`signatures[${m}].length != 65`);const l=t.at(m);if((l==null?void 0:l.length)!=st)throw Error(`keys[${m}].length != 20`);const I=o+a*m,f=I+65;p.writeUInt16LE(I,1+m*s),p.writeUInt8(0,3+m*s),p.writeUInt16LE(f,4+m*s),p.writeUInt8(0,6+m*s),p.writeUInt16LE(c,7+m*s),p.writeUInt16LE(d,9+m*s),p.writeUInt8(0,10+m*s),p.write(y.toString("hex"),I,"hex"),p.write(l.toString("hex"),f,"hex")}return p}}function Ne(i,e){return Ee([$.Buffer.from("GuardianSet"),(()=>{const t=$.Buffer.alloc(4);return t.writeUInt32BE(e),t})()],i)}async function pr(i,e,t,r){return i.getAccountInfo(Ne(e,t),r).then(n=>Rt.deserialize(ut(n)))}class Rt{constructor(e,t,r,n){q(this,"index"),q(this,"keys"),q(this,"creationTime"),q(this,"expirationTime"),this.index=e,this.keys=t,this.creationTime=r,this.expirationTime=n}static deserialize(e){const t=e.readUInt32LE(0),r=e.readUInt32LE(4),n=8+r*st,s=e.readUInt32LE(n),o=e.readUInt32LE(4+n),a=[];for(let c=0;c<r;++c){const d=8+c*st;a.push(e.subarray(d,d+st))}return new Rt(t,a,s,o)}}function Ve(i,e){return Ee([$.Buffer.from("PostedVAA"),e],i)}async function Ho(i,e,t){return i.getAccountInfo(new h(e),t).then(r=>zt.deserialize(ut(r)))}class zt{constructor(e,t,r){q(this,"signatures"),q(this,"hash"),q(this,"guardianSetIndex"),this.signatures=e,this.hash=t,this.guardianSetIndex=r}static deserialize(e){const t=e.readUInt32LE(0),r=[...e.subarray(4,4+t)].map(a=>a!=0),n=4+t,s=e.subarray(n,n+32),o=e.readUInt32LE(n+32);return new zt(r,s,o)}}function _n(i){return Ee([$.Buffer.from("upgrade")],i)}function Pn(i,e,t){return H.transfer({fromPubkey:new h(e),toPubkey:Qe(i),lamports:t})}class jo{constructor(e){q(this,"idl"),this.idl=e}async encode(e,t){switch(e){default:throw new Error(`Invalid account name: ${e}`)}}decode(e,t){return this.decodeUnchecked(e,t)}decodeUnchecked(e,t){switch(e){default:throw new Error(`Invalid account name: ${e}`)}}memcmp(e,t){switch(e){case"postVaa":return{dataSize:56};default:throw new Error(`Invalid account name: ${e}`)}}size(e){return Dr(this.idl,e)??0}}class Go{constructor(e){}decode(e){throw new Error("Wormhole program does not have events")}}var J={};const Jo=ts(qo);(function(i){var e=kr&&kr.__importDefault||function(C){return C&&C.__esModule?C:{default:C}};Object.defineProperty(i,"__esModule",{value:!0}),i.map=i.array=i.rustEnum=i.str=i.vecU8=i.tagged=i.vec=i.bool=i.option=i.publicKey=i.i256=i.u256=i.i128=i.u128=i.i64=i.u64=i.struct=i.f64=i.f32=i.i32=i.u32=i.i16=i.u16=i.i8=i.u8=void 0;const t=Ir,r=Jo,n=e(Hn);var s=Ir;Object.defineProperty(i,"u8",{enumerable:!0,get:function(){return s.u8}}),Object.defineProperty(i,"i8",{enumerable:!0,get:function(){return s.s8}}),Object.defineProperty(i,"u16",{enumerable:!0,get:function(){return s.u16}}),Object.defineProperty(i,"i16",{enumerable:!0,get:function(){return s.s16}}),Object.defineProperty(i,"u32",{enumerable:!0,get:function(){return s.u32}}),Object.defineProperty(i,"i32",{enumerable:!0,get:function(){return s.s32}}),Object.defineProperty(i,"f32",{enumerable:!0,get:function(){return s.f32}}),Object.defineProperty(i,"f64",{enumerable:!0,get:function(){return s.f64}}),Object.defineProperty(i,"struct",{enumerable:!0,get:function(){return s.struct}});class o extends t.Layout{constructor(v,E,L){super(v,L),this.blob=(0,t.blob)(v),this.signed=E}decode(v,E=0){const L=new n.default(this.blob.decode(v,E),10,"le");return this.signed?L.fromTwos(this.span*8).clone():L}encode(v,E,L=0){return this.signed&&(v=v.toTwos(this.span*8)),this.blob.encode(v.toArrayLike($.Buffer,"le",this.span),E,L)}}function a(C){return new o(8,!1,C)}i.u64=a;function c(C){return new o(8,!0,C)}i.i64=c;function d(C){return new o(16,!1,C)}i.u128=d;function p(C){return new o(16,!0,C)}i.i128=p;function m(C){return new o(32,!1,C)}i.u256=m;function y(C){return new o(32,!0,C)}i.i256=y;class l extends t.Layout{constructor(v,E,L,Q){super(v.span,Q),this.layout=v,this.decoder=E,this.encoder=L}decode(v,E){return this.decoder(this.layout.decode(v,E))}encode(v,E,L){return this.layout.encode(this.encoder(v),E,L)}getSpan(v,E){return this.layout.getSpan(v,E)}}function I(C){return new l((0,t.blob)(32),v=>new r.PublicKey(v),v=>v.toBuffer(),C)}i.publicKey=I;class f extends t.Layout{constructor(v,E){super(-1,E),this.layout=v,this.discriminator=(0,t.u8)()}encode(v,E,L=0){return v==null?this.discriminator.encode(0,E,L):(this.discriminator.encode(1,E,L),this.layout.encode(v,E,L+1)+1)}decode(v,E=0){const L=this.discriminator.decode(v,E);if(L===0)return null;if(L===1)return this.layout.decode(v,E+1);throw new Error("Invalid option "+this.property)}getSpan(v,E=0){const L=this.discriminator.decode(v,E);if(L===0)return 1;if(L===1)return this.layout.getSpan(v,E+1)+1;throw new Error("Invalid option "+this.property)}}function B(C,v){return new f(C,v)}i.option=B;function R(C){return new l((0,t.u8)(),D,ge,C)}i.bool=R;function D(C){if(C===0)return!1;if(C===1)return!0;throw new Error("Invalid bool: "+C)}function ge(C){return C?1:0}function $e(C,v){const E=(0,t.u32)("length"),L=(0,t.struct)([E,(0,t.seq)(C,(0,t.offset)(E,-E.span),"values")]);return new l(L,({values:Q})=>Q,Q=>({values:Q}),v)}i.vec=$e;function Mn(C,v,E){const L=(0,t.struct)([a("tag"),v.replicate("data")]);function Q({tag:de,data:Fn}){if(!de.eq(C))throw new Error("Invalid tag, expected: "+C.toString("hex")+", got: "+de.toString("hex"));return Fn}return new l(L,Q,de=>({tag:C,data:de}),E)}i.tagged=Mn;function br(C){const v=(0,t.u32)("length"),E=(0,t.struct)([v,(0,t.blob)((0,t.offset)(v,-v.span),"data")]);return new l(E,({data:L})=>L,L=>({data:L}),C)}i.vecU8=br;function Un(C){return new l(br(),v=>v.toString("utf-8"),v=>$.Buffer.from(v,"utf-8"),C)}i.str=Un;function qn(C,v,E){const L=(0,t.union)(E??(0,t.u8)(),v);return C.forEach((Q,de)=>L.addVariant(de,Q,Q.property)),L}i.rustEnum=qn;function Vn(C,v,E){const L=(0,t.struct)([(0,t.seq)(C,v,"values")]);return new l(L,({values:Q})=>Q,Q=>({values:Q}),E)}i.array=Vn;class $n extends t.Layout{constructor(v,E,L){super(v.span+E.span,L),this.keyLayout=v,this.valueLayout=E}decode(v,E){E=E||0;const L=this.keyLayout.decode(v,E),Q=this.valueLayout.decode(v,E+this.keyLayout.getSpan(v,E));return[L,Q]}encode(v,E,L){L=L||0;const Q=this.keyLayout.encode(v[0],E,L),de=this.valueLayout.encode(v[1],E,L+Q);return Q+de}getSpan(v,E){return this.keyLayout.getSpan(v,E)+this.valueLayout.getSpan(v,E)}}function Dn(C,v,E){const L=(0,t.u32)("length"),Q=(0,t.struct)([L,(0,t.seq)(new $n(C,v),(0,t.offset)(L,-L.span),"values")]);return new l(Q,({values:de})=>new Map(de),de=>({values:Array.from(de.entries())}),E)}i.map=Dn})(J);class Fe{static fieldLayout(e,t){const r=e.name!==void 0?tt(e.name):void 0;switch(e.type){case"bool":return J.bool(r);case"u8":return J.u8(r);case"i8":return J.i8(r);case"u16":return J.u16(r);case"i16":return J.i16(r);case"u32":return J.u32(r);case"i32":return J.i32(r);case"f32":return J.f32(r);case"u64":return J.u64(r);case"i64":return J.i64(r);case"f64":return J.f64(r);case"u128":return J.u128(r);case"i128":return J.i128(r);case"u256":return J.u256(r);case"i256":return J.i256(r);case"bytes":return J.vecU8(r);case"string":return J.str(r);case"publicKey":return J.publicKey(r);default:{if("vec"in e.type)return J.vec(Fe.fieldLayout({name:void 0,type:e.type.vec},t),r);if("option"in e.type)return J.option(Fe.fieldLayout({name:void 0,type:e.type.option},t),r);if("array"in e.type){let n=e.type.array[0],s=e.type.array[1],o=Fe.fieldLayout({name:void 0,type:n},t);return J.array(o,s,r)}else throw new Error(`Not yet implemented: ${e}`)}}}}class mr{constructor(e){q(this,"ixLayout"),this.ixLayout=mr.parseIxLayout(e)}static parseIxLayout(e){const t=(e.instructions?e.instructions:[]).map(r=>{let n=r.args.map(o=>Fe.fieldLayout(o,Array.from([...e.accounts??[],...e.types??[]])));const s=tt(r.name);return[s,J.struct(n,s)]}).concat(e.instructions.map(r=>{let n=r.args.map(o=>Fe.fieldLayout(o,Array.from([...e.accounts??[],...e.types??[]])));const s=tt(r.name);return[s,J.struct(n,s)]}));return new Map(t)}encode(e,t){const r=$.Buffer.alloc(1e3),n=tt(e),s=this.ixLayout.get(n);if(!s)throw new Error(`Unknown method: ${n}`);const o=s.encode(t,r),a=r.slice(0,o);return Yo(St[ys(n)],a)}encodeState(e,t){throw new Error("Wormhole program does not have state")}decode(e,t="hex"){var r;typeof e=="string"&&(e=t==="hex"?$.Buffer.from(e,"hex"):rs.decode(e));let n=$.Buffer.from(e.slice(0,1)).readInt8(),s=$.Buffer.from(e.slice(1)),o=tt(St[n]??"");return this.ixLayout.get(o)?{data:(r=this.ixLayout.get(o))==null?void 0:r.decode(s),name:o}:null}}var St;(function(i){i[i.Initialize=0]="Initialize",i[i.PostMessage=1]="PostMessage",i[i.PostVaa=2]="PostVaa",i[i.SetFees=3]="SetFees",i[i.TransferFees=4]="TransferFees",i[i.UpgradeContract=5]="UpgradeContract",i[i.UpgradeGuardianSet=6]="UpgradeGuardianSet",i[i.VerifySignatures=7]="VerifySignatures",i[i.PostMessageUnreliable=8]="PostMessageUnreliable"})(St||(St={}));function Yo(i,e){const t=$.Buffer.alloc(1+(e===void 0?0:e.length));return t.writeUInt8(i,0),e!==void 0&&t.write(e.toString("hex"),1,"hex"),t}class Xo{constructor(e){}encode(e,t){throw new Error("Wormhole program does not have state")}decode(e){throw new Error("Wormhole program does not have state")}}class Zo{constructor(e){}encode(e,t){throw new Error("Wormhole program does not have user-defined types")}decode(e,t){throw new Error("Wormhole program does not have user-defined types")}}class Qo{constructor(e){q(this,"instruction"),q(this,"accounts"),q(this,"state"),q(this,"events"),q(this,"types"),this.instruction=new mr(e),this.accounts=new jo(e),this.state=new Xo(e),this.events=new Go(e),this.types=new Zo(e)}}const yr={version:"0.1.0",name:"wormhole",instructions:[{name:"initialize",accounts:[{name:"bridge",isMut:!0,isSigner:!1},{name:"guardianSet",isMut:!0,isSigner:!1},{name:"feeCollector",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"guardianSetExpirationTime",type:"u32"},{name:"fee",type:"u64"},{name:"initialGuardians",type:{vec:{array:["u8",20]}}}]},{name:"postMessage",accounts:[{name:"bridge",isMut:!0,isSigner:!1},{name:"message",isMut:!0,isSigner:!0},{name:"emitter",isMut:!1,isSigner:!0},{name:"sequence",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"feeCollector",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"nonce",type:"u32"},{name:"payload",type:"bytes"},{name:"consistencyLevel",type:"u8"}]},{name:"postVaa",accounts:[{name:"guardianSet",isMut:!1,isSigner:!1},{name:"bridge",isMut:!1,isSigner:!1},{name:"signatureSet",isMut:!1,isSigner:!1},{name:"vaa",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"version",type:"u8"},{name:"guardianSetIndex",type:"u32"},{name:"timestamp",type:"u32"},{name:"nonce",type:"u32"},{name:"emitterChain",type:"u16"},{name:"emitterAddress",type:{array:["u8",32]}},{name:"sequence",type:"u64"},{name:"consistencyLevel",type:"u8"},{name:"payload",type:"bytes"}]},{name:"setFees",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"bridge",isMut:!0,isSigner:!1},{name:"vaa",isMut:!1,isSigner:!1},{name:"claim",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"transferFees",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"bridge",isMut:!0,isSigner:!1},{name:"vaa",isMut:!1,isSigner:!1},{name:"claim",isMut:!0,isSigner:!1},{name:"feeCollector",isMut:!0,isSigner:!1},{name:"recipient",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"upgradeContract",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"bridge",isMut:!0,isSigner:!1},{name:"vaa",isMut:!1,isSigner:!1},{name:"claim",isMut:!0,isSigner:!1},{name:"upgradeAuthority",isMut:!1,isSigner:!1},{name:"spill",isMut:!0,isSigner:!1},{name:"implementation",isMut:!0,isSigner:!1},{name:"programData",isMut:!0,isSigner:!1},{name:"wormholeProgram",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"bpfLoaderUpgradeable",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"upgradeGuardianSet",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"bridge",isMut:!0,isSigner:!1},{name:"vaa",isMut:!1,isSigner:!1},{name:"claim",isMut:!0,isSigner:!1},{name:"guardianSetOld",isMut:!0,isSigner:!1},{name:"guardianSetNew",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"verifySignatures",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"guardianSet",isMut:!1,isSigner:!1},{name:"signatureSet",isMut:!0,isSigner:!0},{name:"instructions",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"signatureStatus",type:{array:["i8",19]}}]},{name:"postMessageUnreliable",accounts:[{name:"bridge",isMut:!0,isSigner:!1},{name:"message",isMut:!0,isSigner:!0},{name:"emitter",isMut:!1,isSigner:!0},{name:"sequence",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"feeCollector",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"nonce",type:"u32"},{name:"payload",type:"bytes"},{name:"consistencyLevel",type:"u8"}]}],accounts:[{name:"PostedMessage",type:{kind:"struct",fields:[{name:"vaaVersion",type:"u8"},{name:"consistencyLevel",type:"u8"},{name:"vaaTime",type:"u32"},{name:"vaaSignatureAccount",type:"publicKey"},{name:"submissionTime",type:"u32"},{name:"nonce",type:"u32"},{name:"sequence",type:"u64"},{name:"emitterChain",type:"u16"},{name:"emitterAddress",type:{array:["u8",32]}},{name:"payload",type:"bytes"}]}},{name:"PostedVAA",type:{kind:"struct",fields:[{name:"vaaVersion",type:"u8"},{name:"consistencyLevel",type:"u8"},{name:"vaaTime",type:"u32"},{name:"vaaSignatureAccount",type:"publicKey"},{name:"submissionTime",type:"u32"},{name:"nonce",type:"u32"},{name:"sequence",type:"u64"},{name:"emitterChain",type:"u16"},{name:"emitterAddress",type:{array:["u8",32]}},{name:"payload",type:"bytes"}]}}]};function En(i,e){return new es(yr,new h(i),e===void 0?{connection:null}:e,Bn())}function Ae(i,e){return En(i,os(e))}function Bn(){return new Qo(yr)}function ea(i,e,t,r){const n=Ae(e,i).methods.setFees();return n._ixFn(...n._args,{accounts:xn(e,t,r),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function xn(i,e,t){return{payer:new h(e),bridge:ve(i),vaa:Ve(i,$.Buffer.from(t.hash)),claim:Ze(i,t.emitterAddress.toString(),Ge(t.emitterChain),t.sequence),systemProgram:H.programId}}function ta(i,e,t,r,n){const s=Ae(e,i).methods.transferFees();return s._ixFn(...s._args,{accounts:Tn(e,t,r,n),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function Tn(i,e,t,r){return{payer:new h(e),bridge:ve(i),vaa:Ve(i,$.Buffer.from(r.hash)),claim:Ze(i,r.emitterAddress.toString(),Ge(r.emitterChain),r.sequence),feeCollector:Qe(i),recipient:new h(t),rent:he,systemProgram:H.programId}}function ra(i,e,t,r){const n=Ae(e,i).methods.upgradeGuardianSet();return n._ixFn(...n._args,{accounts:Cn(e,t,r),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function Cn(i,e,t){return{payer:new h(e),bridge:ve(i),vaa:Ve(i,$.Buffer.from(t.hash)),claim:Ze(i,t.emitterAddress.toString(),Ge(t.emitterChain),t.sequence),guardianSetOld:Ne(i,t.guardianSet),guardianSetNew:Ne(i,t.guardianSet+1),systemProgram:H.programId}}function na(i,e,t,r){const n=Ae(e,i).methods.upgradeContract();return n._ixFn(...n._args,{accounts:Ln(e,t,r),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function Ln(i,e,t,r){const{newContract:n}=t.payload;return{payer:new h(e),bridge:ve(i),vaa:Ve(i,$.Buffer.from(t.hash)),claim:Ze(i,t.emitterAddress.toString(),Ge(t.emitterChain),t.sequence),upgradeAuthority:_n(i),spill:new h(r===void 0?e:r),implementation:new mt(n).unwrap(),programData:ps(i),wormholeProgram:new h(i),rent:he,clock:ae,bpfLoaderUpgradeable:Gt.programId,systemProgram:H.programId}}function sa(i,e,t,r,n,s){const o=Ae(e,i).methods.initialize(r,new bt(n.toString()),[...s.map(a=>[...new Uint8Array(a)])]);return o._ixFn(...o._args,{accounts:Rn(e,t),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function Rn(i,e){return{bridge:ve(i),guardianSet:Ne(i,0),feeCollector:Qe(i),payer:new h(e),clock:ae,rent:he,systemProgram:H.programId}}function zn(i,e,t,r,n,s,o){const a=Ae(e,i).methods.postMessage(s,$.Buffer.from(n),o);return a._ixFn(...a._args,{accounts:fr(e,t,r),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function fr(i,e,t,r){let n;return r?{emitter:r,sequence:n}=gr(r,i):(r=e,n=Ct(r,i)),{bridge:ve(i),message:new h(t),emitter:new h(r),sequence:n,payer:new h(e),feeCollector:Qe(i),clock:ae,rent:he,systemProgram:H.programId}}function Kn(i,e,t,r,n){const s=Ae(e,i).methods.postVaa(1,r.guardianSet,r.timestamp,r.nonce,Ge(r.emitterChain),[...r.emitterAddress.toUint8Array()],new bt(r.sequence.toString()),r.consistencyLevel,$.Buffer.from(Jn(r.payloadLiteral,r.payload)));return s._ixFn(...s._args,{accounts:Wn(e,t,n,r),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function Wn(i,e,t,r){return{guardianSet:Ne(i,r.guardianSet),bridge:ve(i),signatureSet:new h(t),vaa:Ve(i,$.Buffer.from(r.hash)),payer:new h(e),clock:ae,rent:he,systemProgram:H.programId}}const ia=19;async function On(i,e,t,r,n,s){const o=r.guardianSet,a=await pr(i,e,o,s),c=r.signatures,d=a.keys,p=7,m=[];for(let y=0;y<Math.ceil(c.length/p);++y){const l=y*p,I=Math.min(c.length,(y+1)*p),f=new Array(ia).fill(-1),B=[],R=[];for(let D=0;D<I-l;++D){const ge=c.at(D+l);B.push($.Buffer.from(ge.signature.encode())),R.push(d.at(ge.guardianIndex)),f[ge.guardianIndex]=D}m.push(Do(B,R,$.Buffer.from(r.hash))),m.push(oa(i,e,t,r,n,f))}return m}function oa(i,e,t,r,n,s){const o=Ae(e,i).methods.verifySignatures(s);return o._ixFn(...o._args,{accounts:Nn(e,t,n,r),signers:void 0,remainingAccounts:void 0,preInstructions:void 0,postInstructions:void 0})}function Nn(i,e,t,r){return{payer:new h(e),guardianSet:Ne(i,r.guardianSet),signatureSet:new h(t),instructions:en,rent:he,systemProgram:H.programId}}function aa(i,e){const{emitter:t,sequence:r}=gr(i,e);return{wormholeBridge:ve(e),wormholeEmitter:t,wormholeSequence:r,wormholeFeeCollector:Qe(e)}}function ca(i,e,t,r){const n=fr(e,t,r,i);return{payer:n.payer,wormholeBridge:n.bridge,wormholeMessage:n.message,wormholeEmitter:n.emitter,wormholeSequence:n.sequence,wormholeFeeCollector:n.feeCollector,clock:n.clock,rent:n.rent,systemProgram:n.systemProgram}}const ua=Object.freeze(Object.defineProperty({__proto__:null,BridgeConfig:xt,BridgeData:Tt,GuardianSetData:Rt,SequenceTracker:Lt,SignatureSetData:zt,coder:Bn,createBridgeFeeTransferInstruction:Pn,createInitializeInstruction:sa,createPostMessageInstruction:zn,createPostVaaInstruction:Kn,createReadOnlyWormholeProgramInterface:Ae,createSetFeesInstruction:ea,createTransferFeesInstruction:ta,createUpgradeContractInstruction:na,createUpgradeGuardianSetInstruction:ra,createVerifySignaturesInstructions:On,createWormholeProgramInterface:En,deriveClaimKey:Ze,deriveEmitterSequenceKey:Ct,deriveFeeCollectorKey:Qe,deriveGuardianSetKey:Ne,derivePostedVaaKey:Ve,deriveUpgradeAuthorityKey:_n,deriveWormholeBridgeDataKey:ve,deriveWormholeEmitterKey:hr,getClaim:Vo,getEmitterKeys:gr,getGuardianSet:pr,getInitializeAccounts:Rn,getPostMessageAccounts:fr,getPostMessageCpiAccounts:ca,getPostVaaAccounts:Wn,getProgramSequenceTracker:$o,getSequenceTracker:An,getSetFeesAccounts:xn,getSignatureSetData:Ho,getTransferFeesAccounts:Tn,getUpgradeContractAccounts:Ln,getUpgradeGuardianSetAccounts:Cn,getVerifySignatureAccounts:Nn,getWormholeBridgeData:vn,getWormholeDerivedAccounts:aa},Symbol.toStringTag,{value:"Module"})),Vr="Program log: Sequence: ";class ct{constructor(e,t,r,n){q(this,"network"),q(this,"chain"),q(this,"connection"),q(this,"contracts"),q(this,"chainId"),q(this,"coreBridge"),q(this,"address"),q(this,"bridgeData"),this.network=e,this.chain=t,this.connection=r,this.contracts=n,this.chainId=Ge(t);const s=n.coreBridge;if(!s)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.address=s,this.coreBridge=Ae(s,r)}async getGuardianSet(e){const t=await pr(this.connection,this.coreBridge.programId,e);return{index:t.index,keys:t.keys.map(r=>r.toString("hex")),expiry:BigInt(t.expirationTime)}}static async fromRpc(e,t){const[r,n]=await as.chainFromRpc(e),s=t[n];if(s.network!==r)throw new Error(`Network mismatch for chain ${n}: ${s.network} != ${r}`);return new ct(r,n,e,t[n].contracts)}async ensureBridgeConfig(){this.bridgeData||(this.bridgeData=await vn(this.connection,this.coreBridge.programId))}async getMessageFee(){return await this.ensureBridgeConfig(),this.bridgeData.config.fee}async getGuardianSetIndex(){return await this.ensureBridgeConfig(),this.bridgeData.guardianSetIndex}async*publishMessage(e,t,r,n){const s=Te.generate(),o=new mt(e).unwrap(),a=zn(this.connection,this.coreBridge.programId,o,s.publicKey,t,r,n),c=await this.getMessageFee(),d=Pn(this.coreBridge.programId,o,c),p=new N;p.feePayer=o,p.add(d,a),yield this.createUnsignedTx({transaction:p,signers:[s]},"Core.PublishMessage")}async*verifyMessage(e,t){yield*this.postVaa(e,t)}async*postVaa(e,t){const r=Ve(this.coreBridge.programId,$.Buffer.from(t.hash));if(await this.connection.getAccountInfo(r))return;const n=new mt(e).unwrap(),s=Te.generate(),o=await On(this.connection,this.coreBridge.programId,n,t,s.publicKey);for(let c=0;c<o.length;c+=2){const d=new N().add(...o.slice(c,c+2));d.feePayer=n,yield this.createUnsignedTx({transaction:d,signers:[s]},"Core.VerifySignature",!0)}const a=new N().add(Kn(this.connection,this.coreBridge.programId,n,t,s.publicKey));a.feePayer=n,yield this.createUnsignedTx({transaction:a},"Core.PostVAA")}static parseSequenceFromLog(e,t){var r,n,s,o;const{meta:a,transaction:{message:c}}=t;if(!((r=a==null?void 0:a.innerInstructions)!=null&&r.length))return[];const d=c.staticAccountKeys;if(d.filter(y=>y.toString()===e).length===0)return[];const p=(o=(s=(n=a==null?void 0:a.logMessages)==null?void 0:n.filter(y=>y.startsWith(Vr)))==null?void 0:s[0])==null?void 0:o.replace(Vr,"");if(!p)return[];const m=[];for(const y of a==null?void 0:a.innerInstructions){const l=y.instructions;m.push(...l.filter(I=>I.programIdIndex in d&&d[I.programIdIndex].toString()===e))}return m.length<1?[]:d.length<3?[]:m.map(y=>[new mt(d[y.accounts[2]]).toUniversalAddress(),BigInt(p)]).filter(y=>y!==null)}async getMessageAccountKeys(e){let t;if(typeof e.transaction.message.version!="string")if(e.meta.loadedAddresses)t=e.transaction.message.getAccountKeys({accountKeysFromLookups:e.meta.loadedAddresses});else{const r=await Promise.all(e.transaction.message.addressTableLookups.map(async n=>{const s=await this.connection.getAddressLookupTable(n.accountKey);if(!s||!s.value)throw new Error("Could not resolve lookup table: "+n.accountKey.toBase58());return s.value}));t=e.transaction.message.getAccountKeys({addressLookupTableAccounts:r})}else t=e.transaction.message.getAccountKeys();return t}async findInstructions(e,t){var r;const{meta:n,transaction:{message:s}}=t,o=this.coreBridge.programId,a=(r=n.innerInstructions)==null?void 0:r.flatMap(d=>d.instructions.filter(p=>o.toString()===e.get(p.programIdIndex).toString())).map(d=>({programIdIndex:d.programIdIndex,accountKeyIndexes:d.accounts})),c=s.compiledInstructions.filter(d=>o.toString()===e.get(d.programIdIndex).toString());return[...a,...c]}async parsePostMessageAccount(e){const t=await this.connection.getAccountInfo(e);if(!(t!=null&&t.data))throw new Error("No data found in message account");const{timestamp:r,emitterAddress:n,emitterChain:s,consistencyLevel:o,sequence:a,nonce:c,payload:d}=In(new Uint8Array(t==null?void 0:t.data));return ds("Uint8Array",{guardianSet:await this.getGuardianSetIndex(),emitterChain:jn(s),timestamp:r,emitterAddress:n,consistencyLevel:o,sequence:a,nonce:c,payload:d,signatures:[]})}async parseTransaction(e){const t=await this.connection.getTransaction(e,{maxSupportedTransactionVersion:0});if(!t||!t.meta||!t.meta.innerInstructions)throw new Error("transaction not found");try{const o=ct.parseSequenceFromLog(this.coreBridge.programId.toBase58(),t);if(o.length>0){const[a,c]=o[0];return[{chain:this.chain,emitter:a,sequence:c}]}}catch{}const r=await this.getMessageAccountKeys(t),n=await this.findInstructions(r,t);if(!n||n.length===0)throw new Error("no bridge messages found");const s=n.map(async o=>{const a=r.get(o.accountKeyIndexes[1]),c=await this.parsePostMessageAccount(a);return{chain:c.emitterChain,emitter:c.emitterAddress,sequence:c.sequence}});return await Promise.all(s)}async parseMessages(e){const t=await this.connection.getTransaction(e,{maxSupportedTransactionVersion:0});if(!t||!t.meta||!t.meta.innerInstructions)throw new Error("transaction not found");const r=await this.getMessageAccountKeys(t),n=await this.findInstructions(r,t);if(!n||n.length===0)throw new Error("no bridge messages found");const s=n.map(async o=>{const a=r.get(o.accountKeyIndexes[1]);return await this.parsePostMessageAccount(a)});return await Promise.all(s)}createUnsignedTx(e,t,r=!1){return new cs(e,this.network,this.chain,t,r)}}ls(us,"WormholeCore",ct);const fa=Object.freeze(Object.defineProperty({__proto__:null,IDL:yr,SolanaWormholeCore:ct,deserializePostMessage:In,postMessageLayout:Sn,utils:ua},Symbol.toStringTag,{value:"Module"}));export{Gt as B,ct as S,Dr as a,ya as b,fr as c,Ee as d,Ve as e,Ze as f,ut as g,_n as h,ps as i,ca as j,aa as k,Vo as l,Pn as m,ma as n,fa as o};
