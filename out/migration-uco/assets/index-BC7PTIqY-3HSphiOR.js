import{A as O,S as A,a as J}from"./index-CqJuSw0V-HnIqbu9o.js";import{cE as X,bh as S,bz as H,ct as $,cF as E,cw as F,c3 as Q,aN as b,aG as Y,aS as K,cx as k,cy as x,cB as v,c4 as M,aK as Z,bK as L,cG as ee,cH as G,cI as te}from"./index-Bibw8odz.js";import{a as se,A as u,s as l,_ as oe}from"./algorand-C6Gy4I2H-PkWBrzVN.js";import{b as ne}from"./chain-DfK5JtF7-Jmo_aVnV.js";import"./create-D7FD56l0-D2uTFRvt.js";var re=Object.defineProperty,ae=(N,t,e)=>t in N?re(N,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):N[t]=e,c=(N,t,e)=>(ae(N,typeof t!="symbol"?t+"":t,e),e);const z=X.fromSignature("portal_transfer(byte[])byte[]"),C=class m{constructor(t,e,n,o){if(c(this,"network"),c(this,"chain"),c(this,"connection"),c(this,"contracts"),c(this,"chainId"),c(this,"coreBridge"),c(this,"coreAppId"),c(this,"coreAppAddress"),c(this,"tokenBridgeAppId"),c(this,"tokenBridgeAddress"),this.network=t,this.chain=e,this.connection=n,this.contracts=o,this.chainId=H(e),!o.coreBridge)throw new Error(`Core contract address for chain ${e} not found`);const r=BigInt(o.coreBridge);if(this.coreAppId=r,this.coreAppAddress=$(r),this.coreBridge=new O(t,e,n,o),!o.tokenBridge)throw new Error(`TokenBridge contract address for chain ${e} not found`);const s=BigInt(o.tokenBridge);this.tokenBridgeAppId=s,this.tokenBridgeAddress=$(s)}static async fromRpc(t,e){const[n,o]=await se.chainFromRpc(t),r=e[o];if(r.network!==n)throw new Error(`Network mismatch: ${r.network} != ${n}`);return new m(n,o,t,r.contracts)}async isWrappedAsset(t){const e=new u(t).toInt();if(e===0)return!1;const n=await this.connection.getAssetByID(e).do(),o=E.from_obj_for_encoding(n).params.creator,r=await this.connection.accountInformation(o).exclude("all").do(),s=F.from_obj_for_encoding(r);return(s==null?void 0:s.authAddr)===this.tokenBridgeAddress}async getOriginalAsset(t){const e=new u(t).toInt(),n=await this.connection.getAssetByID(e).do(),o=E.from_obj_for_encoding(n),r=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,o.params.creator);if(r.length<94)throw new Error("Invalid local state data");const s=r.slice(92,94),a=Q(b.decode(s)),p=new Y(r.slice(60,92));return{chain:a,address:p}}async getWrappedAsset(t){const e=A.forWrappedAsset(this.tokenBridgeAppId,t),n=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,e.address());if(n.length<8)throw new Error("Invalid wrapped asset data");return K(this.chain,b.decode(n.slice(0,8)).toString())}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedNative(){return K(this.chain,"0")}async isTransferCompleted(t){const e=A.forMessageId(this.tokenBridgeAppId,{sequence:t.sequence,chain:t.emitterChain,emitter:t.emitterAddress});try{return await A.checkBitsSet(this.connection,this.tokenBridgeAppId,e.address(),t.sequence)}catch{}return!1}async*createAttestation(t,e){if(!e)throw new Error("Payer required to create attestation");const n=new u(e).toString(),o=new u(t).toInt(),r=[],s=await this.connection.getTransactionParams().do(),a=A.forEmitter(this.coreAppId,new u(this.tokenBridgeAddress).toUint8Array()),{accounts:[p],txs:g}=await O.maybeCreateStorageTx(this.connection,n,this.coreAppId,a,s);r.push(...g);let B="",i;if(o!==0){const I=await this.connection.getAssetByID(o).do(),j=E.from_obj_for_encoding(I),U=await this.connection.accountInformation(j.params.creator).do();if(i=F.from_obj_for_encoding(U),i.authAddr===this.tokenBridgeAddress.toString())throw new Error("Cannot re-attest wormhole assets")}const T=A.forNativeAsset(this.tokenBridgeAppId,BigInt(o)),y=await O.maybeCreateStorageTx(this.connection,n,this.tokenBridgeAppId,T);B=y.accounts[0],r.push(...y.txs);const f=k({from:n,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[m.noop],suggestedParams:s});r.push({tx:f});const h=await this.coreBridge.getMessageFee();if(h>BigInt(0)){const I=v({from:n,suggestedParams:s,to:this.tokenBridgeAddress,amount:h});r.push({tx:I})}let _=[p,B,this.coreAppAddress];i&&_.push(i.address);let d=k({appArgs:[m.attestToken,b.toBytes(o,8)],accounts:_,appIndex:l(this.tokenBridgeAppId),foreignApps:[l(this.coreAppId)],foreignAssets:[o],from:n,onComplete:x.NoOpOC,suggestedParams:s});h>BigInt(0)?d.fee*=3:d.fee*=2,r.push({tx:d});for(const I of r)yield this.createUnsignedTx(I,"TokenBridge.createAttestation",!0)}async*submitAttestation(t,e,n){if(!e)throw new Error("Sender required to submit attestation");n||(n=await this.connection.getTransactionParams().do());const o=e.toString(),r=A.forWrappedAsset(this.tokenBridgeAppId,t.payload.token).address(),s=[],a=[],p=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,r);p.length>8&&a.push(new u(p.slice(0,8)).toInt()),s.push({tx:v({from:o,to:r,amount:1e5,suggestedParams:n})});let g=new Uint8Array(1);g[0]=1,s.push({tx:k({appArgs:[m.noop,g],appIndex:l(this.tokenBridgeAppId),from:o,onComplete:x.NoOpOC,suggestedParams:n})}),g=new Uint8Array(1),g[0]=2,s.push({tx:k({appArgs:[m.noop,g],appIndex:l(this.tokenBridgeAppId),from:o,onComplete:x.NoOpOC,suggestedParams:n})}),s.push({tx:k({accounts:[],appArgs:[m.receiveAttest,M(t)],appIndex:l(this.tokenBridgeAppId),foreignAssets:a,from:o,onComplete:x.NoOpOC,suggestedParams:n})}),s[s.length-1].tx.fee=s[s.length-1].tx.fee*2;for(const B of s)yield this.createUnsignedTx(B,"TokenBridge.submitAttestation",!0)}async*transfer(t,e,n,o,r){const s=t.toString(),a=Z(n)?0:new u(n).toInt(),p=o,g=H(e.chain),B=e.address.toUniversalAddress().toUint8Array(),i=await this.connection.getTransactionParams().do(),T=BigInt(0),y=A.fromData({appId:this.coreAppId,appAddress:L(this.coreAppAddress).publicKey,idx:BigInt(0),address:L(this.tokenBridgeAddress).publicKey}),f=[],{accounts:[h],txs:_}=await O.maybeCreateStorageTx(this.connection,s,this.coreAppId,y,i);f.push(..._);let d="",I,j=!1;if(a!==0){const w=await this.connection.getAssetByID(a).do();d=E.from_obj_for_encoding(w).params.creator;const P=await this.connection.accountInformation(d).do();I=F.from_obj_for_encoding(P),j=I.authAddr===this.tokenBridgeAddress.toString()}const U=await this.coreBridge.getMessageFee();if(U>0&&f.push({tx:v({from:s,to:this.tokenBridgeAddress,amount:U,suggestedParams:i})}),!j){const w=A.forNativeAsset(this.tokenBridgeAppId,BigInt(a)),{accounts:[P],txs:D}=await O.maybeCreateStorageTx(this.connection,s,this.tokenBridgeAppId,w,i);d=P,D.push(...D)}if(a!==0&&!await m.isOptedInToAsset(this.connection,d,a)){const w=v({from:s,to:d,amount:1e5,suggestedParams:i});let P=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[m.optIn,ee(a,8)],foreignAssets:[a],accounts:[d],suggestedParams:i});P.fee*=2,f.unshift({tx:w},{tx:P})}const V=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:[m.noop],suggestedParams:i});f.push({tx:V});let W=[];if(a===0){const w=v({from:s,to:d,amount:p,suggestedParams:i});f.push({tx:w}),W=[h,d,d]}else{const w=G({from:s,to:d,amount:p,assetIndex:a,suggestedParams:i});f.push({tx:w}),W=I!=null&&I.address?[h,d,I.address]:[h,d]}const R=[m.sendTransfer,b.toBytes(a,8),b.toBytes(p,8),B,b.toBytes(g,8),b.toBytes(T,8)];r&&R.push(r);const q=k({from:s,appIndex:l(this.tokenBridgeAppId),onComplete:x.NoOpOC,appArgs:R,foreignApps:[l(this.coreAppId)],foreignAssets:[a],accounts:W,suggestedParams:i});q.fee*=2,f.push({tx:q});for(const w of f)yield this.createUnsignedTx(w,"TokenBridge.transfer",!0)}async*redeem(t,e,n=!0,o){o||(o=await this.connection.getTransactionParams().do());const r=new u(t).toString(),{accounts:s,txs:a}=await O.submitVAAHeader(this.connection,this.coreAppId,this.tokenBridgeAppId,e,r);let p,g="",B=[],i=0;if(e.payload.token.chain!==this.chain){p=A.forWrappedAsset(this.tokenBridgeAppId,e.payload.token),g=p.address();const h=await A.decodeLocalState(this.connection,this.tokenBridgeAppId,g);i=new u(h.slice(0,8)).toInt()}else{const h=new u(e.payload.token.address).toBigInt();p=A.forNativeAsset(this.tokenBridgeAppId,h),g=p.address(),i=l(h)}s.push(g);let T=0,y="";if(e.payloadName==="TransferWithPayload"?(T=new u(e.payload.to.address).toInt(),y=$(T)):y=new u(e.payload.to.address.toUint8Array()).toString(),s.push(y),i!==0&&(B.push(i),!await m.isOptedInToAsset(this.connection,y,i))){if(r!=y)throw new Error("Cannot ASA optin for somebody else (asset "+i.toString()+")");a.unshift({tx:G({amount:0,assetIndex:i,from:r,suggestedParams:o,to:r})})}const f={accounts:s,appArgs:[m.completeTransfer,M(e)],appIndex:l(this.tokenBridgeAppId),foreignAssets:B,from:r,onComplete:x.NoOpOC,suggestedParams:o};a.push({tx:k(f)}),a[a.length-1].tx.fee=a[a.length-1].tx.fee*(e.payloadName==="Transfer"&&e.payload.fee!==void 0&&e.payload.fee===0n?2:3),e.payloadName==="TransferWithPayload"&&(a[a.length-1].tx.appForeignApps=[T],a.push({tx:k({appArgs:[z.getSelector(),z.args[0].type.encode(M(e))],appIndex:T,foreignAssets:B,from:r,onComplete:x.NoOpOC,suggestedParams:o})}));for(const h of a)yield this.createUnsignedTx(h,"TokenBridge.redeem",!0)}static async isOptedInToAsset(t,e,n){var o;try{const r=await t.accountAssetInformation(e,n).do();return(((o=te.from_obj_for_encoding(r).assetHolding)==null?void 0:o.amount)??0)>0}catch{}return!1}createUnsignedTx(t,e,n=!0){return new J(t,this.network,this.chain,e,n)}};c(C,"sendTransfer",S.encode("sendTransfer")),c(C,"attestToken",S.encode("attestToken")),c(C,"noop",S.encode("nop")),c(C,"optIn",S.encode("optin")),c(C,"completeTransfer",S.encode("completeTransfer")),c(C,"receiveAttest",S.encode("receiveAttest"));let ie=C;ne(oe,"TokenBridge",ie);export{ie as AlgorandTokenBridge,z as TransferMethodSelector};
