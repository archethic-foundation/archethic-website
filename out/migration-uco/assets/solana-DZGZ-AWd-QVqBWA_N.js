const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-DKT3rJAB-BsTutSMp.js","assets/index-Bibw8odz.js","assets/index-BelLbmDI.css","assets/chain-DfK5JtF7-Jmo_aVnV.js","assets/index-C2SM05Vf-DrEj5SaI.js","assets/index-DpFNxVts-CtfGCFjC.js","assets/create-D7FD56l0-D2uTFRvt.js","assets/index-CS1RMSbZ-DZU5EiSz.js","assets/index-dElhxORT-B_cYUvUZ.js"])))=>i.map(i=>d[i]);
import{al as U,aU as de,q as C,aV as he,aW as M,aX as A,aY as I,aZ as D,a_ as P,a$ as $,b0 as ft,b1 as G,b2 as Ae,b3 as q,aE as tn,b4 as Bt,b5 as en,b6 as nn,b7 as sn,aG as ge,aF as Jt,aH as rn,aI as on,aJ as an,aK as Ht,aL as cn,aM as un,_ as Kt,aO as ln,b8 as dn,b9 as hn,ba as gn,bb as fn,bc as pn,bd as mn}from"./index-Bibw8odz.js";import{I as yn,R as bn}from"./chain-DfK5JtF7-Jmo_aVnV.js";var wn=Object.defineProperty,kn=(o,t,e)=>t in o?wn(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,F=(o,t,e)=>(kn(o,typeof t!="symbol"?t+"":t,e),e);class Sn extends TypeError{constructor(t,e){let n;const{message:s,...r}=t,{path:i}=t,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,r),this.name=this.constructor.name,this.failures=()=>{var c;return(c=n)!=null?c:n=[t,...e()]}}}function vn(o){return st(o)&&typeof o[Symbol.iterator]=="function"}function st(o){return typeof o=="object"&&o!=null}function X(o){return typeof o=="string"?JSON.stringify(o):""+o}function _n(o){const{done:t,value:e}=o.next();return t?void 0:e}function An(o,t,e,n){if(o===!0)return;o===!1?o={}:typeof o=="string"&&(o={message:o});const{path:s,branch:r}=t,{type:i}=e,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+X(n)+"`"}=o;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:r,...o,message:c}}function*fe(o,t,e,n){vn(o)||(o=[o]);for(const s of o){const r=An(s,t,e,n);r&&(yield r)}}function*ne(o,t,e={}){const{path:n=[],branch:s=[o],coerce:r=!1,mask:i=!1}=e,a={path:n,branch:s};if(r&&(o=t.coercer(o,a),i&&t.type!=="type"&&st(t.schema)&&st(o)&&!Array.isArray(o)))for(const l in o)t.schema[l]===void 0&&delete o[l];let c=!0;for(const l of t.validator(o,a))c=!1,yield[l,void 0];for(let[l,y,w]of t.entries(o,a)){const k=ne(y,w,{path:l===void 0?n:[...n,l],branch:l===void 0?s:[...s,y],coerce:r,mask:i});for(const b of k)b[0]?(c=!1,yield[b[0],void 0]):r&&(y=b[1],l===void 0?o=y:o instanceof Map?o.set(l,y):o instanceof Set?o.add(y):st(o)&&(o[l]=y))}if(c)for(const l of t.refiner(o,a))c=!1,yield[l,void 0];c&&(yield[void 0,o])}let Q=class{constructor(o){const{type:t,schema:e,validator:n,refiner:s,coercer:r=a=>a,entries:i=function*(){}}=o;this.type=t,this.schema=e,this.entries=i,this.coercer=r,n?this.validator=(a,c)=>{const l=n(a,c);return fe(l,c,this,a)}:this.validator=()=>[],s?this.refiner=(a,c)=>{const l=s(a,c);return fe(l,c,this,a)}:this.refiner=()=>[]}assert(o){return In(o,this)}create(o){return f(o,this)}is(o){return Ie(o,this)}mask(o){return Bn(o,this)}validate(o,t={}){return xt(o,this,t)}};function In(o,t){const e=xt(o,t);if(e[0])throw e[0]}function f(o,t){const e=xt(o,t,{coerce:!0});if(e[0])throw e[0];return e[1]}function Bn(o,t){const e=xt(o,t,{coerce:!0,mask:!0});if(e[0])throw e[0];return e[1]}function Ie(o,t){return!xt(o,t)[0]}function xt(o,t,e={}){const n=ne(o,t,e),s=_n(n);return s[0]?[new Sn(s[0],function*(){for(const r of n)r[0]&&(yield r[0])}),void 0]:[void 0,s[1]]}function ut(o,t){return new Q({type:o,schema:null,validator:t})}function xn(){return ut("any",()=>!0)}function m(o){return new Q({type:"array",schema:o,*entries(t){if(o&&Array.isArray(t))for(const[e,n]of t.entries())yield[e,n,o]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||"Expected an array value, but received: "+X(t)}})}function Z(){return ut("boolean",o=>typeof o=="boolean")}function se(o){return ut("instance",t=>t instanceof o||"Expected a `"+o.name+"` instance, but received: "+X(t))}function K(o){const t=X(o),e=typeof o;return new Q({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?o:null,validator(n){return n===o||"Expected the literal `"+t+"`, but received: "+X(n)}})}function En(){return ut("never",()=>!1)}function p(o){return new Q({...o,validator:(t,e)=>t===null||o.validator(t,e),refiner:(t,e)=>t===null||o.refiner(t,e)})}function u(){return ut("number",o=>typeof o=="number"&&!isNaN(o)||"Expected a number, but received: "+X(o))}function x(o){return new Q({...o,validator:(t,e)=>t===void 0||o.validator(t,e),refiner:(t,e)=>t===void 0||o.refiner(t,e)})}function Be(o,t){return new Q({type:"record",schema:null,*entries(e){if(st(e))for(const n in e){const s=e[n];yield[n,n,o],yield[n,s,t]}},validator(e){return st(e)||"Expected an object, but received: "+X(e)}})}function g(){return ut("string",o=>typeof o=="string"||"Expected a string, but received: "+X(o))}function re(o){const t=En();return new Q({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const n=Math.max(o.length,e.length);for(let s=0;s<n;s++)yield[s,e[s],o[s]||t]}},validator(e){return Array.isArray(e)||"Expected an array, but received: "+X(e)}})}function d(o){const t=Object.keys(o);return new Q({type:"type",schema:o,*entries(e){if(st(e))for(const n of t)yield[n,e[n],o[n]]},validator(e){return st(e)||"Expected an object, but received: "+X(e)}})}function H(o){const t=o.map(e=>e.type).join(" | ");return new Q({type:"union",schema:null,validator(e,n){const s=[];for(const r of o){const[...i]=ne(e,r,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+t+"`, but received: "+X(e),...s]}})}function Et(){return ut("unknown",()=>!0)}function Ct(o,t,e){return new Q({...o,coercer:(n,s)=>Ie(n,t)?o.coercer(e(n,s),s):o.coercer(n,s)})}const pe=()=>{const o=Bt.utils.randomPrivateKey(),t=Gt(o),e=new Uint8Array(64);return e.set(o),e.set(t,32),{publicKey:t,secretKey:e}},Gt=Bt.getPublicKey;function me(o){try{return Bt.ExtendedPoint.fromHex(o),!0}catch{return!1}}const Cn=(o,t)=>Bt.sign(o,t.slice(0,32)),Tn=Bt.verify,ct=o=>C.Buffer.isBuffer(o)?o:o instanceof Uint8Array?C.Buffer.from(o.buffer,o.byteOffset,o.byteLength):C.Buffer.from(o);class Rn{constructor(t){Object.assign(this,t)}encode(){return C.Buffer.from(en(Nt,this))}static decode(t){return nn(Nt,this,t)}static decodeUnchecked(t){return sn(Nt,this,t)}}const Nt=new Map;var xe;let Ee;const Pn=32,rt=32;function Ln(o){return o._bn!==void 0}let ye=1;Ee=Symbol.toStringTag;class v extends Rn{constructor(t){if(super({}),this._bn=void 0,Ln(t))this._bn=t._bn;else{if(typeof t=="string"){const e=U.decode(t);if(e.length!=rt)throw new Error("Invalid public key input");this._bn=new de(e)}else this._bn=new de(t);if(this._bn.byteLength()>rt)throw new Error("Invalid public key input")}}static unique(){const t=new v(ye);return ye+=1,new v(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return U.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(C.Buffer);if(t.length===rt)return t;const e=C.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[Ee](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,n){const s=C.Buffer.concat([t.toBuffer(),C.Buffer.from(e),n.toBuffer()]),r=he(s);return new v(r)}static createProgramAddressSync(t,e){let n=C.Buffer.alloc(0);t.forEach(function(r){if(r.length>Pn)throw new TypeError("Max seed length exceeded");n=C.Buffer.concat([n,ct(r)])}),n=C.Buffer.concat([n,e.toBuffer(),C.Buffer.from("ProgramDerivedAddress")]);const s=he(n);if(me(s))throw new Error("Invalid seeds, address must fall off the curve");return new v(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let n=255,s;for(;n!=0;){try{const r=t.concat(C.Buffer.from([n]));s=this.createProgramAddressSync(r,e)}catch(r){if(r instanceof TypeError)throw r;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new v(t);return me(e.toBytes())}}xe=v;v.default=new xe("11111111111111111111111111111111");Nt.set(v,{kind:"struct",fields:[["_bn","u256"]]});new v("BPFLoader1111111111111111111111111111111111");const pt=1232,Ce=127,Te=64;class oe extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty(oe.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Re extends Error{constructor(t,e){super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Re.prototype,"name",{value:"TransactionExpiredTimeoutError"});class kt extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty(kt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class qt{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const e=new Map;this.keySegments().flat().forEach((s,r)=>{e.set(s.toBase58(),r)});const n=s=>{const r=e.get(s.toBase58());if(r===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return r};return t.map(s=>({programIdIndex:n(s.programId),accountKeyIndexes:s.keys.map(r=>n(r.pubkey)),data:s.data}))}}const T=(o="publicKey")=>q(32,o),gt=(o="string")=>{const t=A([I("length"),I("lengthPadding"),q(ft(I(),-8),"chars")],o),e=t.decode.bind(t),n=t.encode.bind(t),s=t;return s.decode=(r,i)=>e(r,i).chars.toString(),s.encode=(r,i,a)=>{const c={chars:C.Buffer.from(r,"utf8")};return n(c,i,a)},s.alloc=r=>I().span+I().span+C.Buffer.from(r,"utf8").length,s},Kn=(o="authorized")=>A([T("staker"),T("withdrawer")],o),Nn=(o="lockup")=>A([D("unixTimestamp"),D("epoch"),T("custodian")],o),On=(o="voteInit")=>A([T("nodePubkey"),T("authorizedVoter"),T("authorizedWithdrawer"),P("commission")],o),qn=(o="voteAuthorizeWithSeedArgs")=>A([I("voteAuthorizationType"),T("currentAuthorityDerivedKeyOwnerPubkey"),gt("currentAuthorityDerivedKeySeed"),T("newAuthorized")],o);function Pe(o,t){const e=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(t[s.property]);if("count"in s&&"elementLayout"in s){const r=t[s.property];if(Array.isArray(r))return r.length*e(s.elementLayout)}else if("fields"in s)return Pe({layout:s},t[s.property]);return 0};let n=0;return o.layout.fields.forEach(s=>{n+=e(s)}),n}function j(o){let t=0,e=0;for(;;){let n=o.shift();if(t|=(n&127)<<e*7,e+=1,!(n&128))break}return t}function V(o,t){let e=t;for(;;){let n=e&127;if(e>>=7,e==0){o.push(n);break}else n|=128,o.push(n)}}function O(o,t){if(!o)throw new Error(t||"Assertion failed")}class zt{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},r=s(e);r.isSigner=!0,r.isWritable=!0;for(const i of t){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new zt(e,n)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];O(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,c])=>c.isSigner&&c.isWritable),n=t.filter(([,c])=>c.isSigner&&!c.isWritable),s=t.filter(([,c])=>!c.isSigner&&c.isWritable),r=t.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:e.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:r.length};{O(e.length>0,"Expected at least one writable signer key");const[c]=e[0];O(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...e.map(([c])=>new v(c)),...n.map(([c])=>new v(c)),...s.map(([c])=>new v(c)),...r.map(([c])=>new v(c))];return[i,a]}extractTableLookup(t){const[e,n]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,r]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:n,readonly:r}]}drainKeysFoundInLookupTable(t,e){const n=new Array,s=new Array;for(const[r,i]of this.keyMetaMap.entries())if(e(i)){const a=new v(r),c=t.findIndex(l=>l.equals(a));c>=0&&(O(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(r))}return[n,s]}}const Le="Reached end of buffer unexpectedly";function Y(o){if(o.length===0)throw new Error(Le);return o.shift()}function J(o,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>o.length:e>=o.length)throw new Error(Le);return o.splice(...t)}class tt{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new v(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:U.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new qt(this.staticAccountKeys)}static compile(t){const e=zt.compile(t.instructions,t.payerKey),[n,s]=e.getMessageComponents(),r=new qt(s).compileInstructions(t.instructions).map(i=>({programIdIndex:i.programIdIndex,accounts:i.accountKeyIndexes,data:U.encode(i.data)}));return new tt({header:n,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:r})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const n=t-e,s=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return n<s}else{const n=e-this.header.numReadonlySignedAccounts;return t<n}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];V(e,t);const n=this.instructions.map(w=>{const{accounts:k,programIdIndex:b}=w,S=Array.from(U.decode(w.data));let h=[];V(h,k.length);let B=[];return V(B,S.length),{programIdIndex:b,keyIndicesCount:C.Buffer.from(h),keyIndices:k,dataLength:C.Buffer.from(B),data:S}});let s=[];V(s,n.length);let r=C.Buffer.alloc(pt);C.Buffer.from(s).copy(r);let i=s.length;n.forEach(w=>{const k=A([P("programIdIndex"),q(w.keyIndicesCount.length,"keyIndicesCount"),$(P("keyIndex"),w.keyIndices.length,"keyIndices"),q(w.dataLength.length,"dataLength"),$(P("userdatum"),w.data.length,"data")]).encode(w,r,i);i+=k}),r=r.slice(0,i);const a=A([q(1,"numRequiredSignatures"),q(1,"numReadonlySignedAccounts"),q(1,"numReadonlyUnsignedAccounts"),q(e.length,"keyCount"),$(T("key"),t,"keys"),T("recentBlockhash")]),c={numRequiredSignatures:C.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:C.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:C.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:C.Buffer.from(e),keys:this.accountKeys.map(w=>ct(w.toBytes())),recentBlockhash:U.decode(this.recentBlockhash)};let l=C.Buffer.alloc(2048);const y=a.encode(c,l);return r.copy(l,y),l.slice(0,y+r.length)}static from(t){let e=[...t];const n=Y(e);if(n!==(n&Ce))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=Y(e),r=Y(e),i=j(e);let a=[];for(let k=0;k<i;k++){const b=J(e,0,rt);a.push(new v(C.Buffer.from(b)))}const c=J(e,0,rt),l=j(e);let y=[];for(let k=0;k<l;k++){const b=Y(e),S=j(e),h=J(e,0,S),B=j(e),R=J(e,0,B),z=U.encode(C.Buffer.from(R));y.push({programIdIndex:b,accounts:h,data:z})}const w={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:r},recentBlockhash:U.encode(C.Buffer.from(c)),accountKeys:a,instructions:y};return new tt(w)}}class _t{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new qt(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(t>=n){const s=t-n,r=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<r}else if(t>=this.header.numRequiredSignatures){const s=t-e,r=n-e-this.header.numReadonlyUnsignedAccounts;return s<r}else{const s=e-this.header.numReadonlySignedAccounts;return t<s}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=t.find(r=>r.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const r of n.writableIndexes)if(r<s.state.addresses.length)e.writable.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`);for(const r of n.readonlyIndexes)if(r<s.state.addresses.length)e.readonly.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`)}return e}static compile(t){const e=zt.compile(t.instructions,t.payerKey),n=new Array,s={writable:new Array,readonly:new Array},r=t.addressLookupTableAccounts||[];for(const l of r){const y=e.extractTableLookup(l);if(y!==void 0){const[w,{writable:k,readonly:b}]=y;n.push(w),s.writable.push(...k),s.readonly.push(...b)}}const[i,a]=e.getMessageComponents(),c=new qt(a,s).compileInstructions(t.instructions);return new _t({header:i,staticAccountKeys:a,recentBlockhash:t.recentBlockhash,compiledInstructions:c,addressTableLookups:n})}serialize(){const t=Array();V(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),n=Array();V(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),r=Array();V(r,this.addressTableLookups.length);const i=A([P("prefix"),A([P("numRequiredSignatures"),P("numReadonlySignedAccounts"),P("numReadonlyUnsignedAccounts")],"header"),q(t.length,"staticAccountKeysLength"),$(T(),this.staticAccountKeys.length,"staticAccountKeys"),T("recentBlockhash"),q(n.length,"instructionsLength"),q(e.length,"serializedInstructions"),q(r.length,"addressTableLookupsLength"),q(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(pt),c=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:U.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(r),serializedAddressTableLookups:s},a);return a.slice(0,c)}serializeInstructions(){let t=0;const e=new Uint8Array(pt);for(const n of this.compiledInstructions){const s=Array();V(s,n.accountKeyIndexes.length);const r=Array();V(r,n.data.length);const i=A([P("programIdIndex"),q(s.length,"encodedAccountKeyIndexesLength"),$(P(),n.accountKeyIndexes.length,"accountKeyIndexes"),q(r.length,"encodedDataLength"),q(n.data.length,"data")]);t+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(r),data:n.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(pt);for(const n of this.addressTableLookups){const s=Array();V(s,n.writableIndexes.length);const r=Array();V(r,n.readonlyIndexes.length);const i=A([T("accountKey"),q(s.length,"encodedWritableIndexesLength"),$(P(),n.writableIndexes.length,"writableIndexes"),q(r.length,"encodedReadonlyIndexesLength"),$(P(),n.readonlyIndexes.length,"readonlyIndexes")]);t+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(r),readonlyIndexes:n.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const n=Y(e),s=n&Ce;O(n!==s,"Expected versioned message but received legacy message");const r=s;O(r===0,`Expected versioned message with version 0 but found version ${r}`);const i={numRequiredSignatures:Y(e),numReadonlySignedAccounts:Y(e),numReadonlyUnsignedAccounts:Y(e)},a=[],c=j(e);for(let S=0;S<c;S++)a.push(new v(J(e,0,rt)));const l=U.encode(J(e,0,rt)),y=j(e),w=[];for(let S=0;S<y;S++){const h=Y(e),B=j(e),R=J(e,0,B),z=j(e),bt=new Uint8Array(J(e,0,z));w.push({programIdIndex:h,accountKeyIndexes:R,data:bt})}const k=j(e),b=[];for(let S=0;S<k;S++){const h=new v(J(e,0,rt)),B=j(e),R=J(e,0,B),z=j(e),bt=J(e,0,z);b.push({accountKey:h,writableIndexes:R,readonlyIndexes:bt})}return new _t({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:w,addressTableLookups:b})}}let et=function(o){return o[o.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",o[o.PROCESSED=1]="PROCESSED",o[o.TIMED_OUT=2]="TIMED_OUT",o[o.NONCE_INVALID=3]="NONCE_INVALID",o}({});const Wn=C.Buffer.alloc(Te).fill(0);class at{constructor(t){this.keys=void 0,this.programId=void 0,this.data=C.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:n})=>({pubkey:t.toJSON(),isSigner:e,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class nt{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:n}=t;this.minNonceContextSlot=e,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:n}=t;this.recentBlockhash=e,this.lastValidBlockHeight=n}else{const{recentBlockhash:e,nonceInfo:n}=t;n&&(this.nonceInfo=n),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new at(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let h=0;h<e.length;h++)if(e[h].programId===void 0)throw new Error(`Transaction instruction index ${h} has undefined program id`);const s=[],r=[];e.forEach(h=>{h.keys.forEach(R=>{r.push({...R})});const B=h.programId.toString();s.includes(B)||s.push(B)}),s.forEach(h=>{r.push({pubkey:new v(h),isSigner:!1,isWritable:!1})});const i=[];r.forEach(h=>{const B=h.pubkey.toString(),R=i.findIndex(z=>z.pubkey.toString()===B);R>-1?(i[R].isWritable=i[R].isWritable||h.isWritable,i[R].isSigner=i[R].isSigner||h.isSigner):i.push(h)}),i.sort(function(h,B){if(h.isSigner!==B.isSigner)return h.isSigner?-1:1;if(h.isWritable!==B.isWritable)return h.isWritable?-1:1;const R={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return h.pubkey.toBase58().localeCompare(B.pubkey.toBase58(),"en",R)});const a=i.findIndex(h=>h.pubkey.equals(n));if(a>-1){const[h]=i.splice(a,1);h.isSigner=!0,h.isWritable=!0,i.unshift(h)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const h of this.signatures){const B=i.findIndex(R=>R.pubkey.equals(h.publicKey));if(B>-1)i[B].isSigner||(i[B].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${h.publicKey.toString()}`)}let c=0,l=0,y=0;const w=[],k=[];i.forEach(({pubkey:h,isSigner:B,isWritable:R})=>{B?(w.push(h.toString()),c+=1,R||(l+=1)):(k.push(h.toString()),R||(y+=1))});const b=w.concat(k),S=e.map(h=>{const{data:B,programId:R}=h;return{programIdIndex:b.indexOf(R.toString()),accounts:h.keys.map(z=>b.indexOf(z.pubkey.toString())),data:U.encode(B)}});return S.forEach(h=>{O(h.programIdIndex>=0),h.accounts.forEach(B=>O(B>=0))}),new tt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:y},accountKeys:b,recentBlockhash:t,instructions:S})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((n,s)=>e[s].equals(n.publicKey))||(this.signatures=e.map(n=>({signature:null,publicKey:n}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(n=>{const s=n.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,n=[];for(const r of t){const i=r.publicKey.toString();e.has(i)||(e.add(i),n.push(r))}this.signatures=n.map(r=>({signature:null,publicKey:r.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,n=[];for(const r of t){const i=r.publicKey.toString();e.has(i)||(e.add(i),n.push(r))}const s=this._compile();this._partialSign(s,...n)}_partialSign(t,...e){const n=t.serialize();e.forEach(s=>{const r=Cn(n,s.secretKey);this._addSignature(s.publicKey,ct(r))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){O(e.length===64);const n=this.signatures.findIndex(s=>t.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[n].signature=C.Buffer.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const n={};for(const{signature:s,publicKey:r}of this.signatures)s===null?e&&(n.missing||(n.missing=[])).push(r):Tn(s,t,r.toBytes())||(n.invalid||(n.invalid=[])).push(r);return n.invalid||n.missing?n:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),s=this.serializeMessage();if(n){const r=this._getMessageSignednessErrors(s,e);if(r){let i="Signature verification failed.";throw r.invalid&&(i+=`
Invalid signature for public key${r.invalid.length===1?"":"(s)"} [\`${r.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),r.missing&&(i+=`
Missing signature for public key${r.missing.length===1?"":"(s)"} [\`${r.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(t){const{signatures:e}=this,n=[];V(n,e.length);const s=n.length+e.length*64+t.length,r=C.Buffer.alloc(s);return O(e.length<256),C.Buffer.from(n).copy(r,0),e.forEach(({signature:i},a)=>{i!==null&&(O(i.length===64,"signature has invalid length"),C.Buffer.from(i).copy(r,n.length+a*64))}),t.copy(r,n.length+e.length*64),O(r.length<=pt,`Transaction too large: ${r.length} > ${pt}`),r}get keys(){return O(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return O(this.instructions.length===1),this.instructions[0].programId}get data(){return O(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const n=j(e);let s=[];for(let r=0;r<n;r++){const i=J(e,0,Te);s.push(U.encode(C.Buffer.from(i)))}return nt.populate(tt.from(e),s)}static populate(t,e=[]){const n=new nt;return n.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(n.feePayer=t.accountKeys[0]),e.forEach((s,r)=>{const i={signature:s==U.encode(Wn)?null:U.decode(s),publicKey:t.accountKeys[r]};n.signatures.push(i)}),t.instructions.forEach(s=>{const r=s.accounts.map(i=>{const a=t.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||t.isAccountSigner(i),isWritable:t.isAccountWritable(i)}});n.instructions.push(new at({keys:r,programId:t.accountKeys[s.programIdIndex],data:U.decode(s.data)}))}),n._message=t,n._json=n.toJSON(),n}}class ie{constructor(t){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=t.payerKey,this.instructions=t.instructions,this.recentBlockhash=t.recentBlockhash}static decompile(t,e){const{header:n,compiledInstructions:s,recentBlockhash:r}=t,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=n,l=i-a;O(l>0,"Message header is invalid");const y=t.staticAccountKeys.length-i-c;O(y>=0,"Message header is invalid");const w=t.getAccountKeys(e),k=w.get(0);if(k===void 0)throw new Error("Failed to decompile message because no account keys were found");const b=[];for(const S of s){const h=[];for(const R of S.accountKeyIndexes){const z=w.get(R);if(z===void 0)throw new Error(`Failed to find key for account key index ${R}`);const bt=R<i;let Tt;bt?Tt=R<l:R<w.staticAccountKeys.length?Tt=R-i<y:Tt=R-w.staticAccountKeys.length<w.accountKeysFromLookups.writable.length,h.push({pubkey:z,isSigner:R<n.numRequiredSignatures,isWritable:Tt})}const B=w.get(S.programIdIndex);if(B===void 0)throw new Error(`Failed to find program id for program id index ${S.programIdIndex}`);b.push(new at({programId:B,data:ct(S.data),keys:h}))}return new ie({payerKey:k,instructions:b,recentBlockhash:r})}compileToLegacyMessage(){return tt.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(t){return _t.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:t})}}const zn=160,Fn=64,Un=zn/Fn,Mn=1e3/Un;new v("SysvarC1ock11111111111111111111111111111111");new v("SysvarEpochSchedu1e111111111111111111111111");new v("Sysvar1nstructions1111111111111111111111111");new v("SysvarRecentB1ockHashes11111111111111111111");new v("SysvarRent111111111111111111111111111111111");new v("SysvarRewards111111111111111111111111111111");new v("SysvarS1otHashes111111111111111111111111111");new v("SysvarS1otHistory11111111111111111111111111");new v("SysvarStakeHistory1111111111111111111111111");function ht(o){return new Promise(t=>setTimeout(t,o))}function Rt(o,t){const e=o.layout.span>=0?o.layout.span:Pe(o,t),n=C.Buffer.alloc(e),s=Object.assign({instruction:o.index},t);return o.layout.encode(s,n),n}const $n=M("lamportsPerSignature"),Ke=A([I("version"),I("state"),T("authorizedPubkey"),T("nonce"),A([$n],"feeCalculator")]);Ke.span;class ae{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const e=Ke.decode(ct(t),0);return new ae({authorizedPubkey:new v(e.authorizedPubkey),nonce:new v(e.nonce).toString(),feeCalculator:e.feeCalculator})}}const Hn=o=>{const t=o.decode.bind(o),e=o.encode.bind(o);return{decode:t,encode:e}},Dn=o=>t=>{const e=q(o,t),{encode:n,decode:s}=Hn(e),r=e;return r.decode=(i,a)=>{const c=s(i,a);return dn(C.Buffer.from(c))},r.encode=(i,a,c)=>{const l=hn(i,o);return n(l,a,c)},r},mt=Dn(8);Object.freeze({Create:{index:0,layout:A([I("instruction"),D("lamports"),D("space"),T("programId")])},Assign:{index:1,layout:A([I("instruction"),T("programId")])},Transfer:{index:2,layout:A([I("instruction"),mt("lamports")])},CreateWithSeed:{index:3,layout:A([I("instruction"),T("base"),gt("seed"),D("lamports"),D("space"),T("programId")])},AdvanceNonceAccount:{index:4,layout:A([I("instruction")])},WithdrawNonceAccount:{index:5,layout:A([I("instruction"),D("lamports")])},InitializeNonceAccount:{index:6,layout:A([I("instruction"),T("authorized")])},AuthorizeNonceAccount:{index:7,layout:A([I("instruction"),T("authorized")])},Allocate:{index:8,layout:A([I("instruction"),D("space")])},AllocateWithSeed:{index:9,layout:A([I("instruction"),T("base"),gt("seed"),D("space"),T("programId")])},AssignWithSeed:{index:10,layout:A([I("instruction"),T("base"),gt("seed"),T("programId")])},TransferWithSeed:{index:11,layout:A([I("instruction"),mt("lamports"),gt("seed"),T("programId")])},UpgradeNonceAccount:{index:12,layout:A([I("instruction")])}});new v("11111111111111111111111111111111");new v("BPFLoader2111111111111111111111111111111111");function jn(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var Vn=Object.prototype.toString,Jn=Object.keys||function(o){var t=[];for(var e in o)t.push(e);return t};function St(o,t){var e,n,s,r,i,a,c;if(o===!0)return"true";if(o===!1)return"false";switch(typeof o){case"object":if(o===null)return null;if(o.toJSON&&typeof o.toJSON=="function")return St(o.toJSON(),t);if(c=Vn.call(o),c==="[object Array]"){for(s="[",n=o.length-1,e=0;e<n;e++)s+=St(o[e],!0)+",";return n>-1&&(s+=St(o[e],!0)),s+"]"}else if(c==="[object Object]"){for(r=Jn(o).sort(),n=r.length,s="",e=0;e<n;)i=r[e],a=St(o[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),e++;return"{"+s+"}"}else return JSON.stringify(o);case"function":case"undefined":return t?null:void 0;case"string":return JSON.stringify(o);default:return isFinite(o)?o:null}}var Gn=function(o){var t=St(o,!1);if(t!==void 0)return""+t},be=jn(Gn);const wt=32;function Dt(o){let t=0;for(;o>1;)o/=2,t++;return t}function Xn(o){return o===0?1:(o--,o|=o>>1,o|=o>>2,o|=o>>4,o|=o>>8,o|=o>>16,o|=o>>32,o+1)}class Zn{constructor(t,e,n,s,r){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=e,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=r}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const e=Dt(Xn(t+wt+1))-Dt(wt)-1,n=this.getSlotsInEpoch(e),s=t-(n-wt);return[e,s]}else{const e=t-this.firstNormalSlot,n=Math.floor(e/this.slotsPerEpoch),s=this.firstNormalEpoch+n,r=e%this.slotsPerEpoch;return[s,r]}}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?(Math.pow(2,t)-1)*wt:(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+Dt(wt)):this.slotsPerEpoch}}class Xt extends Error{constructor(t,e){super(t),this.logs=void 0,this.logs=e}}class _ extends Error{constructor({code:t,message:e,data:n},s){super(s!=null?`${s}: ${e}`:e),this.code=void 0,this.data=void 0,this.code=t,this.data=n,this.name="SolanaJSONRPCError"}}var Qn=globalThis.fetch;class Yn extends fn{constructor(t,e,n){const s=r=>{const i=mn(r,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...e});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,t,e,n),this.underlyingSocket=void 0}call(...t){var e;const n=(e=this.underlyingSocket)==null?void 0:e.readyState;return n===1?super.call(...t):Promise.reject(new Error("Tried to call a JSON-RPC method `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+n+")"))}notify(...t){var e;const n=(e=this.underlyingSocket)==null?void 0:e.readyState;return n===1?super.notify(...t):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+n+")"))}}function ts(o,t){let e;try{e=o.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(e.typeIndex!==o.index)throw new Error(`invalid account data; account type mismatch ${e.typeIndex} != ${o.index}`);return e}const we=56;class ke{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const e=ts(es,t),n=t.length-we;O(n>=0,"lookup table is invalid"),O(n%32===0,"lookup table is invalid");const s=n/32,{addresses:r}=A([$(T(),s,"addresses")]).decode(t.slice(we));return{deactivationSlot:e.deactivationSlot,lastExtendedSlot:e.lastExtendedSlot,lastExtendedSlotStartIndex:e.lastExtendedStartIndex,authority:e.authority.length!==0?new v(e.authority[0]):void 0,addresses:r.map(i=>new v(i))}}}const es={index:1,layout:A([I("typeIndex"),mt("deactivationSlot"),M("lastExtendedSlot"),P("lastExtendedStartIndex"),P(),$(T(),ft(P(),-1),"authority")])},ns=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function ss(o){const t=o.match(ns);if(t==null)throw TypeError(`Failed to validate endpoint URL \`${o}\``);const[e,n,s,r]=t,i=o.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${r}`}const W=Ct(se(v),g(),o=>new v(o)),Ne=re([g(),K("base64")]),ce=Ct(se(C.Buffer),Ne,o=>C.Buffer.from(o[0],"base64")),rs=30*1e3;function os(o){if(/^https?:/.test(o)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return o}function L(o){let t,e;if(typeof o=="string")t=o;else if(o){const{commitment:n,...s}=o;t=n,e=s}return{commitment:t,config:e}}function Oe(o){return H([d({jsonrpc:K("2.0"),id:g(),result:o}),d({jsonrpc:K("2.0"),id:g(),error:d({code:Et(),message:g(),data:x(xn())})})])}const is=Oe(Et());function E(o){return Ct(Oe(o),is,t=>"error"in t?t:{...t,result:f(t.result,o)})}function N(o){return E(d({context:d({slot:u()}),value:o}))}function Ft(o){return d({context:d({slot:u()}),value:o})}function jt(o,t){return o===0?new _t({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new v(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:U.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new tt(t)}const as=d({foundation:u(),foundationTerm:u(),initial:u(),taper:u(),terminal:u()}),cs=E(m(p(d({epoch:u(),effectiveSlot:u(),amount:u(),postBalance:u(),commission:x(p(u()))})))),us=m(d({slot:u(),prioritizationFee:u()})),ls=d({total:u(),validator:u(),foundation:u(),epoch:u()}),ds=d({epoch:u(),slotIndex:u(),slotsInEpoch:u(),absoluteSlot:u(),blockHeight:x(u()),transactionCount:x(u())}),hs=d({slotsPerEpoch:u(),leaderScheduleSlotOffset:u(),warmup:Z(),firstNormalEpoch:u(),firstNormalSlot:u()}),gs=Be(g(),m(u())),lt=p(H([d({}),g()])),fs=d({err:lt}),ps=K("receivedSignature"),ms=d({"solana-core":g(),"feature-set":x(u())}),Se=N(d({err:p(H([d({}),g()])),logs:p(m(g())),accounts:x(p(m(p(d({executable:Z(),owner:g(),lamports:u(),data:m(g()),rentEpoch:x(u())}))))),unitsConsumed:x(u()),returnData:x(p(d({programId:g(),data:re([g(),K("base64")])})))})),ys=N(d({byIdentity:Be(g(),m(u())),range:d({firstSlot:u(),lastSlot:u()})}));function bs(o,t,e,n,s,r){const i=e||Qn;let a;r!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(l,y)=>{const w=await new Promise((k,b)=>{try{n(l,y,(S,h)=>k([S,h]))}catch(S){b(S)}});return await i(...w)}),new pn(async(l,y)=>{const w={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},t||{},wr)};try{let k=5,b,S=500;for(;c?b=await c(o,w):b=await i(o,w),!(b.status!==429||s===!0||(k-=1,k===0));)console.error(`Server responded with ${b.status} ${b.statusText}.  Retrying after ${S}ms delay...`),await ht(S),S*=2;const h=await b.text();b.ok?y(null,h):y(new Error(`${b.status} ${b.statusText}: ${h}`))}catch(k){k instanceof Error&&y(k)}},{})}function ws(o){return(t,e)=>new Promise((n,s)=>{o.request(t,e,(r,i)=>{if(r){s(r);return}n(i)})})}function ks(o){return t=>new Promise((e,n)=>{t.length===0&&e([]);const s=t.map(r=>o.request(r.methodName,r.args));o.request(s,(r,i)=>{if(r){n(r);return}e(i)})})}const Ss=E(as),vs=E(ls),_s=E(us),As=E(ds),Is=E(hs),Bs=E(gs),xs=E(u()),Es=N(d({total:u(),circulating:u(),nonCirculating:u(),nonCirculatingAccounts:m(W)})),Zt=d({amount:g(),uiAmount:p(u()),decimals:u(),uiAmountString:x(g())}),Cs=N(m(d({address:W,amount:g(),uiAmount:p(u()),decimals:u(),uiAmountString:x(g())}))),Ts=N(m(d({pubkey:W,account:d({executable:Z(),owner:W,lamports:u(),data:ce,rentEpoch:u()})}))),Qt=d({program:g(),parsed:Et(),space:u()}),Rs=N(m(d({pubkey:W,account:d({executable:Z(),owner:W,lamports:u(),data:Qt,rentEpoch:u()})}))),Ps=N(m(d({lamports:u(),address:W}))),At=d({executable:Z(),owner:W,lamports:u(),data:ce,rentEpoch:u()}),Ls=d({pubkey:W,account:At}),Ks=Ct(H([se(C.Buffer),Qt]),H([Ne,Qt]),o=>Array.isArray(o)?f(o,ce):o),Yt=d({executable:Z(),owner:W,lamports:u(),data:Ks,rentEpoch:u()}),Ns=d({pubkey:W,account:Yt}),Os=d({state:H([K("active"),K("inactive"),K("activating"),K("deactivating")]),active:u(),inactive:u()}),qs=E(m(d({signature:g(),slot:u(),err:lt,memo:p(g()),blockTime:x(p(u()))}))),Ws=E(m(d({signature:g(),slot:u(),err:lt,memo:p(g()),blockTime:x(p(u()))}))),zs=d({subscription:u(),result:Ft(At)}),Fs=d({pubkey:W,account:At}),Us=d({subscription:u(),result:Ft(Fs)}),Ms=d({parent:u(),slot:u(),root:u()}),$s=d({subscription:u(),result:Ms}),Hs=H([d({type:H([K("firstShredReceived"),K("completed"),K("optimisticConfirmation"),K("root")]),slot:u(),timestamp:u()}),d({type:K("createdBank"),parent:u(),slot:u(),timestamp:u()}),d({type:K("frozen"),slot:u(),timestamp:u(),stats:d({numTransactionEntries:u(),numSuccessfulTransactions:u(),numFailedTransactions:u(),maxTransactionsPerEntry:u()})}),d({type:K("dead"),slot:u(),timestamp:u(),err:g()})]),Ds=d({subscription:u(),result:Hs}),js=d({subscription:u(),result:Ft(H([fs,ps]))}),Vs=d({subscription:u(),result:u()}),Js=d({pubkey:g(),gossip:p(g()),tpu:p(g()),rpc:p(g()),version:p(g())}),ve=d({votePubkey:g(),nodePubkey:g(),activatedStake:u(),epochVoteAccount:Z(),epochCredits:m(re([u(),u(),u()])),commission:u(),lastVote:u(),rootSlot:p(u())}),Gs=E(d({current:m(ve),delinquent:m(ve)})),Xs=H([K("processed"),K("confirmed"),K("finalized")]),Zs=d({slot:u(),confirmations:p(u()),err:lt,confirmationStatus:x(Xs)}),Qs=N(m(p(Zs))),Ys=E(u()),qe=d({accountKey:W,writableIndexes:m(u()),readonlyIndexes:m(u())}),ue=d({signatures:m(g()),message:d({accountKeys:m(g()),header:d({numRequiredSignatures:u(),numReadonlySignedAccounts:u(),numReadonlyUnsignedAccounts:u()}),instructions:m(d({accounts:m(u()),data:g(),programIdIndex:u()})),recentBlockhash:g(),addressTableLookups:x(m(qe))})}),We=d({pubkey:W,signer:Z(),writable:Z(),source:x(H([K("transaction"),K("lookupTable")]))}),ze=d({accountKeys:m(We),signatures:m(g())}),Fe=d({parsed:Et(),program:g(),programId:W}),Ue=d({accounts:m(W),data:g(),programId:W}),tr=H([Ue,Fe]),er=H([d({parsed:Et(),program:g(),programId:g()}),d({accounts:m(g()),data:g(),programId:g()})]),Me=Ct(tr,er,o=>"accounts"in o?f(o,Ue):f(o,Fe)),$e=d({signatures:m(g()),message:d({accountKeys:m(We),instructions:m(Me),recentBlockhash:g(),addressTableLookups:x(p(m(qe)))})}),Wt=d({accountIndex:u(),mint:g(),owner:x(g()),uiTokenAmount:Zt}),He=d({writable:m(W),readonly:m(W)}),Ut=d({err:lt,fee:u(),innerInstructions:x(p(m(d({index:u(),instructions:m(d({accounts:m(u()),data:g(),programIdIndex:u()}))})))),preBalances:m(u()),postBalances:m(u()),logMessages:x(p(m(g()))),preTokenBalances:x(p(m(Wt))),postTokenBalances:x(p(m(Wt))),loadedAddresses:x(He),computeUnitsConsumed:x(u())}),le=d({err:lt,fee:u(),innerInstructions:x(p(m(d({index:u(),instructions:m(Me)})))),preBalances:m(u()),postBalances:m(u()),logMessages:x(p(m(g()))),preTokenBalances:x(p(m(Wt))),postTokenBalances:x(p(m(Wt))),loadedAddresses:x(He),computeUnitsConsumed:x(u())}),yt=H([K(0),K("legacy")]),dt=d({pubkey:g(),lamports:u(),postBalance:p(u()),rewardType:p(g()),commission:x(p(u()))}),nr=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:m(d({transaction:ue,meta:p(Ut),version:x(yt)})),rewards:x(m(dt)),blockTime:p(u()),blockHeight:p(u())}))),sr=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),rewards:x(m(dt)),blockTime:p(u()),blockHeight:p(u())}))),rr=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:m(d({transaction:ze,meta:p(Ut),version:x(yt)})),rewards:x(m(dt)),blockTime:p(u()),blockHeight:p(u())}))),or=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:m(d({transaction:$e,meta:p(le),version:x(yt)})),rewards:x(m(dt)),blockTime:p(u()),blockHeight:p(u())}))),ir=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:m(d({transaction:ze,meta:p(le),version:x(yt)})),rewards:x(m(dt)),blockTime:p(u()),blockHeight:p(u())}))),ar=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),rewards:x(m(dt)),blockTime:p(u()),blockHeight:p(u())}))),cr=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),transactions:m(d({transaction:ue,meta:p(Ut)})),rewards:x(m(dt)),blockTime:p(u())}))),_e=E(p(d({blockhash:g(),previousBlockhash:g(),parentSlot:u(),signatures:m(g()),blockTime:p(u())}))),Vt=E(p(d({slot:u(),meta:p(Ut),blockTime:x(p(u())),transaction:ue,version:x(yt)}))),Pt=E(p(d({slot:u(),transaction:$e,meta:p(le),blockTime:x(p(u())),version:x(yt)}))),ur=N(d({blockhash:g(),feeCalculator:d({lamportsPerSignature:u()})})),lr=N(d({blockhash:g(),lastValidBlockHeight:u()})),dr=N(Z()),hr=d({slot:u(),numTransactions:u(),numSlots:u(),samplePeriodSecs:u()}),gr=E(m(hr)),fr=N(p(d({feeCalculator:d({lamportsPerSignature:u()})}))),pr=E(g()),mr=E(g()),yr=d({err:lt,logs:m(g()),signature:g()}),br=d({result:Ft(yr),subscription:u()}),wr={"solana-client":"js/0.0.0-development"};class kr{constructor(t,e){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const l={};return async y=>{const{commitment:w,config:k}=L(y),b=this._buildArgs([],w,void 0,k),S=be(b);return l[S]=l[S]??(async()=>{try{const h=await this._rpcRequest("getBlockHeight",b),B=f(h,E(u()));if("error"in B)throw new _(B.error,"failed to get block height information");return B.result}finally{delete l[S]}})(),await l[S]}})();let n,s,r,i,a,c;e&&typeof e=="string"?this._commitment=e:e&&(this._commitment=e.commitment,this._confirmTransactionInitialTimeout=e.confirmTransactionInitialTimeout,n=e.wsEndpoint,s=e.httpHeaders,r=e.fetch,i=e.fetchMiddleware,a=e.disableRetryOnRateLimit,c=e.httpAgent),this._rpcEndpoint=os(t),this._rpcWsEndpoint=n||ss(t),this._rpcClient=bs(t,s,r,i,a,c),this._rpcRequest=ws(this._rpcClient),this._rpcBatchRequest=ks(this._rpcClient),this._rpcWebSocket=new Yn(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgs([t.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",r),a=f(i,N(u()));if("error"in a)throw new _(a.error,`failed to get balance for ${t.toBase58()}`);return a.result}async getBalance(t,e){return await this.getBalanceAndContext(t,e).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+n)})}async getBlockTime(t){const e=await this._rpcRequest("getBlockTime",[t]),n=f(e,E(p(u())));if("error"in n)throw new _(n.error,`failed to get block time for slot ${t}`);return n.result}async getMinimumLedgerSlot(){const t=await this._rpcRequest("minimumLedgerSlot",[]),e=f(t,E(u()));if("error"in e)throw new _(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const t=await this._rpcRequest("getFirstAvailableBlock",[]),e=f(t,xs);if("error"in e)throw new _(e.error,"failed to get first available block");return e.result}async getSupply(t){let e={};typeof t=="string"?e={commitment:t}:t?e={...t,commitment:t&&t.commitment||this.commitment}:e={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[e]),s=f(n,Es);if("error"in s)throw new _(s.error,"failed to get supply");return s.result}async getTokenSupply(t,e){const n=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenSupply",n),r=f(s,N(Zt));if("error"in r)throw new _(r.error,"failed to get token supply");return r.result}async getTokenAccountBalance(t,e){const n=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenAccountBalance",n),r=f(s,N(Zt));if("error"in r)throw new _(r.error,"failed to get token account balance");return r.result}async getTokenAccountsByOwner(t,e,n){const{commitment:s,config:r}=L(n);let i=[t.toBase58()];"mint"in e?i.push({mint:e.mint.toBase58()}):i.push({programId:e.programId.toBase58()});const a=this._buildArgs(i,s,"base64",r),c=await this._rpcRequest("getTokenAccountsByOwner",a),l=f(c,Ts);if("error"in l)throw new _(l.error,`failed to get token accounts owned by account ${t.toBase58()}`);return l.result}async getParsedTokenAccountsByOwner(t,e,n){let s=[t.toBase58()];"mint"in e?s.push({mint:e.mint.toBase58()}):s.push({programId:e.programId.toBase58()});const r=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",r),a=f(i,Rs);if("error"in a)throw new _(a.error,`failed to get token accounts owned by account ${t.toBase58()}`);return a.result}async getLargestAccounts(t){const e={...t,commitment:t&&t.commitment||this.commitment},n=e.filter||e.commitment?[e]:[],s=await this._rpcRequest("getLargestAccounts",n),r=f(s,Ps);if("error"in r)throw new _(r.error,"failed to get largest accounts");return r.result}async getTokenLargestAccounts(t,e){const n=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenLargestAccounts",n),r=f(s,Cs);if("error"in r)throw new _(r.error,"failed to get token largest accounts");return r.result}async getAccountInfoAndContext(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgs([t.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",r),a=f(i,N(p(At)));if("error"in a)throw new _(a.error,`failed to get info about account ${t.toBase58()}`);return a.result}async getParsedAccountInfo(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgs([t.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",r),a=f(i,N(p(Yt)));if("error"in a)throw new _(a.error,`failed to get info about account ${t.toBase58()}`);return a.result}async getAccountInfo(t,e){try{return(await this.getAccountInfoAndContext(t,e)).value}catch(n){throw new Error("failed to get info about account "+t.toBase58()+": "+n)}}async getMultipleParsedAccounts(t,e){const{commitment:n,config:s}=L(e),r=t.map(l=>l.toBase58()),i=this._buildArgs([r],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=f(a,N(m(p(Yt))));if("error"in c)throw new _(c.error,`failed to get info for accounts ${r}`);return c.result}async getMultipleAccountsInfoAndContext(t,e){const{commitment:n,config:s}=L(e),r=t.map(l=>l.toBase58()),i=this._buildArgs([r],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=f(a,N(m(p(At))));if("error"in c)throw new _(c.error,`failed to get info for accounts ${r}`);return c.result}async getMultipleAccountsInfo(t,e){return(await this.getMultipleAccountsInfoAndContext(t,e)).value}async getStakeActivation(t,e,n){const{commitment:s,config:r}=L(e),i=this._buildArgs([t.toBase58()],s,void 0,{...r,epoch:n??(r==null?void 0:r.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=f(a,E(Os));if("error"in c)throw new _(c.error,`failed to get Stake Activation ${t.toBase58()}`);return c.result}async getProgramAccounts(t,e){const{commitment:n,config:s}=L(e),{encoding:r,...i}=s||{},a=this._buildArgs([t.toBase58()],n,r||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),l=m(Ls),y=i.withContext===!0?f(c,N(l)):f(c,E(l));if("error"in y)throw new _(y.error,`failed to get accounts owned by program ${t.toBase58()}`);return y.result}async getParsedProgramAccounts(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgs([t.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",r),a=f(i,E(m(Ns)));if("error"in a)throw new _(a.error,`failed to get accounts owned by program ${t.toBase58()}`);return a.result}async confirmTransaction(t,e){var n;let s;if(typeof t=="string")s=t;else{const i=t;if((n=i.abortSignal)!=null&&n.aborted)return Promise.reject(i.abortSignal.reason);s=i.signature}let r;try{r=U.decode(s)}catch{throw new Error("signature must be base58 encoded: "+s)}return O(r.length===64,"signature has invalid length"),typeof t=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:e||this.commitment,signature:s}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:e||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise((e,n)=>{t!=null&&(t.aborted?n(t.reason):t.addEventListener("abort",()=>{n(t.reason)}))})}getTransactionConfirmationPromise({commitment:t,signature:e}){let n,s,r=!1;const i=new Promise((a,c)=>{try{n=this.onSignature(e,(y,w)=>{n=void 0;const k={context:w,value:y};a({__type:et.PROCESSED,response:k})},t);const l=new Promise(y=>{n==null?y():s=this._onSubscriptionStateChange(n,w=>{w==="subscribed"&&y()})});(async()=>{if(await l,r)return;const y=await this.getSignatureStatus(e);if(r||y==null)return;const{context:w,value:k}=y;if(k!=null)if(k!=null&&k.err)c(k.err);else{switch(t){case"confirmed":case"single":case"singleGossip":{if(k.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(k.confirmationStatus==="processed"||k.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}r=!0,a({__type:et.PROCESSED,response:{context:w,value:k}})}})()}catch(l){c(l)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t,strategy:{abortSignal:e,lastValidBlockHeight:n,signature:s}}){let r=!1;const i=new Promise(w=>{const k=async()=>{try{return await this.getBlockHeight(t)}catch{return-1}};(async()=>{let b=await k();if(!r){for(;b<=n;)if(await ht(1e3),r||(b=await k(),r))return;w({__type:et.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:t,signature:s}),l=this.getCancellationPromise(e);let y;try{const w=await Promise.race([l,c,i]);if(w.__type===et.PROCESSED)y=w.response;else throw new oe(s)}finally{r=!0,a()}return y}async confirmTransactionUsingDurableNonceStrategy({commitment:t,strategy:{abortSignal:e,minContextSlot:n,nonceAccountPubkey:s,nonceValue:r,signature:i}}){let a=!1;const c=new Promise(b=>{let S=r,h=null;const B=async()=>{try{const{context:R,value:z}=await this.getNonceAndContext(s,{commitment:t,minContextSlot:n});return h=R.slot,z==null?void 0:z.nonce}catch{return S}};(async()=>{if(S=await B(),!a)for(;;){if(r!==S){b({__type:et.NONCE_INVALID,slotInWhichNonceDidAdvance:h});return}if(await ht(2e3),a||(S=await B(),a))return}})()}),{abortConfirmation:l,confirmationPromise:y}=this.getTransactionConfirmationPromise({commitment:t,signature:i}),w=this.getCancellationPromise(e);let k;try{const b=await Promise.race([w,y,c]);if(b.__type===et.PROCESSED)k=b.response;else{let S;for(;;){const h=await this.getSignatureStatus(i);if(h==null)break;if(h.context.slot<(b.slotInWhichNonceDidAdvance??n)){await ht(400);continue}S=h;break}if(S!=null&&S.value){const h=t||"finalized",{confirmationStatus:B}=S.value;switch(h){case"processed":case"recent":if(B!=="processed"&&B!=="confirmed"&&B!=="finalized")throw new kt(i);break;case"confirmed":case"single":case"singleGossip":if(B!=="confirmed"&&B!=="finalized")throw new kt(i);break;case"finalized":case"max":case"root":if(B!=="finalized")throw new kt(i);break;default:}k={context:S.context,value:{err:S.value.err}}}else throw new kt(i)}}finally{a=!0,l()}return k}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:t,signature:e}){let n;const s=new Promise(c=>{let l=this._confirmTransactionInitialTimeout||6e4;switch(t){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{l=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:et.TIMED_OUT,timeoutMs:l}),l)}),{abortConfirmation:r,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:t,signature:e});let a;try{const c=await Promise.race([i,s]);if(c.__type===et.PROCESSED)a=c.response;else throw new Re(e,c.timeoutMs/1e3)}finally{clearTimeout(n),r()}return a}async getClusterNodes(){const t=await this._rpcRequest("getClusterNodes",[]),e=f(t,E(m(Js)));if("error"in e)throw new _(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(t){const e=this._buildArgs([],t),n=await this._rpcRequest("getVoteAccounts",e),s=f(n,Gs);if("error"in s)throw new _(s.error,"failed to get vote accounts");return s.result}async getSlot(t){const{commitment:e,config:n}=L(t),s=this._buildArgs([],e,void 0,n),r=await this._rpcRequest("getSlot",s),i=f(r,E(u()));if("error"in i)throw new _(i.error,"failed to get slot");return i.result}async getSlotLeader(t){const{commitment:e,config:n}=L(t),s=this._buildArgs([],e,void 0,n),r=await this._rpcRequest("getSlotLeader",s),i=f(r,E(g()));if("error"in i)throw new _(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(t,e){const n=[t,e],s=await this._rpcRequest("getSlotLeaders",n),r=f(s,E(m(W)));if("error"in r)throw new _(r.error,"failed to get slot leaders");return r.result}async getSignatureStatus(t,e){const{context:n,value:s}=await this.getSignatureStatuses([t],e);O(s.length===1);const r=s[0];return{context:n,value:r}}async getSignatureStatuses(t,e){const n=[t];e&&n.push(e);const s=await this._rpcRequest("getSignatureStatuses",n),r=f(s,Qs);if("error"in r)throw new _(r.error,"failed to get signature status");return r.result}async getTransactionCount(t){const{commitment:e,config:n}=L(t),s=this._buildArgs([],e,void 0,n),r=await this._rpcRequest("getTransactionCount",s),i=f(r,E(u()));if("error"in i)throw new _(i.error,"failed to get transaction count");return i.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const e=this._buildArgs([],t),n=await this._rpcRequest("getInflationGovernor",e),s=f(n,Ss);if("error"in s)throw new _(s.error,"failed to get inflation");return s.result}async getInflationReward(t,e,n){const{commitment:s,config:r}=L(n),i=this._buildArgs([t.map(l=>l.toBase58())],s,void 0,{...r,epoch:e??(r==null?void 0:r.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=f(a,cs);if("error"in c)throw new _(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const t=await this._rpcRequest("getInflationRate",[]),e=f(t,vs);if("error"in e)throw new _(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(t){const{commitment:e,config:n}=L(t),s=this._buildArgs([],e,void 0,n),r=await this._rpcRequest("getEpochInfo",s),i=f(r,As);if("error"in i)throw new _(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const t=await this._rpcRequest("getEpochSchedule",[]),e=f(t,Is);if("error"in e)throw new _(e.error,"failed to get epoch schedule");const n=e.result;return new Zn(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const t=await this._rpcRequest("getLeaderSchedule",[]),e=f(t,Bs);if("error"in e)throw new _(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(t,e){const n=this._buildArgs([t],e),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),r=f(s,Ys);return"error"in r?(console.warn("Unable to fetch minimum balance for rent exemption"),0):r.result}async getRecentBlockhashAndContext(t){const e=this._buildArgs([],t),n=await this._rpcRequest("getRecentBlockhash",e),s=f(n,ur);if("error"in s)throw new _(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(t){const e=await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),n=f(e,gr);if("error"in n)throw new _(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(t,e){const n=this._buildArgs([t],e),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),r=f(s,fr);if("error"in r)throw new _(r.error,"failed to get fee calculator");const{context:i,value:a}=r.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(t,e){const n=ct(t.serialize()).toString("base64"),s=this._buildArgs([n],e),r=await this._rpcRequest("getFeeForMessage",s),i=f(r,N(p(u())));if("error"in i)throw new _(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(t){var e;const n=(e=t==null?void 0:t.lockedWritableAccounts)==null?void 0:e.map(a=>a.toBase58()),s=n!=null&&n.length?[n]:[],r=await this._rpcRequest("getRecentPrioritizationFees",s),i=f(r,_s);if("error"in i)throw new _(i.error,"failed to get recent prioritization fees");return i.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(t){const{commitment:e,config:n}=L(t),s=this._buildArgs([],e,void 0,n),r=await this._rpcRequest("getLatestBlockhash",s),i=f(r,lr);if("error"in i)throw new _(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgs([t],n,void 0,s),i=await this._rpcRequest("isBlockhashValid",r),a=f(i,dr);if("error"in a)throw new _(a.error,"failed to determine if the blockhash `"+t+"`is valid");return a.result}async getVersion(){const t=await this._rpcRequest("getVersion",[]),e=f(t,E(ms));if("error"in e)throw new _(e.error,"failed to get version");return e.result}async getGenesisHash(){const t=await this._rpcRequest("getGenesisHash",[]),e=f(t,E(g()));if("error"in e)throw new _(e.error,"failed to get genesis hash");return e.result}async getBlock(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgsAtLeastConfirmed([t],n,void 0,s),i=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=f(i,rr);if("error"in a)throw a.error;return a.result}case"none":{const a=f(i,sr);if("error"in a)throw a.error;return a.result}default:{const a=f(i,nr);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:l,meta:y,version:w})=>({meta:y,transaction:{...l,message:jt(w,l.message)},version:w}))}:null}}}catch(a){throw new _(a,"failed to get confirmed block")}}async getParsedBlock(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgsAtLeastConfirmed([t],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=f(i,ir);if("error"in a)throw a.error;return a.result}case"none":{const a=f(i,ar);if("error"in a)throw a.error;return a.result}default:{const a=f(i,or);if("error"in a)throw a.error;return a.result}}}catch(a){throw new _(a,"failed to get block")}}async getBlockProduction(t){let e,n;if(typeof t=="string")n=t;else if(t){const{commitment:a,...c}=t;n=a,e=c}const s=this._buildArgs([],n,"base64",e),r=await this._rpcRequest("getBlockProduction",s),i=f(r,ys);if("error"in i)throw new _(i.error,"failed to get block production information");return i.result}async getTransaction(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgsAtLeastConfirmed([t],n,void 0,s),i=await this._rpcRequest("getTransaction",r),a=f(i,Vt);if("error"in a)throw new _(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:jt(c.version,c.transaction.message)}}}async getParsedTransaction(t,e){const{commitment:n,config:s}=L(e),r=this._buildArgsAtLeastConfirmed([t],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",r),a=f(i,Pt);if("error"in a)throw new _(a.error,"failed to get transaction");return a.result}async getParsedTransactions(t,e){const{commitment:n,config:s}=L(e),r=t.map(i=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([i],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(r)).map(i=>{const a=f(i,Pt);if("error"in a)throw new _(a.error,"failed to get transactions");return a.result})}async getTransactions(t,e){const{commitment:n,config:s}=L(e),r=t.map(i=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([i],n,void 0,s)}));return(await this._rpcBatchRequest(r)).map(i=>{const a=f(i,Vt);if("error"in a)throw new _(a.error,"failed to get transactions");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:jt(c.version,c.transaction.message)}}})}async getConfirmedBlock(t,e){const n=this._buildArgsAtLeastConfirmed([t],e),s=await this._rpcRequest("getConfirmedBlock",n),r=f(s,cr);if("error"in r)throw new _(r.error,"failed to get confirmed block");const i=r.result;if(!i)throw new Error("Confirmed block "+t+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:l})=>{const y=new tt(c.message);return{meta:l,transaction:{...c,message:y}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:nt.populate(c.message,c.signatures)}))}}async getBlocks(t,e,n){const s=this._buildArgsAtLeastConfirmed(e!==void 0?[t,e]:[t],n),r=await this._rpcRequest("getBlocks",s),i=f(r,E(m(u())));if("error"in i)throw new _(i.error,"failed to get blocks");return i.result}async getBlockSignatures(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),r=f(s,_e);if("error"in r)throw new _(r.error,"failed to get block");const i=r.result;if(!i)throw new Error("Block "+t+" not found");return i}async getConfirmedBlockSignatures(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),r=f(s,_e);if("error"in r)throw new _(r.error,"failed to get confirmed block");const i=r.result;if(!i)throw new Error("Confirmed block "+t+" not found");return i}async getConfirmedTransaction(t,e){const n=this._buildArgsAtLeastConfirmed([t],e),s=await this._rpcRequest("getConfirmedTransaction",n),r=f(s,Vt);if("error"in r)throw new _(r.error,"failed to get transaction");const i=r.result;if(!i)return i;const a=new tt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:nt.populate(a,c)}}async getParsedConfirmedTransaction(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),r=f(s,Pt);if("error"in r)throw new _(r.error,"failed to get confirmed transaction");return r.result}async getParsedConfirmedTransactions(t,e){const n=t.map(s=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([s],e,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(s=>{const r=f(s,Pt);if("error"in r)throw new _(r.error,"failed to get confirmed transactions");return r.result})}async getConfirmedSignaturesForAddress(t,e,n){let s={},r=await this.getFirstAvailableBlock();for(;!("until"in s)&&(e--,!(e<=0||e<r));)try{const a=await this.getConfirmedBlockSignatures(e,"finalized");a.signatures.length>0&&(s.until=a.signatures[a.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const a=await this.getConfirmedBlockSignatures(n);a.signatures.length>0&&(s.before=a.signatures[a.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}return(await this.getConfirmedSignaturesForAddress2(t,s)).map(a=>a.signature)}async getConfirmedSignaturesForAddress2(t,e,n){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],n,void 0,e),r=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=f(r,qs);if("error"in i)throw new _(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(t,e,n){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],n,void 0,e),r=await this._rpcRequest("getSignaturesForAddress",s),i=f(r,Ws);if("error"in i)throw new _(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(t,e){const{context:n,value:s}=await this.getAccountInfoAndContext(t,e);let r=null;return s!==null&&(r=new ke({key:t,state:ke.deserialize(s.data)})),{context:n,value:r}}async getNonceAndContext(t,e){const{context:n,value:s}=await this.getAccountInfoAndContext(t,e);let r=null;return s!==null&&(r=ae.fromAccountData(s.data)),{context:n,value:r}}async getNonce(t,e){return await this.getNonceAndContext(t,e).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+n)})}async requestAirdrop(t,e){const n=await this._rpcRequest("requestAirdrop",[t.toBase58(),e]),s=f(n,pr);if("error"in s)throw new _(s.error,`airdrop to ${t.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await ht(100);const e=Date.now()-this._blockhashInfo.lastFetch>=rs;if(this._blockhashInfo.latestBlockhash!==null&&!e)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),e=this._blockhashInfo.latestBlockhash,n=e?e.blockhash:null;for(let s=0;s<50;s++){const r=await this.getLatestBlockhash("finalized");if(n!==r.blockhash)return this._blockhashInfo={latestBlockhash:r,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},r;await ht(Mn/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:e,config:n}=L(t),s=this._buildArgs([],e,"base64",n),r=await this._rpcRequest("getStakeMinimumDelegation",s),i=f(r,N(u()));if("error"in i)throw new _(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(t,e,n){if("message"in t){const b=t.serialize(),S=C.Buffer.from(b).toString("base64");if(Array.isArray(e)||n!==void 0)throw new Error("Invalid arguments");const h=e||{};h.encoding="base64","commitment"in h||(h.commitment=this.commitment);const B=[S,h],R=await this._rpcRequest("simulateTransaction",B),z=f(R,Se);if("error"in z)throw new Error("failed to simulate transaction: "+z.error.message);return z.result}let s;if(t instanceof nt){let b=t;s=new nt,s.feePayer=b.feePayer,s.instructions=t.instructions,s.nonceInfo=b.nonceInfo,s.signatures=b.signatures}else s=nt.populate(t),s._message=s._json=void 0;if(e!==void 0&&!Array.isArray(e))throw new Error("Invalid arguments");const r=e;if(s.nonceInfo&&r)s.sign(...r);else{let b=this._disableBlockhashCaching;for(;;){const S=await this._blockhashWithExpiryBlockHeight(b);if(s.lastValidBlockHeight=S.lastValidBlockHeight,s.recentBlockhash=S.blockhash,!r)break;if(s.sign(...r),!s.signature)throw new Error("!signature");const h=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(h)&&!this._blockhashInfo.transactionSignatures.includes(h)){this._blockhashInfo.simulatedSignatures.push(h);break}else b=!0}}const i=s._compile(),a=i.serialize(),c=s._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(n){const b=(Array.isArray(n)?n:i.nonProgramIds()).map(S=>S.toBase58());l.accounts={encoding:"base64",addresses:b}}r&&(l.sigVerify=!0);const y=[c,l],w=await this._rpcRequest("simulateTransaction",y),k=f(w,Se);if("error"in k){let b;if("data"in k.error&&(b=k.error.data.logs,b&&Array.isArray(b))){const S=`
    `,h=S+b.join(S);console.error(k.error.message,h)}throw new Xt("failed to simulate transaction: "+k.error.message,b)}return k.result}async sendTransaction(t,e,n){if("version"in t){if(e&&Array.isArray(e))throw new Error("Invalid arguments");const i=t.serialize();return await this.sendRawTransaction(i,e)}if(e===void 0||!Array.isArray(e))throw new Error("Invalid arguments");const s=e;if(t.nonceInfo)t.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(t.lastValidBlockHeight=a.lastValidBlockHeight,t.recentBlockhash=a.blockhash,t.sign(...s),!t.signature)throw new Error("!signature");const c=t.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const r=t.serialize();return await this.sendRawTransaction(r,n)}async sendRawTransaction(t,e){const n=ct(t).toString("base64");return await this.sendEncodedTransaction(n,e)}async sendEncodedTransaction(t,e){const n={encoding:"base64"},s=e&&e.skipPreflight,r=s===!0?"processed":e&&e.preflightCommitment||this.commitment;e&&e.maxRetries!=null&&(n.maxRetries=e.maxRetries),e&&e.minContextSlot!=null&&(n.minContextSlot=e.minContextSlot),s&&(n.skipPreflight=s),r&&(n.preflightCommitment=r);const i=[t,n],a=await this._rpcRequest("sendTransaction",i),c=f(a,mr);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new Xt("failed to send transaction: "+c.error.message,l)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),t===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,n])=>{this._setSubscription(e,{...n,state:"pending"})})}_setSubscription(t,e){var n;const s=(n=this._subscriptionsByHash[t])==null?void 0:n.state;if(this._subscriptionsByHash[t]=e,s!==e.state){const r=this._subscriptionStateChangeCallbacksByHash[t];r&&r.forEach(i=>{try{i(e.state)}catch{}})}}_onSubscriptionStateChange(t,e){var n;const s=this._subscriptionHashByClientSubscriptionId[t];if(s==null)return()=>{};const r=(n=this._subscriptionStateChangeCallbacksByHash)[s]||(n[s]=new Set);return r.add(e),()=>{r.delete(e),r.size===0&&delete this._subscriptionStateChangeCallbacksByHash[s]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const t=this._rpcWebSocketGeneration,e=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:r,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,r);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,r,a.message),!e())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:r,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(r))this._subscriptionsAutoDisposedByRpc.delete(r);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[r])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!e())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(t,e){const n=this._subscriptionCallbacksByServerSubscriptionId[t];n!==void 0&&n.forEach(s=>{try{s(...e)}catch(r){console.error(r)}})}_wsOnAccountNotification(t){const{result:e,subscription:n}=f(t,zs);this._handleServerNotification(n,[e.value,e.context])}_makeSubscription(t,e){const n=this._nextClientSubscriptionId++,s=be([t.method,e]),r=this._subscriptionsByHash[s];return r===void 0?this._subscriptionsByHash[s]={...t,args:e,callbacks:new Set([t.callback]),state:"pending"}:r.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];O(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(t,e,n){const s=this._buildArgs([t.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:e,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:e,subscription:n}=f(t,Us);this._handleServerNotification(n,[{accountId:e.value.pubkey,accountInfo:e.value.account},e.context])}onProgramAccountChange(t,e,n,s){const r=this._buildArgs([t.toBase58()],n||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:e,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},r)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,e,n){const s=this._buildArgs([typeof t=="object"?{mentions:[t.toString()]}:t],n||this._commitment||"finalized");return this._makeSubscription({callback:e,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:e,subscription:n}=f(t,br);this._handleServerNotification(n,[e.value,e.context])}_wsOnSlotNotification(t){const{result:e,subscription:n}=f(t,$s);this._handleServerNotification(n,[e])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:e,subscription:n}=f(t,Ds);this._handleServerNotification(n,[e])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,e){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)}_buildArgs(t,e,n,s){const r=e||this._commitment;if(r||n||s){let i={};n&&(i.encoding=n),r&&(i.commitment=r),s&&(i=Object.assign(i,s)),t.push(i)}return t}_buildArgsAtLeastConfirmed(t,e,n,s){const r=e||this._commitment;if(r&&!["confirmed","finalized"].includes(r))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,e,n,s)}_wsOnSignatureNotification(t){const{result:e,subscription:n}=f(t,js);e.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,e.value==="receivedSignature"?[{type:"received"},e.context]:[{type:"status",result:e.value},e.context])}onSignature(t,e,n){const s=this._buildArgs([t],n||this._commitment||"finalized"),r=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){e(i.result,a);try{this.removeSignatureListener(r)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return r}onSignatureWithOptions(t,e,n){const{commitment:s,...r}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([t],s,void 0,r),a=this._makeSubscription({callback:(c,l)=>{e(c,l);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:e,subscription:n}=f(t,Vs);this._handleServerNotification(n,[e])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class vt{constructor(t){this._keypair=void 0,this._keypair=t??pe()}static generate(){return new vt(pe())}static fromSecretKey(t,e){if(t.byteLength!==64)throw new Error("bad secret key size");const n=t.slice(32,64);if(!e||!e.skipValidation){const s=t.slice(0,32),r=Gt(s);for(let i=0;i<32;i++)if(n[i]!==r[i])throw new Error("provided secretKey is invalid")}return new vt({publicKey:n,secretKey:t})}static fromSeed(t){const e=Gt(t),n=new Uint8Array(64);return n.set(t),n.set(e,32),new vt({publicKey:e,secretKey:n})}get publicKey(){return new v(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:A([I("instruction"),mt("recentSlot"),P("bumpSeed")])},FreezeLookupTable:{index:1,layout:A([I("instruction")])},ExtendLookupTable:{index:2,layout:A([I("instruction"),mt(),$(T(),ft(I(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:A([I("instruction")])},CloseLookupTable:{index:4,layout:A([I("instruction")])}});new v("AddressLookupTab1e1111111111111111111111111");const Lt=Object.freeze({RequestUnits:{index:0,layout:A([P("instruction"),I("units"),I("additionalFee")])},RequestHeapFrame:{index:1,layout:A([P("instruction"),I("bytes")])},SetComputeUnitLimit:{index:2,layout:A([P("instruction"),I("units")])},SetComputeUnitPrice:{index:3,layout:A([P("instruction"),mt("microLamports")])}});class te{constructor(){}static requestUnits(t){const e=Lt.RequestUnits,n=Rt(e,t);return new at({keys:[],programId:this.programId,data:n})}static requestHeapFrame(t){const e=Lt.RequestHeapFrame,n=Rt(e,t);return new at({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(t){const e=Lt.SetComputeUnitLimit,n=Rt(e,t);return new at({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(t){const e=Lt.SetComputeUnitPrice,n=Rt(e,{microLamports:BigInt(t.microLamports)});return new at({keys:[],programId:this.programId,data:n})}}te.programId=new v("ComputeBudget111111111111111111111111111111");A([P("numSignatures"),P("padding"),G("signatureOffset"),G("signatureInstructionIndex"),G("publicKeyOffset"),G("publicKeyInstructionIndex"),G("messageDataOffset"),G("messageDataSize"),G("messageInstructionIndex")]);new v("Ed25519SigVerify111111111111111111111111111");Ae.utils.isValidPrivateKey;Ae.getPublicKey;A([P("numSignatures"),G("signatureOffset"),P("signatureInstructionIndex"),G("ethAddressOffset"),P("ethAddressInstructionIndex"),G("messageDataOffset"),G("messageDataSize"),P("messageInstructionIndex"),q(20,"ethAddress"),q(64,"signature"),P("recoveryId")]);new v("KeccakSecp256k11111111111111111111111111111");var De;new v("StakeConfig11111111111111111111111111111111");class je{constructor(t,e,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=n}}De=je;je.default=new De(0,0,v.default);Object.freeze({Initialize:{index:0,layout:A([I("instruction"),Kn(),Nn()])},Authorize:{index:1,layout:A([I("instruction"),T("newAuthorized"),I("stakeAuthorizationType")])},Delegate:{index:2,layout:A([I("instruction")])},Split:{index:3,layout:A([I("instruction"),D("lamports")])},Withdraw:{index:4,layout:A([I("instruction"),D("lamports")])},Deactivate:{index:5,layout:A([I("instruction")])},Merge:{index:7,layout:A([I("instruction")])},AuthorizeWithSeed:{index:8,layout:A([I("instruction"),T("newAuthorized"),I("stakeAuthorizationType"),gt("authoritySeed"),T("authorityOwner")])}});new v("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:A([I("instruction"),On()])},Authorize:{index:1,layout:A([I("instruction"),T("newAuthorized"),I("voteAuthorizationType")])},Withdraw:{index:3,layout:A([I("instruction"),D("lamports")])},UpdateValidatorIdentity:{index:4,layout:A([I("instruction")])},AuthorizeWithSeed:{index:10,layout:A([I("instruction"),qn()])}});new v("Vote111111111111111111111111111111111111111");new v("Va1idator1nfo111111111111111111111111111111");d({name:g(),website:x(g()),details:x(g()),keybaseUsername:x(g())});new v("Vote111111111111111111111111111111111111111");A([T("nodePubkey"),T("authorizedWithdrawer"),P("commission"),M(),$(A([M("slot"),I("confirmationCount")]),ft(I(),-8),"votes"),P("rootSlotValid"),M("rootSlot"),M(),$(A([M("epoch"),T("authorizedVoter")]),ft(I(),-8),"authorizedVoters"),A([$(A([T("authorizedPubkey"),M("epochOfLastAuthorizedSwitch"),M("targetEpoch")]),32,"buf"),M("idx"),P("isEmpty")],"priorVoters"),M(),$(A([M("epoch"),M("credits"),M("prevCredits")]),ft(I(),-8),"epochCredits"),A([M("slot"),M("timestamp")],"lastTimestamp")]);const Mt="Solana",Sr="11111111111111111111111111111111",ee=class Ot{constructor(t){F(this,"type","Native"),F(this,"address"),Ot.instanceof(t)?this.address=t.address:ge.instanceof(t)?this.address=new v(t.toUint8Array()):typeof t=="string"&&Jt.valid(t)?this.address=new v(Jt.decode(t)):this.address=new v(t)}unwrap(){return this.address}toString(){return this.address.toBase58()}toUint8Array(){return new Uint8Array(this.address.toBytes())}toNative(){return this}toUniversalAddress(){return new ge(this.toUint8Array())}static instanceof(t){return t.constructor.platform===Ot.platform}equals(t){return Ot.instanceof(t)?t.unwrap().equals(this.unwrap()):this.toUniversalAddress().equals(t)}};F(ee,"byteSize",32),F(ee,"platform",Mt);let ot=ee;tn(Mt,ot);class Ve extends bn{async getTokenAccount(t,e){const{getAssociatedTokenAddress:n}=await Kt(async()=>{const{getAssociatedTokenAddress:a}=await import("./index-DKT3rJAB-BsTutSMp.js");return{getAssociatedTokenAddress:a}},__vite__mapDeps([0,1,2,3])),s=new ot(e).unwrap(),r=new ot(t).unwrap(),i=await n(s,r);return{chain:this.chain,address:new ot(i.toString())}}}const vr=new v("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new v("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const Lr=new v("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new v("So11111111111111111111111111111111111111112");new v("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");const Je=class it extends yn{constructor(t,e){super(t,e??rn(t,it._platform))}getRpc(t,e={commitment:"confirmed",disableRetryOnRateLimit:!0}){if(t in this.config)return new kr(this.config[t].rpc,e);throw new Error("No configuration available for chain: "+t)}getChain(t,e){if(t in this.config)return new Ve(t,this,e);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(t,e){if(!it.isSupportedChain(e))throw new Error(`invalid chain: ${e}`);return on.chainAddress(e,Sr)}static isNativeTokenId(t,e,n){return!this.isSupportedChain(e)||n.chain!==e?!1:this.nativeTokenId(t,e)==n}static isSupportedChain(t){return an(t)===it._platform}static async getDecimals(t,e,n){if(Ht(n))return cn(it._platform);let s=await e.getParsedAccountInfo(new ot(n).unwrap());if(!s||!s.value)throw new Error("could not fetch token details");const{decimals:r}=s.value.data.parsed.info;return r}static async getBalance(t,e,n,s){const r=new v(n);if(Ht(s))return BigInt(await e.getBalance(r));const i=await e.getTokenAccountsByOwner(r,{mint:new ot(s).unwrap()}),a=i.value.length>0?i.value[0].pubkey:r,c=await e.getTokenAccountBalance(a);return BigInt(c.value.amount)}static async getBalances(t,e,n,s){let r;s.includes("native")&&(r=BigInt(await e.getBalance(new v(n))));const i=await e.getParsedTokenAccountsByOwner(new v(n),{programId:new v(vr)});return s.map(a=>{var c,l,y,w;if(Ht(a))return{native:r};const k=new ot(a).toString(),b=(w=(y=(l=(c=i.value.find(S=>{var h,B;return((B=(h=S==null?void 0:S.account.data.parsed)==null?void 0:h.info)==null?void 0:B.mint)===a}))==null?void 0:c.account.data.parsed)==null?void 0:l.info)==null?void 0:y.tokenAmount)==null?void 0:w.amount;return b?{[k]:BigInt(b)}:{[k]:null}}).reduce((a,c)=>Object.assign(a,c),{})}static async sendWait(t,e,n,s){const{blockhash:r,lastValidBlockHeight:i}=await this.latestBlock(e),a=await Promise.all(n.map(l=>e.sendRawTransaction(l,s??{preflightCommitment:e.commitment}))),c=(await Promise.all(a.map(l=>e.confirmTransaction({signature:l,blockhash:r,lastValidBlockHeight:i},e.commitment)))).filter(l=>l.value.err).map(l=>l.value.err);if(c.length>0)throw new Error(`Failed to confirm transaction: ${c}`);return a}static async latestBlock(t,e){return t.getLatestBlockhash(e??t.commitment)}static async getLatestBlock(t){return await t.getSlot()}static async getLatestFinalizedBlock(t){const{lastValidBlockHeight:e}=await this.latestBlock(t,"finalized");return e}static chainFromChainId(t){const e=un(it._platform,t);if(!e)throw new Error(`No matching genesis hash to determine network and chain: ${t}`);const[n,s]=e;return[n,s]}static async chainFromRpc(t){try{const e=await t.getGenesisHash();return it.chainFromChainId(e)}catch(e){if(t.rpcEndpoint.includes("http://127")||t.rpcEndpoint.includes("http://localhost")||t.rpcEndpoint==="http://solana-devnet:8899")return["Devnet","Solana"];throw e}}};F(Je,"_platform",Mt);let It=Je;class Kr{constructor(t,e,n,s,r=!1){F(this,"transaction"),F(this,"network"),F(this,"chain"),F(this,"description"),F(this,"parallelizable"),this.transaction=t,this.network=e,this.chain=n,this.description=s,this.parallelizable=r}}function $t(o){return o.signatures!==void 0&&o.message!==void 0}const Ge=.5,Xe=1,Ze=1,Qe=1e9,Ye=5,_r=25e4;async function Ar(o,t,e){const[n,s]=await It.chainFromRpc(o),r=typeof t=="string"?vt.fromSecretKey(gn.decode(t)):t;if(e!=null&&e.priorityFee&&e.priorityFee.percentile&&e.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new Ir(o,s,r,(e==null?void 0:e.debug)??!1,(e==null?void 0:e.priorityFee)??{},(e==null?void 0:e.retries)??Ye,e==null?void 0:e.sendOpts)}class Ir{constructor(t,e,n,s=!1,r,i=Ye,a){F(this,"_rpc"),F(this,"_chain"),F(this,"_keypair"),F(this,"_debug"),F(this,"_priorityFee"),F(this,"_maxResubmits"),F(this,"_sendOpts"),this._rpc=t,this._chain=e,this._keypair=n,this._debug=s,this._priorityFee=r,this._maxResubmits=i,this._sendOpts=a,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(t){var e;if(t instanceof oe)return!0;if(!(t instanceof Xt)||!t.message.includes("Transaction simulation failed"))return!1;if(t.message.includes("Blockhash not found"))return!0;const n=(e=t.logs)==null?void 0:e.find(s=>s.startsWith("Program log: Error: "));return n?!!(n.includes("Not enough bytes")||n.includes("Unexpected length of input")):!1}async signAndSend(t){var e;let{blockhash:n,lastValidBlockHeight:s}=await It.latestBlock(this._rpc);const r=[];for(const a of t){const{description:c,transaction:{transaction:l,signers:y}}=a;this._debug&&console.log(`Signing: ${c} for ${this.address()}`);let w;(e=this._priorityFee)!=null&&e.percentile&&this._priorityFee.percentile>0&&(w=await xr(this._rpc,l,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&Br(l);for(let k=0;k<this._maxResubmits;k++)try{if($t(l)){if(w){const S=ie.decompile(l.message);S.instructions.push(...w),l.message=S.compileToV0Message()}l.message.recentBlockhash=n,l.sign([this._keypair,...y??[]])}else w&&l.add(...w),l.recentBlockhash=n,l.partialSign(this._keypair,...y??[]);this._debug&&console.log("Submitting transactions ");const b=await this._rpc.sendRawTransaction(l.serialize(),this._sendOpts);r.push(b);break}catch(b){if(k===this._maxResubmits-1||!this.retryable(b))throw b;this._debug&&console.log(`Failed to send transaction on attempt ${k}, retrying: `,b);const{blockhash:S,lastValidBlockHeight:h}=await It.latestBlock(this._rpc);s=h,n=S}}this._debug&&console.log("Waiting for confirmation for: ",r);const i=(await Promise.all(r.map(async a=>{try{return await this._rpc.confirmTransaction({signature:a,blockhash:n,lastValidBlockHeight:s},this._rpc.commitment)}catch(c){throw console.error("Failed to confirm transaction: ",c),c}}))).filter(a=>a.value.err).map(a=>a.value.err);if(i.length>0)throw new Error(`Failed to confirm transaction: ${i}`);return r}}function Br(o){if($t(o)){console.log(o.signatures);const t=o.message,e=t.getAccountKeys();t.compiledInstructions.forEach(n=>{console.log("Program",e.get(n.programIdIndex).toBase58()),console.log("Data: ",Jt.encode(n.data)),console.log("Keys: ",n.accountKeyIndexes.map(s=>[s,e.get(s).toBase58()]))})}else console.log(o.signatures),console.log(o.feePayer),o.instructions.forEach(t=>{console.log("Program",t.programId.toBase58()),console.log("Data: ",t.data.toString("hex")),console.log("Keys: ",t.keys.map(e=>[e,e.pubkey.toBase58()]))})}async function xr(o,t,e=Ge,n=Xe,s=Ze,r=Qe){const[i,a]=await Promise.all([Er(o,t),Cr(o,t,e,n,s,r)]);return[te.setComputeUnitLimit({units:i}),te.setComputeUnitPrice({microLamports:a})]}async function Er(o,t){var e;let n=_r;try{const s=await($t(t),o.simulateTransaction(t));s.value.err&&console.error(`Error simulating Solana transaction: ${s.value.err}`),(e=s==null?void 0:s.value)!=null&&e.unitsConsumed&&(n=Math.round(s.value.unitsConsumed*1.2))}catch(s){console.error(`Failed to calculate compute unit limit for Solana transaction: ${s}`)}return n}async function Cr(o,t,e=Ge,n=Xe,s=Ze,r=Qe){let i=s,a=[];if($t(t)){const c=t.message,l=c.getAccountKeys();a=c.compiledInstructions.flatMap(y=>y.accountKeyIndexes).map(y=>c.isAccountWritable(y)?l.get(y):null).filter(y=>y!==null)}else a=t.instructions.flatMap(c=>c.keys).map(c=>c.isWritable?c.pubkey:null).filter(c=>c!==null);try{const c=await o.getRecentPrioritizationFees({lockedWritableAccounts:a});if(c){const l=c.map(w=>w.prioritizationFee).sort((w,k)=>w-k),y=Math.ceil(l.length*e);if(l.length>y){let w=l[y];n>0&&(w*=n),i=Math.max(i,w)}}}catch(c){console.error("Error fetching Solana recent fees",c)}return Math.min(Math.max(i,s),r)}const Tr={Address:ot,Platform:It,getSigner:Ar,protocols:{WormholeCore:()=>Kt(()=>import("./index-C2SM05Vf-DrEj5SaI.js"),__vite__mapDeps([4,1,2,5,6,3])).then(o=>o.o),TokenBridge:()=>Kt(()=>import("./index-CS1RMSbZ-DZU5EiSz.js"),__vite__mapDeps([7,4,1,2,5,6,3])),CircleBridge:()=>Kt(()=>import("./index-dElhxORT-B_cYUvUZ.js"),__vite__mapDeps([8,1,2,3,5]))},getChain:(o,t,e)=>new Ve(t,new It(o,ln(o,Mt,{[t]:e})))},Nr=Object.freeze(Object.defineProperty({__proto__:null,default:Tr},Symbol.toStringTag,{value:"Module"}));export{Lr as A,v as P,It as S,vr as T,Mt as _,ot as a,Kr as b,Nr as s};
