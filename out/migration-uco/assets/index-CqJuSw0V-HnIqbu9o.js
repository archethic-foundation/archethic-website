import{bK as T,ct as y,aN as E,bz as G,bh as l,aK as re,aF as B,cu as J,cv as oe,bg as _,cw as se,d as ie,cx as O,cy as L,cz as ce,cA as W,cB as de,cC as pe,cD as Z,bW as ge,c4 as ue}from"./index-Bibw8odz.js";import{s as h,A as X,a as he}from"./algorand-C6Gy4I2H-PkWBrzVN.js";import{T as le}from"./create-D7FD56l0-D2uTFRvt.js";import{b as fe}from"./chain-DfK5JtF7-Jmo_aVnV.js";var me=Object.defineProperty,Ae=(a,e,t)=>e in a?me(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,c=(a,e,t)=>(Ae(a,typeof e!="symbol"?e+"":e,t),t);class ye{constructor(e,t,r,n,o=!1){c(this,"transaction"),c(this,"network"),c(this,"chain"),c(this,"description"),c(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=n,this.parallelizable=o}}const Q=1002e3,K=15,V=127,Y=8,N=V*Y,ee=V*K,j=Y*ee,b={_limit:127,encodingLength:a=>{let e=0;for(;a>=128;e++)a>>=7;return e+1},encode:(a,e,t)=>{if(typeof a=="bigint"&&(a=h(a)),a<0)throw new RangeError("value must be unsigned");const r=b.encodingLength(a);if(e=e||new ArrayBuffer(r),t=t||0,e.byteLength<t+r)throw new RangeError("the buffer is too small to encode the number at the offset");const n=new Uint8Array(e,t);let o=0;for(;b._limit<a;)n[o++]=a&b._limit|128,a>>=7;return n[o]=Number(a),n},decode:(a,e=0)=>{let t=0,r=0,n;do{if(n=a[e+r],n===void 0)throw new RangeError("offset out of range");t+=(n&b._limit)<<r*7,r++}while(128<=n);return t}},g={forMessageId:(a,e)=>{const t=T(y(a)).publicKey,r=e.emitter.toUniversalAddress().toUint8Array(),n=E.toBytes(BigInt(G(e.chain)),2),o=l.concat(n,r);return g.fromData({appId:a,appAddress:t,idx:e.sequence/BigInt(j),address:o})},forWrappedAsset:(a,e)=>{if(re(e.address))throw new Error("native asset cannot be a wrapped asset");const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:BigInt(G(e.chain)),address:e.address.toUniversalAddress().toUint8Array()})},forNativeAsset:(a,e)=>{const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:e,address:l.encode("native")})},forGuardianSet:(a,e)=>{const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:BigInt(e),address:l.encode("guardian")})},forEmitter:(a,e)=>{const t=T(y(a)).publicKey;return g.fromData({appId:a,appAddress:t,idx:0n,address:e})},_encode:a=>typeof a=="bigint"?[B.encode(b.encode(a))]:[B.encode(b.encode(a.length)),B.encode(a)],fromData:a=>{const e=["0620010181",...g._encode(a.idx),"4880",...g._encode(a.address),"483110810612443119221244311881",...g._encode(a.appId),"1244312080",...g._encode(a.appAddress),"124431018100124431093203124431153203124422"],t=B.decode(e.join(""));return new J(t)},decodeLocalState:async(a,e,t)=>{let r;try{const s=await a.accountApplicationInformation(t,h(e)).do();r=oe.from_obj_for_encoding(s).appLocalState}catch{return new Uint8Array}const n=_.encode("meta");let o=new Map;for(const s of r.keyValue){if(s.key===n)continue;const p=_.decode(s.key)[0],u=_.decode(s.value.bytes);o.set(p,u)}const i=[];for(let s=0;s<K;s++)o.has(s)&&i.push(o.get(s));return l.concat(...i)},checkBitsSet:async(a,e,t,r)=>{let n=!1,o;const i=await a.accountInformation(t).do(),s=se.from_obj_for_encoding(i).appsLocalState;if(s&&s.forEach(I=>{BigInt(I.id)===e&&(o=I.keyValue)}),(o==null?void 0:o.length)===0)return n;const p=BigInt(j),u=BigInt(8),m=r/p*p,w=h(r-m),x=Math.floor(w/N),k=Math.floor((w-x*N)/8),S=_.encode(E.toBytes(x,1));return o==null||o.forEach(I=>{if(I.key===S){const M=ie.Buffer.from(I.value.bytes,"base64"),P=1<<h(r%u);n=(M[k]&P)!=0;return}}),n},storageAccountExists:async(a,e,t)=>{try{const r=await a.accountApplicationInformation(e,h(t)).do();return Object.keys(r).length>0}catch{}return!1}},A=class d{constructor(e,t,r,n){if(c(this,"network"),c(this,"chain"),c(this,"connection"),c(this,"contracts"),c(this,"chainId"),c(this,"coreAppId"),c(this,"coreAppAddress"),c(this,"tokenBridgeAppId"),c(this,"tokenBridgeAppAddress"),this.network=e,this.chain=t,this.connection=r,this.contracts=n,this.chainId=G(t),!n.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const o=BigInt(n.coreBridge);if(this.coreAppId=o,this.coreAppAddress=y(o),!n.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const i=BigInt(n.tokenBridge);this.tokenBridgeAppId=i,this.tokenBridgeAppAddress=y(i)}getGuardianSet(e){throw new Error("Method not implemented.")}async*verifyMessage(e,t,r){const n=new X(e).toString(),o=await d.submitVAAHeader(this.connection,this.coreAppId,r??this.coreAppId,t,n);for(const i of o.txs)yield this.createUnsignedTx(i,"Core.verifyMessage")}static async fromRpc(e,t){const[r,n]=await he.chainFromRpc(e),o=t[n];if(o.network!==r)throw new Error(`Network mismatch: ${o.network} !== ${r}`);return new d(r,n,e,o.contracts)}async*publishMessage(e,t){const r=new X(e),n=r.toString(),o=await this.connection.getTransactionParams().do(),i=g.forEmitter(this.coreAppId,r.toUint8Array()),{accounts:s,txs:p}=await d.maybeCreateStorageTx(this.connection,n,this.coreAppId,i,o);for(const m of p)yield this.createUnsignedTx(m,"Core.publishMessage",!0);const u=O({from:n,appIndex:h(this.coreAppId),appArgs:[d.publishMessage,t,E.toBytes(0n,8)],accounts:s,onComplete:L.NoOpOC,suggestedParams:o});yield this.createUnsignedTx({tx:u},"Core.publishMessage",!0)}async getMessageFee(){var e;const t=await this.connection.getApplicationByID(h(this.coreAppId)).do(),r=(e=ce.from_obj_for_encoding(t).params.globalState)==null?void 0:e.find(n=>n.key===d.feeKey);return r?BigInt(r.value.uint):0n}async getGuardianSetIndex(){throw new Error("Not implemented")}async parseTransaction(e){const t=await this.connection.pendingTransactionInformation(e).do(),r=W.from_obj_for_encoding(t);return this.parseTx(r).map(n=>({chain:n.emitterChain,emitter:n.emitterAddress,sequence:n.sequence}))}async parseMessages(e){const t=await this.connection.pendingTransactionInformation(e).do(),r=W.from_obj_for_encoding(t);return this.parseTx(r)}parseTx(e){const t=[];if(e.innerTxns&&e.innerTxns.length>0&&t.push(...e.innerTxns.flatMap(p=>this.parseTx(p))),BigInt(e.txn.txn.apid??0)!==this.coreAppId||!e.logs||e.logs.length===0)return t;const r=e.txn.txn.apaa??[];if(r.length!==3||!l.equals(new Uint8Array(r[0]),d.publishMessage))return t;const n=E.decode(e.logs[0]),o=new X(e.txn.txn.snd).toUniversalAddress(),i=new Uint8Array(r[1]),s=E.decode(r[2]);return t.push(le("Uint8Array",{emitterChain:this.chain,emitterAddress:o,sequence:n,guardianSet:0,timestamp:0,consistencyLevel:0,nonce:Number(s),payload:i,signatures:[]})),t}static async maybeCreateStorageTx(e,t,r,n,o){const i=y(r),s=n.address(),p=[];if(await g.storageAccountExists(e,s,r))return{accounts:[s],txs:p};o=o??await e.getTransactionParams().do();const u=de({from:t,to:s,amount:Q,suggestedParams:o});u.fee=u.fee*2,p.push({tx:u});const m=pe({from:s,appIndex:h(r),rekeyTo:i,suggestedParams:o});return m.fee=0,p.push({tx:m,signer:{address:n.address(),signTxn:w=>Promise.resolve(Z(w,n).blob)}}),{accounts:[s],txs:p}}static async submitVAAHeader(e,t,r,n,o,i){i=i??await e.getTransactionParams().do();let s=[];const p=g.forMessageId(r,{chain:n.emitterChain,sequence:n.sequence,emitter:n.emitterAddress}),{accounts:u,txs:m}=await d.maybeCreateStorageTx(e,o,r,p,i);s.push(...m);const w=g.forGuardianSet(t,n.guardianSet),{accounts:[x],txs:k}=await d.maybeCreateStorageTx(e,o,t,w,i);s.push(...k);let S=[...u,x];const I=await g.decodeLocalState(e,t,x),M=ge(n.hash),P=n.signatures.length,D=Math.ceil(P/d.MAX_SIGS_PER_TXN),C=20,F=new J(d.ALGO_VERIFY);for(let U=0;U<D;U++){const H=U*d.MAX_SIGS_PER_TXN,v=n.signatures.slice(H,H+d.MAX_SIGS_PER_TXN),ne=v.length*C,$=new Uint8Array(ne);for(let f=0;f<v.length;f++){const z=v[f],ae=I.slice(z.guardianIndex*C+1,(z.guardianIndex+1)*C+1);$.set(ae,f*20)}const q=O({appArgs:[d.verifySigs,l.concat(...v.map(f=>l.concat(new Uint8Array([f.guardianIndex]),f.signature.encode()))),$,M],accounts:S,appIndex:h(t),from:d.ALGO_VERIFY_HASH,onComplete:L.NoOpOC,suggestedParams:i});q.fee=0,s.push({tx:q,signer:{address:F.address(),signTxn:f=>Promise.resolve(Z(f,F).blob)}})}const R=O({appArgs:[d.verifyVaa,ue(n)],accounts:S,appIndex:h(t),from:o,onComplete:L.NoOpOC,suggestedParams:i});return R.fee=R.fee*(2+D),s.push({tx:R}),{accounts:S,txs:s}}createUnsignedTx(e,t,r=!0){return new ye(e,this.network,this.chain,t,r)}};c(A,"MAX_SIGS_PER_TXN",6),c(A,"ALGO_VERIFY_HASH","EZATROXX2HISIRZDRGXW4LRQ46Z6IUJYYIHU3PJGP7P5IQDPKVX42N767A"),c(A,"ALGO_VERIFY",new Uint8Array([6,32,4,1,0,32,20,38,1,0,49,32,50,3,18,68,49,1,35,18,68,49,16,129,6,18,68,54,26,1,54,26,3,54,26,2,136,0,3,68,34,67,53,2,53,1,53,0,40,53,240,40,53,241,52,0,21,53,5,35,53,3,35,53,4,52,3,52,5,12,65,0,68,52,1,52,0,52,3,129,65,8,34,88,23,52,0,52,3,34,8,36,88,52,0,52,3,129,33,8,36,88,7,0,53,241,53,240,52,2,52,4,37,88,52,240,52,241,80,2,87,12,20,18,68,52,3,129,66,8,53,3,52,4,37,8,53,4,66,255,180,34,137])),c(A,"feeKey",_.encode("MessageFee")),c(A,"verifyVaa",l.encode("verifyVAA")),c(A,"verifySigs",l.encode("verifySigs")),c(A,"publishMessage",l.encode("publishMessage"));let te=A;fe("Algorand","WormholeCore",te);const Se=Object.freeze(Object.defineProperty({__proto__:null,AlgorandWormholeCore:te,BITS_PER_BYTE:Y,BITS_PER_KEY:N,MAX_BITS:j,MAX_BYTES:ee,MAX_BYTES_PER_KEY:V,MAX_KEYS:K,SEED_AMT:Q,StorageLogicSig:g,varint:b},Symbol.toStringTag,{value:"Module"}));export{te as A,g as S,ye as a,Se as i};
