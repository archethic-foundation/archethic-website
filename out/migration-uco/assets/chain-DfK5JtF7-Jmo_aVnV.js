import{aK as p,aQ as u,aR as f,aS as d,aT as m,aJ as w}from"./index-Bibw8odz.js";var B=Object.defineProperty,k=(o,t,i)=>t in o?B(o,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[t]=i,r=(o,t,i)=>(k(o,typeof t!="symbol"?t+"":t,i),i);function P(o){return"getVersion"in o}const e={};function b(o,t,i){t in e||(e[t]={});const s=e[t];if(o in s)throw new Error(`Protocol ${o} for protocol ${t} has already registered`);e[t][o]=i}function T(o,t){const i=m(o)?w.get(o):o;return t in e?i in e[t]:!1}function l(o,t){if(t in e){const i=e[t];if(i&&o in i){const s=i[o];if(s)return s}}throw new Error(`No protocols registered for ${o}:${t}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`)}const y=(o,t,i,s)=>l(o,t).fromRpc(i,s);class A{constructor(t,i){r(this,"network"),r(this,"config"),this.network=t,this.config=i}utils(){return this.constructor}getProtocol(t,i){return y(this.utils()._platform,t,i,this.config)}getProtocolInitializer(t){return l(this.utils()._platform,t)}async parseWormholeMessages(t,i,s){return(await this.getProtocol("WormholeCore",i)).parseTransaction(s)}}class R{constructor(t,i,s){r(this,"network"),r(this,"chain"),r(this,"config"),r(this,"platform"),r(this,"rpc"),r(this,"protocols",new Map),r(this,"supportsWormholeCore",()=>this.supportsProtocol("WormholeCore")),r(this,"getWormholeCore",()=>this.getProtocol("WormholeCore")),r(this,"supportsTokenBridge",()=>this.supportsProtocol("TokenBridge")),r(this,"getTokenBridge",()=>this.getProtocol("TokenBridge")),r(this,"supportsAutomaticTokenBridge",()=>this.supportsProtocol("AutomaticTokenBridge")),r(this,"getAutomaticTokenBridge",()=>this.getProtocol("AutomaticTokenBridge")),r(this,"supportsCircleBridge",()=>this.supportsProtocol("CircleBridge")),r(this,"getCircleBridge",()=>this.getProtocol("CircleBridge")),r(this,"supportsAutomaticCircleBridge",()=>this.supportsProtocol("AutomaticCircleBridge")),r(this,"getAutomaticCircleBridge",()=>this.getProtocol("AutomaticCircleBridge")),r(this,"supportsIbcBridge",()=>this.supportsProtocol("IbcBridge")),r(this,"getIbcBridge",()=>this.getProtocol("IbcBridge")),r(this,"supportsPorticoBridge",()=>this.supportsProtocol("PorticoBridge")),r(this,"getPorticoBridge",()=>this.getProtocol("PorticoBridge")),this.config=i.config[t],this.platform=i,this.chain=this.config.key,this.network=this.config.network,this.rpc=s}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if(p(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const i=u({chain:this.chain,address:t}),s=f(this.network,this.chain,i);if(s)return s.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),t)}async getBalance(t,i){return this.platform.utils().getBalance(this.chain,await this.getRpc(),t,i)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:i}=this.config.wrappedNative;return{chain:this.chain,address:d(this.chain,i)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,i){return{chain:this.chain,address:t}}supportsProtocol(t){return T(this.chain,t)}async getProtocol(t,i,s){if(!i&&this.protocols.has(t))return this.protocols.get(t);const h=i?{...this.config.contracts,...i}:this.config.contracts,c=s??await this.getRpc(),a=this.platform.getProtocolInitializer(t);let n;if(s){if(i)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");n=await this.platform.getProtocol(t,c)}else if(P(a)){const g=await a.getVersion(c,h);n=new a(this.network,this.chain,c,h,g)}else n=new a(this.network,this.chain,c,h);return i||this.protocols.set(t,n),n}}export{A as I,R,b};
